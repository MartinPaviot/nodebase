
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Credential
 * 
 */
export type Credential = $Result.DefaultSelection<Prisma.$CredentialPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model Node
 * 
 */
export type Node = $Result.DefaultSelection<Prisma.$NodePayload>
/**
 * Model Connection
 * 
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>
/**
 * Model Execution
 * 
 */
export type Execution = $Result.DefaultSelection<Prisma.$ExecutionPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model AgentConnection
 * 
 */
export type AgentConnection = $Result.DefaultSelection<Prisma.$AgentConnectionPayload>
/**
 * Model AgentTool
 * 
 */
export type AgentTool = $Result.DefaultSelection<Prisma.$AgentToolPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ConversationActivity
 * 
 */
export type ConversationActivity = $Result.DefaultSelection<Prisma.$ConversationActivityPayload>
/**
 * Model AgentMemory
 * 
 */
export type AgentMemory = $Result.DefaultSelection<Prisma.$AgentMemoryPayload>
/**
 * Model KnowledgeDocument
 * 
 */
export type KnowledgeDocument = $Result.DefaultSelection<Prisma.$KnowledgeDocumentPayload>
/**
 * Model KnowledgeChunk
 * 
 */
export type KnowledgeChunk = $Result.DefaultSelection<Prisma.$KnowledgeChunkPayload>
/**
 * Model KnowledgeSettings
 * 
 */
export type KnowledgeSettings = $Result.DefaultSelection<Prisma.$KnowledgeSettingsPayload>
/**
 * Model AgentTrigger
 * 
 */
export type AgentTrigger = $Result.DefaultSelection<Prisma.$AgentTriggerPayload>
/**
 * Model AgentTemplate
 * 
 */
export type AgentTemplate = $Result.DefaultSelection<Prisma.$AgentTemplatePayload>
/**
 * Model AgentEmbed
 * 
 */
export type AgentEmbed = $Result.DefaultSelection<Prisma.$AgentEmbedPayload>
/**
 * Model AgentEmailAddress
 * 
 */
export type AgentEmailAddress = $Result.DefaultSelection<Prisma.$AgentEmailAddressPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model AgentSwarm
 * 
 */
export type AgentSwarm = $Result.DefaultSelection<Prisma.$AgentSwarmPayload>
/**
 * Model SwarmTask
 * 
 */
export type SwarmTask = $Result.DefaultSelection<Prisma.$SwarmTaskPayload>
/**
 * Model MeetingRecording
 * 
 */
export type MeetingRecording = $Result.DefaultSelection<Prisma.$MeetingRecordingPayload>
/**
 * Model AgentPhoneNumber
 * 
 */
export type AgentPhoneNumber = $Result.DefaultSelection<Prisma.$AgentPhoneNumberPayload>
/**
 * Model PhoneCall
 * 
 */
export type PhoneCall = $Result.DefaultSelection<Prisma.$PhoneCallPayload>
/**
 * Model AgentMetric
 * 
 */
export type AgentMetric = $Result.DefaultSelection<Prisma.$AgentMetricPayload>
/**
 * Model ScanResult
 * 
 */
export type ScanResult = $Result.DefaultSelection<Prisma.$ScanResultPayload>
/**
 * Model Signal
 * 
 */
export type Signal = $Result.DefaultSelection<Prisma.$SignalPayload>
/**
 * Model AgentRun
 * 
 */
export type AgentRun = $Result.DefaultSelection<Prisma.$AgentRunPayload>
/**
 * Model AiEvent
 * 
 */
export type AiEvent = $Result.DefaultSelection<Prisma.$AiEventPayload>
/**
 * Model AgentTrace
 * 
 */
export type AgentTrace = $Result.DefaultSelection<Prisma.$AgentTracePayload>
/**
 * Model ConversationEvaluation
 * 
 */
export type ConversationEvaluation = $Result.DefaultSelection<Prisma.$ConversationEvaluationPayload>
/**
 * Model AgentInsight
 * 
 */
export type AgentInsight = $Result.DefaultSelection<Prisma.$AgentInsightPayload>
/**
 * Model AgentFeedback
 * 
 */
export type AgentFeedback = $Result.DefaultSelection<Prisma.$AgentFeedbackPayload>
/**
 * Model AgentABTest
 * 
 */
export type AgentABTest = $Result.DefaultSelection<Prisma.$AgentABTestPayload>
/**
 * Model OptimizationRun
 * 
 */
export type OptimizationRun = $Result.DefaultSelection<Prisma.$OptimizationRunPayload>
/**
 * Model ModificationProposal
 * 
 */
export type ModificationProposal = $Result.DefaultSelection<Prisma.$ModificationProposalPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CredentialType: {
  OPENAI: 'OPENAI',
  ANTHROPIC: 'ANTHROPIC',
  GEMINI: 'GEMINI'
};

export type CredentialType = (typeof CredentialType)[keyof typeof CredentialType]


export const NodeType: {
  INITIAL: 'INITIAL',
  MANUAL_TRIGGER: 'MANUAL_TRIGGER',
  HTTP_REQUEST: 'HTTP_REQUEST',
  GOOGLE_FORM_TRIGGER: 'GOOGLE_FORM_TRIGGER',
  STRIPE_TRIGGER: 'STRIPE_TRIGGER',
  ANTHROPIC: 'ANTHROPIC',
  GEMINI: 'GEMINI',
  OPENAI: 'OPENAI',
  DISCORD: 'DISCORD',
  SLACK: 'SLACK'
};

export type NodeType = (typeof NodeType)[keyof typeof NodeType]


export const ExecutionStatus: {
  RUNNING: 'RUNNING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export type ExecutionStatus = (typeof ExecutionStatus)[keyof typeof ExecutionStatus]


export const AgentModel: {
  ANTHROPIC: 'ANTHROPIC',
  OPENAI: 'OPENAI',
  GEMINI: 'GEMINI'
};

export type AgentModel = (typeof AgentModel)[keyof typeof AgentModel]


export const ConversationSource: {
  CHAT: 'CHAT',
  EMBED: 'EMBED',
  EMAIL: 'EMAIL',
  PHONE: 'PHONE',
  SLACK: 'SLACK',
  WEBHOOK: 'WEBHOOK',
  SCHEDULE: 'SCHEDULE'
};

export type ConversationSource = (typeof ConversationSource)[keyof typeof ConversationSource]


export const MessageRole: {
  USER: 'USER',
  ASSISTANT: 'ASSISTANT',
  SYSTEM: 'SYSTEM',
  TOOL: 'TOOL'
};

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]


export const ActivityType: {
  MESSAGE_SENT: 'MESSAGE_SENT',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  TOOL_CALLED: 'TOOL_CALLED',
  TOOL_COMPLETED: 'TOOL_COMPLETED',
  TOOL_FAILED: 'TOOL_FAILED',
  EMAIL_SENT: 'EMAIL_SENT',
  EMAIL_RECEIVED: 'EMAIL_RECEIVED',
  CALENDAR_EVENT_CREATED: 'CALENDAR_EVENT_CREATED',
  SLACK_MESSAGE_SENT: 'SLACK_MESSAGE_SENT',
  MEMORY_UPDATED: 'MEMORY_UPDATED',
  KNOWLEDGE_SEARCHED: 'KNOWLEDGE_SEARCHED',
  AGENT_DELEGATED: 'AGENT_DELEGATED',
  CONFIRMATION_REQUESTED: 'CONFIRMATION_REQUESTED',
  CONFIRMATION_APPROVED: 'CONFIRMATION_APPROVED',
  CONFIRMATION_REJECTED: 'CONFIRMATION_REJECTED',
  ERROR_OCCURRED: 'ERROR_OCCURRED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const MemoryCategory: {
  GENERAL: 'GENERAL',
  PREFERENCE: 'PREFERENCE',
  CONTEXT: 'CONTEXT',
  HISTORY: 'HISTORY',
  INSTRUCTION: 'INSTRUCTION'
};

export type MemoryCategory = (typeof MemoryCategory)[keyof typeof MemoryCategory]


export const KnowledgeSourceType: {
  TEXT: 'TEXT',
  FILE_UPLOAD: 'FILE_UPLOAD',
  WEBSITE: 'WEBSITE',
  WEBSITE_CRAWL: 'WEBSITE_CRAWL',
  GOOGLE_DRIVE: 'GOOGLE_DRIVE',
  NOTION: 'NOTION',
  DROPBOX: 'DROPBOX',
  ONEDRIVE: 'ONEDRIVE'
};

export type KnowledgeSourceType = (typeof KnowledgeSourceType)[keyof typeof KnowledgeSourceType]


export const KnowledgeSyncStatus: {
  PENDING: 'PENDING',
  SYNCING: 'SYNCING',
  SYNCED: 'SYNCED',
  ERROR: 'ERROR'
};

export type KnowledgeSyncStatus = (typeof KnowledgeSyncStatus)[keyof typeof KnowledgeSyncStatus]


export const TriggerType: {
  SCHEDULE: 'SCHEDULE',
  WEBHOOK: 'WEBHOOK',
  EMAIL: 'EMAIL',
  CHAT: 'CHAT',
  AGENT_MESSAGE: 'AGENT_MESSAGE'
};

export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType]


export const TemplateCategory: {
  PRODUCTIVITY: 'PRODUCTIVITY',
  SALES: 'SALES',
  MARKETING: 'MARKETING',
  SUPPORT: 'SUPPORT',
  RESEARCH: 'RESEARCH',
  CREATIVE: 'CREATIVE',
  OPERATIONS: 'OPERATIONS',
  CUSTOM: 'CUSTOM'
};

export type TemplateCategory = (typeof TemplateCategory)[keyof typeof TemplateCategory]


export const TemplateRole: {
  ENGINEERING: 'ENGINEERING',
  HUMAN_RESOURCES: 'HUMAN_RESOURCES',
  MARKETING: 'MARKETING',
  OPERATIONS: 'OPERATIONS',
  PRODUCT: 'PRODUCT',
  SALES: 'SALES',
  SUPPORT: 'SUPPORT'
};

export type TemplateRole = (typeof TemplateRole)[keyof typeof TemplateRole]


export const TemplateUseCase: {
  AI_ASSISTANT: 'AI_ASSISTANT',
  CHATBOT: 'CHATBOT',
  COACHING: 'COACHING',
  CONTENT_CREATION: 'CONTENT_CREATION',
  DOCUMENT_PROCESSING: 'DOCUMENT_PROCESSING',
  EMAILS: 'EMAILS',
  MEETINGS: 'MEETINGS',
  OUTREACH: 'OUTREACH',
  PHONE: 'PHONE',
  PRODUCTIVITY: 'PRODUCTIVITY',
  RESEARCH: 'RESEARCH',
  TEAMS: 'TEAMS',
  WEB_SCRAPER: 'WEB_SCRAPER'
};

export type TemplateUseCase = (typeof TemplateUseCase)[keyof typeof TemplateUseCase]


export const EmbedPosition: {
  BOTTOM_RIGHT: 'BOTTOM_RIGHT',
  BOTTOM_LEFT: 'BOTTOM_LEFT',
  TOP_RIGHT: 'TOP_RIGHT',
  TOP_LEFT: 'TOP_LEFT'
};

export type EmbedPosition = (typeof EmbedPosition)[keyof typeof EmbedPosition]


export const IntegrationType: {
  GMAIL: 'GMAIL',
  GOOGLE_CALENDAR: 'GOOGLE_CALENDAR',
  GOOGLE_SHEETS: 'GOOGLE_SHEETS',
  GOOGLE_DRIVE: 'GOOGLE_DRIVE',
  GOOGLE_DOCS: 'GOOGLE_DOCS',
  OUTLOOK: 'OUTLOOK',
  OUTLOOK_CALENDAR: 'OUTLOOK_CALENDAR',
  MICROSOFT_TEAMS: 'MICROSOFT_TEAMS',
  SLACK: 'SLACK',
  NOTION: 'NOTION'
};

export type IntegrationType = (typeof IntegrationType)[keyof typeof IntegrationType]


export const SwarmStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type SwarmStatus = (typeof SwarmStatus)[keyof typeof SwarmStatus]


export const SwarmTaskStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type SwarmTaskStatus = (typeof SwarmTaskStatus)[keyof typeof SwarmTaskStatus]


export const MeetingPlatform: {
  ZOOM: 'ZOOM',
  GOOGLE_MEET: 'GOOGLE_MEET',
  MICROSOFT_TEAMS: 'MICROSOFT_TEAMS',
  OTHER: 'OTHER'
};

export type MeetingPlatform = (typeof MeetingPlatform)[keyof typeof MeetingPlatform]


export const RecordingStatus: {
  SCHEDULED: 'SCHEDULED',
  JOINING: 'JOINING',
  RECORDING: 'RECORDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type RecordingStatus = (typeof RecordingStatus)[keyof typeof RecordingStatus]


export const CallDirection: {
  INBOUND: 'INBOUND',
  OUTBOUND: 'OUTBOUND'
};

export type CallDirection = (typeof CallDirection)[keyof typeof CallDirection]


export const CallStatus: {
  INITIATED: 'INITIATED',
  RINGING: 'RINGING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  NO_ANSWER: 'NO_ANSWER'
};

export type CallStatus = (typeof CallStatus)[keyof typeof CallStatus]


export const ScanCategory: {
  SALES: 'SALES',
  SUPPORT: 'SUPPORT',
  MARKETING: 'MARKETING',
  HR: 'HR',
  FINANCE: 'FINANCE',
  PROJECTS: 'PROJECTS'
};

export type ScanCategory = (typeof ScanCategory)[keyof typeof ScanCategory]


export const SignalSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type SignalSeverity = (typeof SignalSeverity)[keyof typeof SignalSeverity]


export const TraceStatus: {
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  TIMEOUT: 'TIMEOUT',
  CANCELLED: 'CANCELLED'
};

export type TraceStatus = (typeof TraceStatus)[keyof typeof TraceStatus]


export const FeedbackType: {
  THUMBS_UP: 'THUMBS_UP',
  THUMBS_DOWN: 'THUMBS_DOWN',
  USER_EDIT: 'USER_EDIT',
  APPROVAL_REJECT: 'APPROVAL_REJECT',
  EXPLICIT_CORRECTION: 'EXPLICIT_CORRECTION',
  RETRY_REQUEST: 'RETRY_REQUEST'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const ABTestStatus: {
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ABTestStatus = (typeof ABTestStatus)[keyof typeof ABTestStatus]


export const ModificationType: {
  PROMPT_REFINEMENT: 'PROMPT_REFINEMENT',
  MODEL_DOWNGRADE: 'MODEL_DOWNGRADE',
  MODEL_UPGRADE: 'MODEL_UPGRADE',
  ADD_TOOL: 'ADD_TOOL',
  REMOVE_TOOL: 'REMOVE_TOOL',
  ADD_RAG: 'ADD_RAG',
  ADJUST_TEMPERATURE: 'ADJUST_TEMPERATURE',
  ADJUST_MAX_STEPS: 'ADJUST_MAX_STEPS'
};

export type ModificationType = (typeof ModificationType)[keyof typeof ModificationType]


export const ProposalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  APPLIED: 'APPLIED'
};

export type ProposalStatus = (typeof ProposalStatus)[keyof typeof ProposalStatus]

}

export type CredentialType = $Enums.CredentialType

export const CredentialType: typeof $Enums.CredentialType

export type NodeType = $Enums.NodeType

export const NodeType: typeof $Enums.NodeType

export type ExecutionStatus = $Enums.ExecutionStatus

export const ExecutionStatus: typeof $Enums.ExecutionStatus

export type AgentModel = $Enums.AgentModel

export const AgentModel: typeof $Enums.AgentModel

export type ConversationSource = $Enums.ConversationSource

export const ConversationSource: typeof $Enums.ConversationSource

export type MessageRole = $Enums.MessageRole

export const MessageRole: typeof $Enums.MessageRole

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type MemoryCategory = $Enums.MemoryCategory

export const MemoryCategory: typeof $Enums.MemoryCategory

export type KnowledgeSourceType = $Enums.KnowledgeSourceType

export const KnowledgeSourceType: typeof $Enums.KnowledgeSourceType

export type KnowledgeSyncStatus = $Enums.KnowledgeSyncStatus

export const KnowledgeSyncStatus: typeof $Enums.KnowledgeSyncStatus

export type TriggerType = $Enums.TriggerType

export const TriggerType: typeof $Enums.TriggerType

export type TemplateCategory = $Enums.TemplateCategory

export const TemplateCategory: typeof $Enums.TemplateCategory

export type TemplateRole = $Enums.TemplateRole

export const TemplateRole: typeof $Enums.TemplateRole

export type TemplateUseCase = $Enums.TemplateUseCase

export const TemplateUseCase: typeof $Enums.TemplateUseCase

export type EmbedPosition = $Enums.EmbedPosition

export const EmbedPosition: typeof $Enums.EmbedPosition

export type IntegrationType = $Enums.IntegrationType

export const IntegrationType: typeof $Enums.IntegrationType

export type SwarmStatus = $Enums.SwarmStatus

export const SwarmStatus: typeof $Enums.SwarmStatus

export type SwarmTaskStatus = $Enums.SwarmTaskStatus

export const SwarmTaskStatus: typeof $Enums.SwarmTaskStatus

export type MeetingPlatform = $Enums.MeetingPlatform

export const MeetingPlatform: typeof $Enums.MeetingPlatform

export type RecordingStatus = $Enums.RecordingStatus

export const RecordingStatus: typeof $Enums.RecordingStatus

export type CallDirection = $Enums.CallDirection

export const CallDirection: typeof $Enums.CallDirection

export type CallStatus = $Enums.CallStatus

export const CallStatus: typeof $Enums.CallStatus

export type ScanCategory = $Enums.ScanCategory

export const ScanCategory: typeof $Enums.ScanCategory

export type SignalSeverity = $Enums.SignalSeverity

export const SignalSeverity: typeof $Enums.SignalSeverity

export type TraceStatus = $Enums.TraceStatus

export const TraceStatus: typeof $Enums.TraceStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type ABTestStatus = $Enums.ABTestStatus

export const ABTestStatus: typeof $Enums.ABTestStatus

export type ModificationType = $Enums.ModificationType

export const ModificationType: typeof $Enums.ModificationType

export type ProposalStatus = $Enums.ProposalStatus

export const ProposalStatus: typeof $Enums.ProposalStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **Credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.CredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.node`: Exposes CRUD operations for the **Node** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nodes
    * const nodes = await prisma.node.findMany()
    * ```
    */
  get node(): Prisma.NodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Connections
    * const connections = await prisma.connection.findMany()
    * ```
    */
  get connection(): Prisma.ConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.execution`: Exposes CRUD operations for the **Execution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Executions
    * const executions = await prisma.execution.findMany()
    * ```
    */
  get execution(): Prisma.ExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentConnection`: Exposes CRUD operations for the **AgentConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentConnections
    * const agentConnections = await prisma.agentConnection.findMany()
    * ```
    */
  get agentConnection(): Prisma.AgentConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentTool`: Exposes CRUD operations for the **AgentTool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentTools
    * const agentTools = await prisma.agentTool.findMany()
    * ```
    */
  get agentTool(): Prisma.AgentToolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationActivity`: Exposes CRUD operations for the **ConversationActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationActivities
    * const conversationActivities = await prisma.conversationActivity.findMany()
    * ```
    */
  get conversationActivity(): Prisma.ConversationActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentMemory`: Exposes CRUD operations for the **AgentMemory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentMemories
    * const agentMemories = await prisma.agentMemory.findMany()
    * ```
    */
  get agentMemory(): Prisma.AgentMemoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeDocument`: Exposes CRUD operations for the **KnowledgeDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeDocuments
    * const knowledgeDocuments = await prisma.knowledgeDocument.findMany()
    * ```
    */
  get knowledgeDocument(): Prisma.KnowledgeDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeChunk`: Exposes CRUD operations for the **KnowledgeChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeChunks
    * const knowledgeChunks = await prisma.knowledgeChunk.findMany()
    * ```
    */
  get knowledgeChunk(): Prisma.KnowledgeChunkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeSettings`: Exposes CRUD operations for the **KnowledgeSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeSettings
    * const knowledgeSettings = await prisma.knowledgeSettings.findMany()
    * ```
    */
  get knowledgeSettings(): Prisma.KnowledgeSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentTrigger`: Exposes CRUD operations for the **AgentTrigger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentTriggers
    * const agentTriggers = await prisma.agentTrigger.findMany()
    * ```
    */
  get agentTrigger(): Prisma.AgentTriggerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentTemplate`: Exposes CRUD operations for the **AgentTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentTemplates
    * const agentTemplates = await prisma.agentTemplate.findMany()
    * ```
    */
  get agentTemplate(): Prisma.AgentTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentEmbed`: Exposes CRUD operations for the **AgentEmbed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentEmbeds
    * const agentEmbeds = await prisma.agentEmbed.findMany()
    * ```
    */
  get agentEmbed(): Prisma.AgentEmbedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentEmailAddress`: Exposes CRUD operations for the **AgentEmailAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentEmailAddresses
    * const agentEmailAddresses = await prisma.agentEmailAddress.findMany()
    * ```
    */
  get agentEmailAddress(): Prisma.AgentEmailAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentSwarm`: Exposes CRUD operations for the **AgentSwarm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentSwarms
    * const agentSwarms = await prisma.agentSwarm.findMany()
    * ```
    */
  get agentSwarm(): Prisma.AgentSwarmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.swarmTask`: Exposes CRUD operations for the **SwarmTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SwarmTasks
    * const swarmTasks = await prisma.swarmTask.findMany()
    * ```
    */
  get swarmTask(): Prisma.SwarmTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meetingRecording`: Exposes CRUD operations for the **MeetingRecording** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingRecordings
    * const meetingRecordings = await prisma.meetingRecording.findMany()
    * ```
    */
  get meetingRecording(): Prisma.MeetingRecordingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentPhoneNumber`: Exposes CRUD operations for the **AgentPhoneNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentPhoneNumbers
    * const agentPhoneNumbers = await prisma.agentPhoneNumber.findMany()
    * ```
    */
  get agentPhoneNumber(): Prisma.AgentPhoneNumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phoneCall`: Exposes CRUD operations for the **PhoneCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneCalls
    * const phoneCalls = await prisma.phoneCall.findMany()
    * ```
    */
  get phoneCall(): Prisma.PhoneCallDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentMetric`: Exposes CRUD operations for the **AgentMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentMetrics
    * const agentMetrics = await prisma.agentMetric.findMany()
    * ```
    */
  get agentMetric(): Prisma.AgentMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scanResult`: Exposes CRUD operations for the **ScanResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScanResults
    * const scanResults = await prisma.scanResult.findMany()
    * ```
    */
  get scanResult(): Prisma.ScanResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signal`: Exposes CRUD operations for the **Signal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signals
    * const signals = await prisma.signal.findMany()
    * ```
    */
  get signal(): Prisma.SignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentRun`: Exposes CRUD operations for the **AgentRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentRuns
    * const agentRuns = await prisma.agentRun.findMany()
    * ```
    */
  get agentRun(): Prisma.AgentRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiEvent`: Exposes CRUD operations for the **AiEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiEvents
    * const aiEvents = await prisma.aiEvent.findMany()
    * ```
    */
  get aiEvent(): Prisma.AiEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentTrace`: Exposes CRUD operations for the **AgentTrace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentTraces
    * const agentTraces = await prisma.agentTrace.findMany()
    * ```
    */
  get agentTrace(): Prisma.AgentTraceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationEvaluation`: Exposes CRUD operations for the **ConversationEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationEvaluations
    * const conversationEvaluations = await prisma.conversationEvaluation.findMany()
    * ```
    */
  get conversationEvaluation(): Prisma.ConversationEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentInsight`: Exposes CRUD operations for the **AgentInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentInsights
    * const agentInsights = await prisma.agentInsight.findMany()
    * ```
    */
  get agentInsight(): Prisma.AgentInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentFeedback`: Exposes CRUD operations for the **AgentFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentFeedbacks
    * const agentFeedbacks = await prisma.agentFeedback.findMany()
    * ```
    */
  get agentFeedback(): Prisma.AgentFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentABTest`: Exposes CRUD operations for the **AgentABTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentABTests
    * const agentABTests = await prisma.agentABTest.findMany()
    * ```
    */
  get agentABTest(): Prisma.AgentABTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.optimizationRun`: Exposes CRUD operations for the **OptimizationRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptimizationRuns
    * const optimizationRuns = await prisma.optimizationRun.findMany()
    * ```
    */
  get optimizationRun(): Prisma.OptimizationRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modificationProposal`: Exposes CRUD operations for the **ModificationProposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModificationProposals
    * const modificationProposals = await prisma.modificationProposal.findMany()
    * ```
    */
  get modificationProposal(): Prisma.ModificationProposalDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Credential: 'Credential',
    Workflow: 'Workflow',
    Node: 'Node',
    Connection: 'Connection',
    Execution: 'Execution',
    Agent: 'Agent',
    AgentConnection: 'AgentConnection',
    AgentTool: 'AgentTool',
    Conversation: 'Conversation',
    Message: 'Message',
    ConversationActivity: 'ConversationActivity',
    AgentMemory: 'AgentMemory',
    KnowledgeDocument: 'KnowledgeDocument',
    KnowledgeChunk: 'KnowledgeChunk',
    KnowledgeSettings: 'KnowledgeSettings',
    AgentTrigger: 'AgentTrigger',
    AgentTemplate: 'AgentTemplate',
    AgentEmbed: 'AgentEmbed',
    AgentEmailAddress: 'AgentEmailAddress',
    Integration: 'Integration',
    AgentSwarm: 'AgentSwarm',
    SwarmTask: 'SwarmTask',
    MeetingRecording: 'MeetingRecording',
    AgentPhoneNumber: 'AgentPhoneNumber',
    PhoneCall: 'PhoneCall',
    AgentMetric: 'AgentMetric',
    ScanResult: 'ScanResult',
    Signal: 'Signal',
    AgentRun: 'AgentRun',
    AiEvent: 'AiEvent',
    AgentTrace: 'AgentTrace',
    ConversationEvaluation: 'ConversationEvaluation',
    AgentInsight: 'AgentInsight',
    AgentFeedback: 'AgentFeedback',
    AgentABTest: 'AgentABTest',
    OptimizationRun: 'OptimizationRun',
    ModificationProposal: 'ModificationProposal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "credential" | "workflow" | "node" | "connection" | "execution" | "agent" | "agentConnection" | "agentTool" | "conversation" | "message" | "conversationActivity" | "agentMemory" | "knowledgeDocument" | "knowledgeChunk" | "knowledgeSettings" | "agentTrigger" | "agentTemplate" | "agentEmbed" | "agentEmailAddress" | "integration" | "agentSwarm" | "swarmTask" | "meetingRecording" | "agentPhoneNumber" | "phoneCall" | "agentMetric" | "scanResult" | "signal" | "agentRun" | "aiEvent" | "agentTrace" | "conversationEvaluation" | "agentInsight" | "agentFeedback" | "agentABTest" | "optimizationRun" | "modificationProposal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Credential: {
        payload: Prisma.$CredentialPayload<ExtArgs>
        fields: Prisma.CredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findFirst: {
            args: Prisma.CredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findMany: {
            args: Prisma.CredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          create: {
            args: Prisma.CredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          createMany: {
            args: Prisma.CredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          delete: {
            args: Prisma.CredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          update: {
            args: Prisma.CredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          deleteMany: {
            args: Prisma.CredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          upsert: {
            args: Prisma.CredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          aggregate: {
            args: Prisma.CredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredential>
          }
          groupBy: {
            args: Prisma.CredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      Node: {
        payload: Prisma.$NodePayload<ExtArgs>
        fields: Prisma.NodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          findFirst: {
            args: Prisma.NodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          findMany: {
            args: Prisma.NodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          create: {
            args: Prisma.NodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          createMany: {
            args: Prisma.NodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          delete: {
            args: Prisma.NodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          update: {
            args: Prisma.NodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          deleteMany: {
            args: Prisma.NodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          upsert: {
            args: Prisma.NodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          aggregate: {
            args: Prisma.NodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNode>
          }
          groupBy: {
            args: Prisma.NodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeCountArgs<ExtArgs>
            result: $Utils.Optional<NodeCountAggregateOutputType> | number
          }
        }
      }
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>
        fields: Prisma.ConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnection>
          }
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number
          }
        }
      }
      Execution: {
        payload: Prisma.$ExecutionPayload<ExtArgs>
        fields: Prisma.ExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>
          }
          findFirst: {
            args: Prisma.ExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>
          }
          findMany: {
            args: Prisma.ExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>[]
          }
          create: {
            args: Prisma.ExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>
          }
          createMany: {
            args: Prisma.ExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>[]
          }
          delete: {
            args: Prisma.ExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>
          }
          update: {
            args: Prisma.ExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>
          }
          deleteMany: {
            args: Prisma.ExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>[]
          }
          upsert: {
            args: Prisma.ExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>
          }
          aggregate: {
            args: Prisma.ExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecution>
          }
          groupBy: {
            args: Prisma.ExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutionCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      AgentConnection: {
        payload: Prisma.$AgentConnectionPayload<ExtArgs>
        fields: Prisma.AgentConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>
          }
          findFirst: {
            args: Prisma.AgentConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>
          }
          findMany: {
            args: Prisma.AgentConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>[]
          }
          create: {
            args: Prisma.AgentConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>
          }
          createMany: {
            args: Prisma.AgentConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>[]
          }
          delete: {
            args: Prisma.AgentConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>
          }
          update: {
            args: Prisma.AgentConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>
          }
          deleteMany: {
            args: Prisma.AgentConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>[]
          }
          upsert: {
            args: Prisma.AgentConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConnectionPayload>
          }
          aggregate: {
            args: Prisma.AgentConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentConnection>
          }
          groupBy: {
            args: Prisma.AgentConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<AgentConnectionCountAggregateOutputType> | number
          }
        }
      }
      AgentTool: {
        payload: Prisma.$AgentToolPayload<ExtArgs>
        fields: Prisma.AgentToolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentToolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentToolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>
          }
          findFirst: {
            args: Prisma.AgentToolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentToolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>
          }
          findMany: {
            args: Prisma.AgentToolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>[]
          }
          create: {
            args: Prisma.AgentToolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>
          }
          createMany: {
            args: Prisma.AgentToolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentToolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>[]
          }
          delete: {
            args: Prisma.AgentToolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>
          }
          update: {
            args: Prisma.AgentToolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>
          }
          deleteMany: {
            args: Prisma.AgentToolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentToolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentToolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>[]
          }
          upsert: {
            args: Prisma.AgentToolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentToolPayload>
          }
          aggregate: {
            args: Prisma.AgentToolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentTool>
          }
          groupBy: {
            args: Prisma.AgentToolGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentToolGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentToolCountArgs<ExtArgs>
            result: $Utils.Optional<AgentToolCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ConversationActivity: {
        payload: Prisma.$ConversationActivityPayload<ExtArgs>
        fields: Prisma.ConversationActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>
          }
          findFirst: {
            args: Prisma.ConversationActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>
          }
          findMany: {
            args: Prisma.ConversationActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>[]
          }
          create: {
            args: Prisma.ConversationActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>
          }
          createMany: {
            args: Prisma.ConversationActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>[]
          }
          delete: {
            args: Prisma.ConversationActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>
          }
          update: {
            args: Prisma.ConversationActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>
          }
          deleteMany: {
            args: Prisma.ConversationActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>[]
          }
          upsert: {
            args: Prisma.ConversationActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationActivityPayload>
          }
          aggregate: {
            args: Prisma.ConversationActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationActivity>
          }
          groupBy: {
            args: Prisma.ConversationActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationActivityCountAggregateOutputType> | number
          }
        }
      }
      AgentMemory: {
        payload: Prisma.$AgentMemoryPayload<ExtArgs>
        fields: Prisma.AgentMemoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentMemoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentMemoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>
          }
          findFirst: {
            args: Prisma.AgentMemoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentMemoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>
          }
          findMany: {
            args: Prisma.AgentMemoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>[]
          }
          create: {
            args: Prisma.AgentMemoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>
          }
          createMany: {
            args: Prisma.AgentMemoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentMemoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>[]
          }
          delete: {
            args: Prisma.AgentMemoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>
          }
          update: {
            args: Prisma.AgentMemoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>
          }
          deleteMany: {
            args: Prisma.AgentMemoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentMemoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentMemoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>[]
          }
          upsert: {
            args: Prisma.AgentMemoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMemoryPayload>
          }
          aggregate: {
            args: Prisma.AgentMemoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentMemory>
          }
          groupBy: {
            args: Prisma.AgentMemoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentMemoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentMemoryCountArgs<ExtArgs>
            result: $Utils.Optional<AgentMemoryCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeDocument: {
        payload: Prisma.$KnowledgeDocumentPayload<ExtArgs>
        fields: Prisma.KnowledgeDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>
          }
          findMany: {
            args: Prisma.KnowledgeDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>[]
          }
          create: {
            args: Prisma.KnowledgeDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>
          }
          createMany: {
            args: Prisma.KnowledgeDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>
          }
          update: {
            args: Prisma.KnowledgeDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeDocumentPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeDocument>
          }
          groupBy: {
            args: Prisma.KnowledgeDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeDocumentCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeChunk: {
        payload: Prisma.$KnowledgeChunkPayload<ExtArgs>
        fields: Prisma.KnowledgeChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          findMany: {
            args: Prisma.KnowledgeChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>[]
          }
          create: {
            args: Prisma.KnowledgeChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          createMany: {
            args: Prisma.KnowledgeChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          update: {
            args: Prisma.KnowledgeChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeChunkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeChunk>
          }
          groupBy: {
            args: Prisma.KnowledgeChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeChunkCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeChunkCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeSettings: {
        payload: Prisma.$KnowledgeSettingsPayload<ExtArgs>
        fields: Prisma.KnowledgeSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>
          }
          findMany: {
            args: Prisma.KnowledgeSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>[]
          }
          create: {
            args: Prisma.KnowledgeSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>
          }
          createMany: {
            args: Prisma.KnowledgeSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>
          }
          update: {
            args: Prisma.KnowledgeSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeSettingsPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeSettings>
          }
          groupBy: {
            args: Prisma.KnowledgeSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeSettingsCountAggregateOutputType> | number
          }
        }
      }
      AgentTrigger: {
        payload: Prisma.$AgentTriggerPayload<ExtArgs>
        fields: Prisma.AgentTriggerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentTriggerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentTriggerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>
          }
          findFirst: {
            args: Prisma.AgentTriggerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentTriggerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>
          }
          findMany: {
            args: Prisma.AgentTriggerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>[]
          }
          create: {
            args: Prisma.AgentTriggerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>
          }
          createMany: {
            args: Prisma.AgentTriggerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentTriggerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>[]
          }
          delete: {
            args: Prisma.AgentTriggerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>
          }
          update: {
            args: Prisma.AgentTriggerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>
          }
          deleteMany: {
            args: Prisma.AgentTriggerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentTriggerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentTriggerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>[]
          }
          upsert: {
            args: Prisma.AgentTriggerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTriggerPayload>
          }
          aggregate: {
            args: Prisma.AgentTriggerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentTrigger>
          }
          groupBy: {
            args: Prisma.AgentTriggerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentTriggerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentTriggerCountArgs<ExtArgs>
            result: $Utils.Optional<AgentTriggerCountAggregateOutputType> | number
          }
        }
      }
      AgentTemplate: {
        payload: Prisma.$AgentTemplatePayload<ExtArgs>
        fields: Prisma.AgentTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>
          }
          findFirst: {
            args: Prisma.AgentTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>
          }
          findMany: {
            args: Prisma.AgentTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>[]
          }
          create: {
            args: Prisma.AgentTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>
          }
          createMany: {
            args: Prisma.AgentTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>[]
          }
          delete: {
            args: Prisma.AgentTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>
          }
          update: {
            args: Prisma.AgentTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>
          }
          deleteMany: {
            args: Prisma.AgentTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>[]
          }
          upsert: {
            args: Prisma.AgentTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTemplatePayload>
          }
          aggregate: {
            args: Prisma.AgentTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentTemplate>
          }
          groupBy: {
            args: Prisma.AgentTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<AgentTemplateCountAggregateOutputType> | number
          }
        }
      }
      AgentEmbed: {
        payload: Prisma.$AgentEmbedPayload<ExtArgs>
        fields: Prisma.AgentEmbedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentEmbedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentEmbedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>
          }
          findFirst: {
            args: Prisma.AgentEmbedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentEmbedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>
          }
          findMany: {
            args: Prisma.AgentEmbedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>[]
          }
          create: {
            args: Prisma.AgentEmbedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>
          }
          createMany: {
            args: Prisma.AgentEmbedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentEmbedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>[]
          }
          delete: {
            args: Prisma.AgentEmbedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>
          }
          update: {
            args: Prisma.AgentEmbedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>
          }
          deleteMany: {
            args: Prisma.AgentEmbedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentEmbedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentEmbedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>[]
          }
          upsert: {
            args: Prisma.AgentEmbedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmbedPayload>
          }
          aggregate: {
            args: Prisma.AgentEmbedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentEmbed>
          }
          groupBy: {
            args: Prisma.AgentEmbedGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentEmbedGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentEmbedCountArgs<ExtArgs>
            result: $Utils.Optional<AgentEmbedCountAggregateOutputType> | number
          }
        }
      }
      AgentEmailAddress: {
        payload: Prisma.$AgentEmailAddressPayload<ExtArgs>
        fields: Prisma.AgentEmailAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentEmailAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentEmailAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>
          }
          findFirst: {
            args: Prisma.AgentEmailAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentEmailAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>
          }
          findMany: {
            args: Prisma.AgentEmailAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>[]
          }
          create: {
            args: Prisma.AgentEmailAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>
          }
          createMany: {
            args: Prisma.AgentEmailAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentEmailAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>[]
          }
          delete: {
            args: Prisma.AgentEmailAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>
          }
          update: {
            args: Prisma.AgentEmailAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>
          }
          deleteMany: {
            args: Prisma.AgentEmailAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentEmailAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentEmailAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>[]
          }
          upsert: {
            args: Prisma.AgentEmailAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentEmailAddressPayload>
          }
          aggregate: {
            args: Prisma.AgentEmailAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentEmailAddress>
          }
          groupBy: {
            args: Prisma.AgentEmailAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentEmailAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentEmailAddressCountArgs<ExtArgs>
            result: $Utils.Optional<AgentEmailAddressCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      AgentSwarm: {
        payload: Prisma.$AgentSwarmPayload<ExtArgs>
        fields: Prisma.AgentSwarmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentSwarmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentSwarmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>
          }
          findFirst: {
            args: Prisma.AgentSwarmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentSwarmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>
          }
          findMany: {
            args: Prisma.AgentSwarmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>[]
          }
          create: {
            args: Prisma.AgentSwarmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>
          }
          createMany: {
            args: Prisma.AgentSwarmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentSwarmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>[]
          }
          delete: {
            args: Prisma.AgentSwarmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>
          }
          update: {
            args: Prisma.AgentSwarmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>
          }
          deleteMany: {
            args: Prisma.AgentSwarmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentSwarmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentSwarmUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>[]
          }
          upsert: {
            args: Prisma.AgentSwarmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSwarmPayload>
          }
          aggregate: {
            args: Prisma.AgentSwarmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentSwarm>
          }
          groupBy: {
            args: Prisma.AgentSwarmGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentSwarmGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentSwarmCountArgs<ExtArgs>
            result: $Utils.Optional<AgentSwarmCountAggregateOutputType> | number
          }
        }
      }
      SwarmTask: {
        payload: Prisma.$SwarmTaskPayload<ExtArgs>
        fields: Prisma.SwarmTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SwarmTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SwarmTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>
          }
          findFirst: {
            args: Prisma.SwarmTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SwarmTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>
          }
          findMany: {
            args: Prisma.SwarmTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>[]
          }
          create: {
            args: Prisma.SwarmTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>
          }
          createMany: {
            args: Prisma.SwarmTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SwarmTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>[]
          }
          delete: {
            args: Prisma.SwarmTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>
          }
          update: {
            args: Prisma.SwarmTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>
          }
          deleteMany: {
            args: Prisma.SwarmTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SwarmTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SwarmTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>[]
          }
          upsert: {
            args: Prisma.SwarmTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwarmTaskPayload>
          }
          aggregate: {
            args: Prisma.SwarmTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSwarmTask>
          }
          groupBy: {
            args: Prisma.SwarmTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<SwarmTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.SwarmTaskCountArgs<ExtArgs>
            result: $Utils.Optional<SwarmTaskCountAggregateOutputType> | number
          }
        }
      }
      MeetingRecording: {
        payload: Prisma.$MeetingRecordingPayload<ExtArgs>
        fields: Prisma.MeetingRecordingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingRecordingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingRecordingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>
          }
          findFirst: {
            args: Prisma.MeetingRecordingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingRecordingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>
          }
          findMany: {
            args: Prisma.MeetingRecordingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>[]
          }
          create: {
            args: Prisma.MeetingRecordingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>
          }
          createMany: {
            args: Prisma.MeetingRecordingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingRecordingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>[]
          }
          delete: {
            args: Prisma.MeetingRecordingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>
          }
          update: {
            args: Prisma.MeetingRecordingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingRecordingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingRecordingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingRecordingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>[]
          }
          upsert: {
            args: Prisma.MeetingRecordingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRecordingPayload>
          }
          aggregate: {
            args: Prisma.MeetingRecordingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingRecording>
          }
          groupBy: {
            args: Prisma.MeetingRecordingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingRecordingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingRecordingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingRecordingCountAggregateOutputType> | number
          }
        }
      }
      AgentPhoneNumber: {
        payload: Prisma.$AgentPhoneNumberPayload<ExtArgs>
        fields: Prisma.AgentPhoneNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentPhoneNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentPhoneNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>
          }
          findFirst: {
            args: Prisma.AgentPhoneNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentPhoneNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>
          }
          findMany: {
            args: Prisma.AgentPhoneNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>[]
          }
          create: {
            args: Prisma.AgentPhoneNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>
          }
          createMany: {
            args: Prisma.AgentPhoneNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentPhoneNumberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>[]
          }
          delete: {
            args: Prisma.AgentPhoneNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>
          }
          update: {
            args: Prisma.AgentPhoneNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>
          }
          deleteMany: {
            args: Prisma.AgentPhoneNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentPhoneNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentPhoneNumberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>[]
          }
          upsert: {
            args: Prisma.AgentPhoneNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPhoneNumberPayload>
          }
          aggregate: {
            args: Prisma.AgentPhoneNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentPhoneNumber>
          }
          groupBy: {
            args: Prisma.AgentPhoneNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentPhoneNumberGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentPhoneNumberCountArgs<ExtArgs>
            result: $Utils.Optional<AgentPhoneNumberCountAggregateOutputType> | number
          }
        }
      }
      PhoneCall: {
        payload: Prisma.$PhoneCallPayload<ExtArgs>
        fields: Prisma.PhoneCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhoneCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>
          }
          findFirst: {
            args: Prisma.PhoneCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhoneCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>
          }
          findMany: {
            args: Prisma.PhoneCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>[]
          }
          create: {
            args: Prisma.PhoneCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>
          }
          createMany: {
            args: Prisma.PhoneCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhoneCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>[]
          }
          delete: {
            args: Prisma.PhoneCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>
          }
          update: {
            args: Prisma.PhoneCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>
          }
          deleteMany: {
            args: Prisma.PhoneCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhoneCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhoneCallUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>[]
          }
          upsert: {
            args: Prisma.PhoneCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneCallPayload>
          }
          aggregate: {
            args: Prisma.PhoneCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoneCall>
          }
          groupBy: {
            args: Prisma.PhoneCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhoneCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhoneCallCountArgs<ExtArgs>
            result: $Utils.Optional<PhoneCallCountAggregateOutputType> | number
          }
        }
      }
      AgentMetric: {
        payload: Prisma.$AgentMetricPayload<ExtArgs>
        fields: Prisma.AgentMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>
          }
          findFirst: {
            args: Prisma.AgentMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>
          }
          findMany: {
            args: Prisma.AgentMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>[]
          }
          create: {
            args: Prisma.AgentMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>
          }
          createMany: {
            args: Prisma.AgentMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>[]
          }
          delete: {
            args: Prisma.AgentMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>
          }
          update: {
            args: Prisma.AgentMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>
          }
          deleteMany: {
            args: Prisma.AgentMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>[]
          }
          upsert: {
            args: Prisma.AgentMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentMetricPayload>
          }
          aggregate: {
            args: Prisma.AgentMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentMetric>
          }
          groupBy: {
            args: Prisma.AgentMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentMetricCountArgs<ExtArgs>
            result: $Utils.Optional<AgentMetricCountAggregateOutputType> | number
          }
        }
      }
      ScanResult: {
        payload: Prisma.$ScanResultPayload<ExtArgs>
        fields: Prisma.ScanResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScanResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScanResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          findFirst: {
            args: Prisma.ScanResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScanResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          findMany: {
            args: Prisma.ScanResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>[]
          }
          create: {
            args: Prisma.ScanResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          createMany: {
            args: Prisma.ScanResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScanResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>[]
          }
          delete: {
            args: Prisma.ScanResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          update: {
            args: Prisma.ScanResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          deleteMany: {
            args: Prisma.ScanResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScanResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScanResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>[]
          }
          upsert: {
            args: Prisma.ScanResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          aggregate: {
            args: Prisma.ScanResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScanResult>
          }
          groupBy: {
            args: Prisma.ScanResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScanResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScanResultCountArgs<ExtArgs>
            result: $Utils.Optional<ScanResultCountAggregateOutputType> | number
          }
        }
      }
      Signal: {
        payload: Prisma.$SignalPayload<ExtArgs>
        fields: Prisma.SignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findFirst: {
            args: Prisma.SignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findMany: {
            args: Prisma.SignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          create: {
            args: Prisma.SignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          createMany: {
            args: Prisma.SignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          delete: {
            args: Prisma.SignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          update: {
            args: Prisma.SignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          deleteMany: {
            args: Prisma.SignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SignalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          upsert: {
            args: Prisma.SignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          aggregate: {
            args: Prisma.SignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignal>
          }
          groupBy: {
            args: Prisma.SignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalCountArgs<ExtArgs>
            result: $Utils.Optional<SignalCountAggregateOutputType> | number
          }
        }
      }
      AgentRun: {
        payload: Prisma.$AgentRunPayload<ExtArgs>
        fields: Prisma.AgentRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>
          }
          findFirst: {
            args: Prisma.AgentRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>
          }
          findMany: {
            args: Prisma.AgentRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>[]
          }
          create: {
            args: Prisma.AgentRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>
          }
          createMany: {
            args: Prisma.AgentRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>[]
          }
          delete: {
            args: Prisma.AgentRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>
          }
          update: {
            args: Prisma.AgentRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>
          }
          deleteMany: {
            args: Prisma.AgentRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>[]
          }
          upsert: {
            args: Prisma.AgentRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRunPayload>
          }
          aggregate: {
            args: Prisma.AgentRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentRun>
          }
          groupBy: {
            args: Prisma.AgentRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentRunCountArgs<ExtArgs>
            result: $Utils.Optional<AgentRunCountAggregateOutputType> | number
          }
        }
      }
      AiEvent: {
        payload: Prisma.$AiEventPayload<ExtArgs>
        fields: Prisma.AiEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>
          }
          findFirst: {
            args: Prisma.AiEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>
          }
          findMany: {
            args: Prisma.AiEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>[]
          }
          create: {
            args: Prisma.AiEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>
          }
          createMany: {
            args: Prisma.AiEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>[]
          }
          delete: {
            args: Prisma.AiEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>
          }
          update: {
            args: Prisma.AiEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>
          }
          deleteMany: {
            args: Prisma.AiEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>[]
          }
          upsert: {
            args: Prisma.AiEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiEventPayload>
          }
          aggregate: {
            args: Prisma.AiEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiEvent>
          }
          groupBy: {
            args: Prisma.AiEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiEventCountArgs<ExtArgs>
            result: $Utils.Optional<AiEventCountAggregateOutputType> | number
          }
        }
      }
      AgentTrace: {
        payload: Prisma.$AgentTracePayload<ExtArgs>
        fields: Prisma.AgentTraceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentTraceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentTraceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>
          }
          findFirst: {
            args: Prisma.AgentTraceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentTraceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>
          }
          findMany: {
            args: Prisma.AgentTraceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>[]
          }
          create: {
            args: Prisma.AgentTraceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>
          }
          createMany: {
            args: Prisma.AgentTraceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentTraceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>[]
          }
          delete: {
            args: Prisma.AgentTraceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>
          }
          update: {
            args: Prisma.AgentTraceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>
          }
          deleteMany: {
            args: Prisma.AgentTraceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentTraceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentTraceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>[]
          }
          upsert: {
            args: Prisma.AgentTraceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTracePayload>
          }
          aggregate: {
            args: Prisma.AgentTraceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentTrace>
          }
          groupBy: {
            args: Prisma.AgentTraceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentTraceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentTraceCountArgs<ExtArgs>
            result: $Utils.Optional<AgentTraceCountAggregateOutputType> | number
          }
        }
      }
      ConversationEvaluation: {
        payload: Prisma.$ConversationEvaluationPayload<ExtArgs>
        fields: Prisma.ConversationEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>
          }
          findFirst: {
            args: Prisma.ConversationEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>
          }
          findMany: {
            args: Prisma.ConversationEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>[]
          }
          create: {
            args: Prisma.ConversationEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>
          }
          createMany: {
            args: Prisma.ConversationEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>[]
          }
          delete: {
            args: Prisma.ConversationEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>
          }
          update: {
            args: Prisma.ConversationEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationEvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationEvaluationPayload>
          }
          aggregate: {
            args: Prisma.ConversationEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationEvaluation>
          }
          groupBy: {
            args: Prisma.ConversationEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationEvaluationCountAggregateOutputType> | number
          }
        }
      }
      AgentInsight: {
        payload: Prisma.$AgentInsightPayload<ExtArgs>
        fields: Prisma.AgentInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>
          }
          findFirst: {
            args: Prisma.AgentInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>
          }
          findMany: {
            args: Prisma.AgentInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>[]
          }
          create: {
            args: Prisma.AgentInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>
          }
          createMany: {
            args: Prisma.AgentInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>[]
          }
          delete: {
            args: Prisma.AgentInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>
          }
          update: {
            args: Prisma.AgentInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>
          }
          deleteMany: {
            args: Prisma.AgentInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>[]
          }
          upsert: {
            args: Prisma.AgentInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInsightPayload>
          }
          aggregate: {
            args: Prisma.AgentInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentInsight>
          }
          groupBy: {
            args: Prisma.AgentInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentInsightCountArgs<ExtArgs>
            result: $Utils.Optional<AgentInsightCountAggregateOutputType> | number
          }
        }
      }
      AgentFeedback: {
        payload: Prisma.$AgentFeedbackPayload<ExtArgs>
        fields: Prisma.AgentFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>
          }
          findFirst: {
            args: Prisma.AgentFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>
          }
          findMany: {
            args: Prisma.AgentFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>[]
          }
          create: {
            args: Prisma.AgentFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>
          }
          createMany: {
            args: Prisma.AgentFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>[]
          }
          delete: {
            args: Prisma.AgentFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>
          }
          update: {
            args: Prisma.AgentFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.AgentFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.AgentFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentFeedbackPayload>
          }
          aggregate: {
            args: Prisma.AgentFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentFeedback>
          }
          groupBy: {
            args: Prisma.AgentFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<AgentFeedbackCountAggregateOutputType> | number
          }
        }
      }
      AgentABTest: {
        payload: Prisma.$AgentABTestPayload<ExtArgs>
        fields: Prisma.AgentABTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentABTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentABTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>
          }
          findFirst: {
            args: Prisma.AgentABTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentABTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>
          }
          findMany: {
            args: Prisma.AgentABTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>[]
          }
          create: {
            args: Prisma.AgentABTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>
          }
          createMany: {
            args: Prisma.AgentABTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentABTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>[]
          }
          delete: {
            args: Prisma.AgentABTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>
          }
          update: {
            args: Prisma.AgentABTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>
          }
          deleteMany: {
            args: Prisma.AgentABTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentABTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentABTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>[]
          }
          upsert: {
            args: Prisma.AgentABTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentABTestPayload>
          }
          aggregate: {
            args: Prisma.AgentABTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentABTest>
          }
          groupBy: {
            args: Prisma.AgentABTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentABTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentABTestCountArgs<ExtArgs>
            result: $Utils.Optional<AgentABTestCountAggregateOutputType> | number
          }
        }
      }
      OptimizationRun: {
        payload: Prisma.$OptimizationRunPayload<ExtArgs>
        fields: Prisma.OptimizationRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptimizationRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptimizationRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>
          }
          findFirst: {
            args: Prisma.OptimizationRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptimizationRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>
          }
          findMany: {
            args: Prisma.OptimizationRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>[]
          }
          create: {
            args: Prisma.OptimizationRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>
          }
          createMany: {
            args: Prisma.OptimizationRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptimizationRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>[]
          }
          delete: {
            args: Prisma.OptimizationRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>
          }
          update: {
            args: Prisma.OptimizationRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>
          }
          deleteMany: {
            args: Prisma.OptimizationRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptimizationRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptimizationRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>[]
          }
          upsert: {
            args: Prisma.OptimizationRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRunPayload>
          }
          aggregate: {
            args: Prisma.OptimizationRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptimizationRun>
          }
          groupBy: {
            args: Prisma.OptimizationRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptimizationRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptimizationRunCountArgs<ExtArgs>
            result: $Utils.Optional<OptimizationRunCountAggregateOutputType> | number
          }
        }
      }
      ModificationProposal: {
        payload: Prisma.$ModificationProposalPayload<ExtArgs>
        fields: Prisma.ModificationProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModificationProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModificationProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>
          }
          findFirst: {
            args: Prisma.ModificationProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModificationProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>
          }
          findMany: {
            args: Prisma.ModificationProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>[]
          }
          create: {
            args: Prisma.ModificationProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>
          }
          createMany: {
            args: Prisma.ModificationProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModificationProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>[]
          }
          delete: {
            args: Prisma.ModificationProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>
          }
          update: {
            args: Prisma.ModificationProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>
          }
          deleteMany: {
            args: Prisma.ModificationProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModificationProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModificationProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>[]
          }
          upsert: {
            args: Prisma.ModificationProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModificationProposalPayload>
          }
          aggregate: {
            args: Prisma.ModificationProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModificationProposal>
          }
          groupBy: {
            args: Prisma.ModificationProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModificationProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModificationProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ModificationProposalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    credential?: CredentialOmit
    workflow?: WorkflowOmit
    node?: NodeOmit
    connection?: ConnectionOmit
    execution?: ExecutionOmit
    agent?: AgentOmit
    agentConnection?: AgentConnectionOmit
    agentTool?: AgentToolOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    conversationActivity?: ConversationActivityOmit
    agentMemory?: AgentMemoryOmit
    knowledgeDocument?: KnowledgeDocumentOmit
    knowledgeChunk?: KnowledgeChunkOmit
    knowledgeSettings?: KnowledgeSettingsOmit
    agentTrigger?: AgentTriggerOmit
    agentTemplate?: AgentTemplateOmit
    agentEmbed?: AgentEmbedOmit
    agentEmailAddress?: AgentEmailAddressOmit
    integration?: IntegrationOmit
    agentSwarm?: AgentSwarmOmit
    swarmTask?: SwarmTaskOmit
    meetingRecording?: MeetingRecordingOmit
    agentPhoneNumber?: AgentPhoneNumberOmit
    phoneCall?: PhoneCallOmit
    agentMetric?: AgentMetricOmit
    scanResult?: ScanResultOmit
    signal?: SignalOmit
    agentRun?: AgentRunOmit
    aiEvent?: AiEventOmit
    agentTrace?: AgentTraceOmit
    conversationEvaluation?: ConversationEvaluationOmit
    agentInsight?: AgentInsightOmit
    agentFeedback?: AgentFeedbackOmit
    agentABTest?: AgentABTestOmit
    optimizationRun?: OptimizationRunOmit
    modificationProposal?: ModificationProposalOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    workflows: number
    credentials: number
    agents: number
    integrations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    workflows?: boolean | UserCountOutputTypeCountWorkflowsArgs
    credentials?: boolean | UserCountOutputTypeCountCredentialsArgs
    agents?: boolean | UserCountOutputTypeCountAgentsArgs
    integrations?: boolean | UserCountOutputTypeCountIntegrationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }


  /**
   * Count Type CredentialCountOutputType
   */

  export type CredentialCountOutputType = {
    Node: number
    agents: number
  }

  export type CredentialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Node?: boolean | CredentialCountOutputTypeCountNodeArgs
    agents?: boolean | CredentialCountOutputTypeCountAgentsArgs
  }

  // Custom InputTypes
  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialCountOutputType
     */
    select?: CredentialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    nodes: number
    connections: number
    executions: number
    agentTools: number
  }

  export type WorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | WorkflowCountOutputTypeCountNodesArgs
    connections?: boolean | WorkflowCountOutputTypeCountConnectionsArgs
    executions?: boolean | WorkflowCountOutputTypeCountExecutionsArgs
    agentTools?: boolean | WorkflowCountOutputTypeCountAgentToolsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountAgentToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentToolWhereInput
  }


  /**
   * Count Type NodeCountOutputType
   */

  export type NodeCountOutputType = {
    outputConnections: number
    inputConnections: number
  }

  export type NodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outputConnections?: boolean | NodeCountOutputTypeCountOutputConnectionsArgs
    inputConnections?: boolean | NodeCountOutputTypeCountInputConnectionsArgs
  }

  // Custom InputTypes
  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeCountOutputType
     */
    select?: NodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountOutputConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountInputConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    conversations: number
    agentTools: number
    memories: number
    knowledgeDocuments: number
    triggers: number
    connectedTo: number
    connectedFrom: number
    swarms: number
    meetingRecordings: number
    metrics: number
    traces: number
    insights: number
    feedbacks: number
    abTests: number
    optimizationRuns: number
    modificationProposals: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | AgentCountOutputTypeCountConversationsArgs
    agentTools?: boolean | AgentCountOutputTypeCountAgentToolsArgs
    memories?: boolean | AgentCountOutputTypeCountMemoriesArgs
    knowledgeDocuments?: boolean | AgentCountOutputTypeCountKnowledgeDocumentsArgs
    triggers?: boolean | AgentCountOutputTypeCountTriggersArgs
    connectedTo?: boolean | AgentCountOutputTypeCountConnectedToArgs
    connectedFrom?: boolean | AgentCountOutputTypeCountConnectedFromArgs
    swarms?: boolean | AgentCountOutputTypeCountSwarmsArgs
    meetingRecordings?: boolean | AgentCountOutputTypeCountMeetingRecordingsArgs
    metrics?: boolean | AgentCountOutputTypeCountMetricsArgs
    traces?: boolean | AgentCountOutputTypeCountTracesArgs
    insights?: boolean | AgentCountOutputTypeCountInsightsArgs
    feedbacks?: boolean | AgentCountOutputTypeCountFeedbacksArgs
    abTests?: boolean | AgentCountOutputTypeCountAbTestsArgs
    optimizationRuns?: boolean | AgentCountOutputTypeCountOptimizationRunsArgs
    modificationProposals?: boolean | AgentCountOutputTypeCountModificationProposalsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAgentToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentToolWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMemoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentMemoryWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountKnowledgeDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeDocumentWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTriggerWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountConnectedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentConnectionWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountConnectedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentConnectionWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountSwarmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentSwarmWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMeetingRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingRecordingWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentMetricWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTraceWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentInsightWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentFeedbackWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAbTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentABTestWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountOptimizationRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptimizationRunWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountModificationProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModificationProposalWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    activities: number
    traces: number
    feedbacks: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    activities?: boolean | ConversationCountOutputTypeCountActivitiesArgs
    traces?: boolean | ConversationCountOutputTypeCountTracesArgs
    feedbacks?: boolean | ConversationCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationActivityWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTraceWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentFeedbackWhereInput
  }


  /**
   * Count Type KnowledgeDocumentCountOutputType
   */

  export type KnowledgeDocumentCountOutputType = {
    chunks: number
  }

  export type KnowledgeDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunks?: boolean | KnowledgeDocumentCountOutputTypeCountChunksArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeDocumentCountOutputType without action
   */
  export type KnowledgeDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocumentCountOutputType
     */
    select?: KnowledgeDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeDocumentCountOutputType without action
   */
  export type KnowledgeDocumentCountOutputTypeCountChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeChunkWhereInput
  }


  /**
   * Count Type AgentTemplateCountOutputType
   */

  export type AgentTemplateCountOutputType = {
    agents: number
  }

  export type AgentTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentTemplateCountOutputTypeCountAgentsArgs
  }

  // Custom InputTypes
  /**
   * AgentTemplateCountOutputType without action
   */
  export type AgentTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplateCountOutputType
     */
    select?: AgentTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentTemplateCountOutputType without action
   */
  export type AgentTemplateCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type AgentSwarmCountOutputType
   */

  export type AgentSwarmCountOutputType = {
    tasks: number
  }

  export type AgentSwarmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | AgentSwarmCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * AgentSwarmCountOutputType without action
   */
  export type AgentSwarmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarmCountOutputType
     */
    select?: AgentSwarmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentSwarmCountOutputType without action
   */
  export type AgentSwarmCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwarmTaskWhereInput
  }


  /**
   * Count Type AgentPhoneNumberCountOutputType
   */

  export type AgentPhoneNumberCountOutputType = {
    calls: number
  }

  export type AgentPhoneNumberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calls?: boolean | AgentPhoneNumberCountOutputTypeCountCallsArgs
  }

  // Custom InputTypes
  /**
   * AgentPhoneNumberCountOutputType without action
   */
  export type AgentPhoneNumberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumberCountOutputType
     */
    select?: AgentPhoneNumberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentPhoneNumberCountOutputType without action
   */
  export type AgentPhoneNumberCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneCallWhereInput
  }


  /**
   * Count Type AgentTraceCountOutputType
   */

  export type AgentTraceCountOutputType = {
    aiEvents: number
    feedbacks: number
  }

  export type AgentTraceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiEvents?: boolean | AgentTraceCountOutputTypeCountAiEventsArgs
    feedbacks?: boolean | AgentTraceCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * AgentTraceCountOutputType without action
   */
  export type AgentTraceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTraceCountOutputType
     */
    select?: AgentTraceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentTraceCountOutputType without action
   */
  export type AgentTraceCountOutputTypeCountAiEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiEventWhereInput
  }

  /**
   * AgentTraceCountOutputType without action
   */
  export type AgentTraceCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentFeedbackWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    workflows?: boolean | User$workflowsArgs<ExtArgs>
    credentials?: boolean | User$credentialsArgs<ExtArgs>
    agents?: boolean | User$agentsArgs<ExtArgs>
    integrations?: boolean | User$integrationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    workflows?: boolean | User$workflowsArgs<ExtArgs>
    credentials?: boolean | User$credentialsArgs<ExtArgs>
    agents?: boolean | User$agentsArgs<ExtArgs>
    integrations?: boolean | User$integrationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      credentials: Prisma.$CredentialPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workflows<T extends User$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credentials<T extends User$credentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$credentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agents<T extends User$agentsArgs<ExtArgs> = {}>(args?: Subset<T, User$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends User$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.workflows
   */
  export type User$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * User.credentials
   */
  export type User$credentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    cursor?: CredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * User.agents
   */
  export type User$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * User.integrations
   */
  export type User$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Credential
   */

  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    type: $Enums.CredentialType | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    type: $Enums.CredentialType | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    name: number
    value: number
    type: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type CredentialMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type CredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credential to aggregate.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithAggregationInput | CredentialOrderByWithAggregationInput[]
    by: CredentialScalarFieldEnum[] | CredentialScalarFieldEnum
    having?: CredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }

  export type CredentialGroupByOutputType = {
    id: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Node?: boolean | Credential$NodeArgs<ExtArgs>
    agents?: boolean | Credential$agentsArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type CredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "type" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["credential"]>
  export type CredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Node?: boolean | Credential$NodeArgs<ExtArgs>
    agents?: boolean | Credential$agentsArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credential"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Node: Prisma.$NodePayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: string
      type: $Enums.CredentialType
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["credential"]>
    composites: {}
  }

  type CredentialGetPayload<S extends boolean | null | undefined | CredentialDefaultArgs> = $Result.GetResult<Prisma.$CredentialPayload, S>

  type CredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface CredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credential'], meta: { name: 'Credential' } }
    /**
     * Find zero or one Credential that matches the filter.
     * @param {CredentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialFindUniqueArgs>(args: SelectSubset<T, CredentialFindUniqueArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CredentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialFindFirstArgs>(args?: SelectSubset<T, CredentialFindFirstArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialFindManyArgs>(args?: SelectSubset<T, CredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credential.
     * @param {CredentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
     */
    create<T extends CredentialCreateArgs>(args: SelectSubset<T, CredentialCreateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credentials.
     * @param {CredentialCreateManyArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialCreateManyArgs>(args?: SelectSubset<T, CredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credentials and returns the data saved in the database.
     * @param {CredentialCreateManyAndReturnArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credential.
     * @param {CredentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
     */
    delete<T extends CredentialDeleteArgs>(args: SelectSubset<T, CredentialDeleteArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credential.
     * @param {CredentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialUpdateArgs>(args: SelectSubset<T, CredentialUpdateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credentials.
     * @param {CredentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialDeleteManyArgs>(args?: SelectSubset<T, CredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialUpdateManyArgs>(args: SelectSubset<T, CredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials and returns the data updated in the database.
     * @param {CredentialUpdateManyAndReturnArgs} args - Arguments to update many Credentials.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, CredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credential.
     * @param {CredentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
     */
    upsert<T extends CredentialUpsertArgs>(args: SelectSubset<T, CredentialUpsertArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends CredentialCountArgs>(
      args?: Subset<T, CredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credential model
   */
  readonly fields: CredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Node<T extends Credential$NodeArgs<ExtArgs> = {}>(args?: Subset<T, Credential$NodeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agents<T extends Credential$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Credential$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credential model
   */
  interface CredentialFieldRefs {
    readonly id: FieldRef<"Credential", 'String'>
    readonly name: FieldRef<"Credential", 'String'>
    readonly value: FieldRef<"Credential", 'String'>
    readonly type: FieldRef<"Credential", 'CredentialType'>
    readonly createdAt: FieldRef<"Credential", 'DateTime'>
    readonly updatedAt: FieldRef<"Credential", 'DateTime'>
    readonly userId: FieldRef<"Credential", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Credential findUnique
   */
  export type CredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findUniqueOrThrow
   */
  export type CredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findFirst
   */
  export type CredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findFirstOrThrow
   */
  export type CredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findMany
   */
  export type CredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credentials to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential create
   */
  export type CredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a Credential.
     */
    data: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
  }

  /**
   * Credential createMany
   */
  export type CredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential createManyAndReturn
   */
  export type CredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credential update
   */
  export type CredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a Credential.
     */
    data: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
    /**
     * Choose, which Credential to update.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential updateMany
   */
  export type CredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential updateManyAndReturn
   */
  export type CredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credential upsert
   */
  export type CredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the Credential to update in case it exists.
     */
    where: CredentialWhereUniqueInput
    /**
     * In case the Credential found by the `where` argument doesn't exist, create a new Credential with this data.
     */
    create: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
    /**
     * In case the Credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
  }

  /**
   * Credential delete
   */
  export type CredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter which Credential to delete.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential deleteMany
   */
  export type CredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credentials to delete
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to delete.
     */
    limit?: number
  }

  /**
   * Credential.Node
   */
  export type Credential$NodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    cursor?: NodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Credential.agents
   */
  export type Credential$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Credential without action
   */
  export type CredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
  }


  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type WorkflowMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nodes?: boolean | Workflow$nodesArgs<ExtArgs>
    connections?: boolean | Workflow$connectionsArgs<ExtArgs>
    executions?: boolean | Workflow$executionsArgs<ExtArgs>
    agentTools?: boolean | Workflow$agentToolsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["workflow"]>
  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | Workflow$nodesArgs<ExtArgs>
    connections?: boolean | Workflow$connectionsArgs<ExtArgs>
    executions?: boolean | Workflow$executionsArgs<ExtArgs>
    agentTools?: boolean | Workflow$agentToolsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      nodes: Prisma.$NodePayload<ExtArgs>[]
      connections: Prisma.$ConnectionPayload<ExtArgs>[]
      executions: Prisma.$ExecutionPayload<ExtArgs>[]
      agentTools: Prisma.$AgentToolPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows and returns the data updated in the database.
     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodes<T extends Workflow$nodesArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    connections<T extends Workflow$connectionsArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$connectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executions<T extends Workflow$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agentTools<T extends Workflow$agentToolsArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$agentToolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly name: FieldRef<"Workflow", 'String'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
    readonly userId: FieldRef<"Workflow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
  }

  /**
   * Workflow updateManyAndReturn
   */
  export type WorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to delete.
     */
    limit?: number
  }

  /**
   * Workflow.nodes
   */
  export type Workflow$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    cursor?: NodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Workflow.connections
   */
  export type Workflow$connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Workflow.executions
   */
  export type Workflow$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    where?: ExecutionWhereInput
    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]
    cursor?: ExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]
  }

  /**
   * Workflow.agentTools
   */
  export type Workflow$agentToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    where?: AgentToolWhereInput
    orderBy?: AgentToolOrderByWithRelationInput | AgentToolOrderByWithRelationInput[]
    cursor?: AgentToolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentToolScalarFieldEnum | AgentToolScalarFieldEnum[]
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
  }


  /**
   * Model Node
   */

  export type AggregateNode = {
    _count: NodeCountAggregateOutputType | null
    _min: NodeMinAggregateOutputType | null
    _max: NodeMaxAggregateOutputType | null
  }

  export type NodeMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    name: string | null
    type: $Enums.NodeType | null
    credentialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NodeMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    name: string | null
    type: $Enums.NodeType | null
    credentialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NodeCountAggregateOutputType = {
    id: number
    workflowId: number
    name: number
    type: number
    position: number
    data: number
    credentialId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NodeMinAggregateInputType = {
    id?: true
    workflowId?: true
    name?: true
    type?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NodeMaxAggregateInputType = {
    id?: true
    workflowId?: true
    name?: true
    type?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NodeCountAggregateInputType = {
    id?: true
    workflowId?: true
    name?: true
    type?: true
    position?: true
    data?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Node to aggregate.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nodes
    **/
    _count?: true | NodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeMaxAggregateInputType
  }

  export type GetNodeAggregateType<T extends NodeAggregateArgs> = {
        [P in keyof T & keyof AggregateNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNode[P]>
      : GetScalarType<T[P], AggregateNode[P]>
  }




  export type NodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithAggregationInput | NodeOrderByWithAggregationInput[]
    by: NodeScalarFieldEnum[] | NodeScalarFieldEnum
    having?: NodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeCountAggregateInputType | true
    _min?: NodeMinAggregateInputType
    _max?: NodeMaxAggregateInputType
  }

  export type NodeGroupByOutputType = {
    id: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonValue
    data: JsonValue
    credentialId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NodeCountAggregateOutputType | null
    _min: NodeMinAggregateOutputType | null
    _max: NodeMaxAggregateOutputType | null
  }

  type GetNodeGroupByPayload<T extends NodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeGroupByOutputType[P]>
            : GetScalarType<T[P], NodeGroupByOutputType[P]>
        }
      >
    >


  export type NodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    data?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    credential?: boolean | Node$credentialArgs<ExtArgs>
    outputConnections?: boolean | Node$outputConnectionsArgs<ExtArgs>
    inputConnections?: boolean | Node$inputConnectionsArgs<ExtArgs>
    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>

  export type NodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    data?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    credential?: boolean | Node$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>

  export type NodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    data?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    credential?: boolean | Node$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>

  export type NodeSelectScalar = {
    id?: boolean
    workflowId?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    data?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowId" | "name" | "type" | "position" | "data" | "credentialId" | "createdAt" | "updatedAt", ExtArgs["result"]["node"]>
  export type NodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    credential?: boolean | Node$credentialArgs<ExtArgs>
    outputConnections?: boolean | Node$outputConnectionsArgs<ExtArgs>
    inputConnections?: boolean | Node$inputConnectionsArgs<ExtArgs>
    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    credential?: boolean | Node$credentialArgs<ExtArgs>
  }
  export type NodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    credential?: boolean | Node$credentialArgs<ExtArgs>
  }

  export type $NodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Node"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      credential: Prisma.$CredentialPayload<ExtArgs> | null
      outputConnections: Prisma.$ConnectionPayload<ExtArgs>[]
      inputConnections: Prisma.$ConnectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      name: string
      type: $Enums.NodeType
      position: Prisma.JsonValue
      data: Prisma.JsonValue
      credentialId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["node"]>
    composites: {}
  }

  type NodeGetPayload<S extends boolean | null | undefined | NodeDefaultArgs> = $Result.GetResult<Prisma.$NodePayload, S>

  type NodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NodeCountAggregateInputType | true
    }

  export interface NodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Node'], meta: { name: 'Node' } }
    /**
     * Find zero or one Node that matches the filter.
     * @param {NodeFindUniqueArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeFindUniqueArgs>(args: SelectSubset<T, NodeFindUniqueArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Node that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NodeFindUniqueOrThrowArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Node that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindFirstArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeFindFirstArgs>(args?: SelectSubset<T, NodeFindFirstArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Node that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindFirstOrThrowArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nodes
     * const nodes = await prisma.node.findMany()
     * 
     * // Get first 10 Nodes
     * const nodes = await prisma.node.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeWithIdOnly = await prisma.node.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeFindManyArgs>(args?: SelectSubset<T, NodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Node.
     * @param {NodeCreateArgs} args - Arguments to create a Node.
     * @example
     * // Create one Node
     * const Node = await prisma.node.create({
     *   data: {
     *     // ... data to create a Node
     *   }
     * })
     * 
     */
    create<T extends NodeCreateArgs>(args: SelectSubset<T, NodeCreateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nodes.
     * @param {NodeCreateManyArgs} args - Arguments to create many Nodes.
     * @example
     * // Create many Nodes
     * const node = await prisma.node.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeCreateManyArgs>(args?: SelectSubset<T, NodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nodes and returns the data saved in the database.
     * @param {NodeCreateManyAndReturnArgs} args - Arguments to create many Nodes.
     * @example
     * // Create many Nodes
     * const node = await prisma.node.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nodes and only return the `id`
     * const nodeWithIdOnly = await prisma.node.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Node.
     * @param {NodeDeleteArgs} args - Arguments to delete one Node.
     * @example
     * // Delete one Node
     * const Node = await prisma.node.delete({
     *   where: {
     *     // ... filter to delete one Node
     *   }
     * })
     * 
     */
    delete<T extends NodeDeleteArgs>(args: SelectSubset<T, NodeDeleteArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Node.
     * @param {NodeUpdateArgs} args - Arguments to update one Node.
     * @example
     * // Update one Node
     * const node = await prisma.node.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeUpdateArgs>(args: SelectSubset<T, NodeUpdateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nodes.
     * @param {NodeDeleteManyArgs} args - Arguments to filter Nodes to delete.
     * @example
     * // Delete a few Nodes
     * const { count } = await prisma.node.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeDeleteManyArgs>(args?: SelectSubset<T, NodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nodes
     * const node = await prisma.node.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeUpdateManyArgs>(args: SelectSubset<T, NodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nodes and returns the data updated in the database.
     * @param {NodeUpdateManyAndReturnArgs} args - Arguments to update many Nodes.
     * @example
     * // Update many Nodes
     * const node = await prisma.node.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nodes and only return the `id`
     * const nodeWithIdOnly = await prisma.node.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NodeUpdateManyAndReturnArgs>(args: SelectSubset<T, NodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Node.
     * @param {NodeUpsertArgs} args - Arguments to update or create a Node.
     * @example
     * // Update or create a Node
     * const node = await prisma.node.upsert({
     *   create: {
     *     // ... data to create a Node
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Node we want to update
     *   }
     * })
     */
    upsert<T extends NodeUpsertArgs>(args: SelectSubset<T, NodeUpsertArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeCountArgs} args - Arguments to filter Nodes to count.
     * @example
     * // Count the number of Nodes
     * const count = await prisma.node.count({
     *   where: {
     *     // ... the filter for the Nodes we want to count
     *   }
     * })
    **/
    count<T extends NodeCountArgs>(
      args?: Subset<T, NodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Node.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeAggregateArgs>(args: Subset<T, NodeAggregateArgs>): Prisma.PrismaPromise<GetNodeAggregateType<T>>

    /**
     * Group by Node.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeGroupByArgs['orderBy'] }
        : { orderBy?: NodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Node model
   */
  readonly fields: NodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Node.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credential<T extends Node$credentialArgs<ExtArgs> = {}>(args?: Subset<T, Node$credentialArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outputConnections<T extends Node$outputConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Node$outputConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inputConnections<T extends Node$inputConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Node$inputConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Node model
   */
  interface NodeFieldRefs {
    readonly id: FieldRef<"Node", 'String'>
    readonly workflowId: FieldRef<"Node", 'String'>
    readonly name: FieldRef<"Node", 'String'>
    readonly type: FieldRef<"Node", 'NodeType'>
    readonly position: FieldRef<"Node", 'Json'>
    readonly data: FieldRef<"Node", 'Json'>
    readonly credentialId: FieldRef<"Node", 'String'>
    readonly createdAt: FieldRef<"Node", 'DateTime'>
    readonly updatedAt: FieldRef<"Node", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Node findUnique
   */
  export type NodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node findUniqueOrThrow
   */
  export type NodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node findFirst
   */
  export type NodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nodes.
     */
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node findFirstOrThrow
   */
  export type NodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nodes.
     */
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node findMany
   */
  export type NodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Nodes to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node create
   */
  export type NodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Node.
     */
    data: XOR<NodeCreateInput, NodeUncheckedCreateInput>
  }

  /**
   * Node createMany
   */
  export type NodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nodes.
     */
    data: NodeCreateManyInput | NodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Node createManyAndReturn
   */
  export type NodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * The data used to create many Nodes.
     */
    data: NodeCreateManyInput | NodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Node update
   */
  export type NodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Node.
     */
    data: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>
    /**
     * Choose, which Node to update.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node updateMany
   */
  export type NodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nodes.
     */
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>
    /**
     * Filter which Nodes to update
     */
    where?: NodeWhereInput
    /**
     * Limit how many Nodes to update.
     */
    limit?: number
  }

  /**
   * Node updateManyAndReturn
   */
  export type NodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * The data used to update Nodes.
     */
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>
    /**
     * Filter which Nodes to update
     */
    where?: NodeWhereInput
    /**
     * Limit how many Nodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Node upsert
   */
  export type NodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Node to update in case it exists.
     */
    where: NodeWhereUniqueInput
    /**
     * In case the Node found by the `where` argument doesn't exist, create a new Node with this data.
     */
    create: XOR<NodeCreateInput, NodeUncheckedCreateInput>
    /**
     * In case the Node was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>
  }

  /**
   * Node delete
   */
  export type NodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter which Node to delete.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node deleteMany
   */
  export type NodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nodes to delete
     */
    where?: NodeWhereInput
    /**
     * Limit how many Nodes to delete.
     */
    limit?: number
  }

  /**
   * Node.credential
   */
  export type Node$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
  }

  /**
   * Node.outputConnections
   */
  export type Node$outputConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Node.inputConnections
   */
  export type Node$inputConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Node without action
   */
  export type NodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
  }


  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  export type ConnectionMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    fromNodeId: string | null
    toNodeId: string | null
    fromOutput: string | null
    toInput: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConnectionMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    fromNodeId: string | null
    toNodeId: string | null
    fromOutput: string | null
    toInput: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConnectionCountAggregateOutputType = {
    id: number
    workflowId: number
    fromNodeId: number
    toNodeId: number
    fromOutput: number
    toInput: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConnectionMinAggregateInputType = {
    id?: true
    workflowId?: true
    fromNodeId?: true
    toNodeId?: true
    fromOutput?: true
    toInput?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConnectionMaxAggregateInputType = {
    id?: true
    workflowId?: true
    fromNodeId?: true
    toNodeId?: true
    fromOutput?: true
    toInput?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConnectionCountAggregateInputType = {
    id?: true
    workflowId?: true
    fromNodeId?: true
    toNodeId?: true
    fromOutput?: true
    toInput?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Connections
    **/
    _count?: true | ConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionMaxAggregateInputType
  }

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>
  }




  export type ConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[]
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum
    having?: ConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionCountAggregateInputType | true
    _min?: ConnectionMinAggregateInputType
    _max?: ConnectionMaxAggregateInputType
  }

  export type ConnectionGroupByOutputType = {
    id: string
    workflowId: string
    fromNodeId: string
    toNodeId: string
    fromOutput: string
    toInput: string
    createdAt: Date
    updatedAt: Date
    _count: ConnectionCountAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    fromOutput?: boolean
    toInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    fromNode?: boolean | NodeDefaultArgs<ExtArgs>
    toNode?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    fromOutput?: boolean
    toInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    fromNode?: boolean | NodeDefaultArgs<ExtArgs>
    toNode?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    fromOutput?: boolean
    toInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    fromNode?: boolean | NodeDefaultArgs<ExtArgs>
    toNode?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectScalar = {
    id?: boolean
    workflowId?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    fromOutput?: boolean
    toInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowId" | "fromNodeId" | "toNodeId" | "fromOutput" | "toInput" | "createdAt" | "updatedAt", ExtArgs["result"]["connection"]>
  export type ConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    fromNode?: boolean | NodeDefaultArgs<ExtArgs>
    toNode?: boolean | NodeDefaultArgs<ExtArgs>
  }
  export type ConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    fromNode?: boolean | NodeDefaultArgs<ExtArgs>
    toNode?: boolean | NodeDefaultArgs<ExtArgs>
  }
  export type ConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    fromNode?: boolean | NodeDefaultArgs<ExtArgs>
    toNode?: boolean | NodeDefaultArgs<ExtArgs>
  }

  export type $ConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Connection"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      fromNode: Prisma.$NodePayload<ExtArgs>
      toNode: Prisma.$NodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      fromNodeId: string
      toNodeId: string
      fromOutput: string
      toInput: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["connection"]>
    composites: {}
  }

  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> = $Result.GetResult<Prisma.$ConnectionPayload, S>

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectionCountAggregateInputType | true
    }

  export interface ConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Connection'], meta: { name: 'Connection' } }
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionFindUniqueArgs>(args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Connection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionFindFirstArgs>(args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     * 
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionWithIdOnly = await prisma.connection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionFindManyArgs>(args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     * 
     */
    create<T extends ConnectionCreateArgs>(args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Connections.
     * @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionCreateManyArgs>(args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Connections and returns the data saved in the database.
     * @param {ConnectionCreateManyAndReturnArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     * 
     */
    delete<T extends ConnectionDeleteArgs>(args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionUpdateArgs>(args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionDeleteManyArgs>(args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionUpdateManyArgs>(args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections and returns the data updated in the database.
     * @param {ConnectionUpdateManyAndReturnArgs} args - Arguments to update many Connections.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionUpsertArgs>(args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
    **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionAggregateArgs>(args: Subset<T, ConnectionAggregateArgs>): Prisma.PrismaPromise<GetConnectionAggregateType<T>>

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Connection model
   */
  readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Connection model
   */
  interface ConnectionFieldRefs {
    readonly id: FieldRef<"Connection", 'String'>
    readonly workflowId: FieldRef<"Connection", 'String'>
    readonly fromNodeId: FieldRef<"Connection", 'String'>
    readonly toNodeId: FieldRef<"Connection", 'String'>
    readonly fromOutput: FieldRef<"Connection", 'String'>
    readonly toInput: FieldRef<"Connection", 'String'>
    readonly createdAt: FieldRef<"Connection", 'DateTime'>
    readonly updatedAt: FieldRef<"Connection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection create
   */
  export type ConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
  }

  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Connection createManyAndReturn
   */
  export type ConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to update.
     */
    limit?: number
  }

  /**
   * Connection updateManyAndReturn
   */
  export type ConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
  }

  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to delete.
     */
    limit?: number
  }

  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
  }


  /**
   * Model Execution
   */

  export type AggregateExecution = {
    _count: ExecutionCountAggregateOutputType | null
    _min: ExecutionMinAggregateOutputType | null
    _max: ExecutionMaxAggregateOutputType | null
  }

  export type ExecutionMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    status: $Enums.ExecutionStatus | null
    error: string | null
    errorStack: string | null
    startedAt: Date | null
    completedAt: Date | null
    inngestEventId: string | null
  }

  export type ExecutionMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    status: $Enums.ExecutionStatus | null
    error: string | null
    errorStack: string | null
    startedAt: Date | null
    completedAt: Date | null
    inngestEventId: string | null
  }

  export type ExecutionCountAggregateOutputType = {
    id: number
    workflowId: number
    status: number
    error: number
    errorStack: number
    startedAt: number
    completedAt: number
    inngestEventId: number
    output: number
    _all: number
  }


  export type ExecutionMinAggregateInputType = {
    id?: true
    workflowId?: true
    status?: true
    error?: true
    errorStack?: true
    startedAt?: true
    completedAt?: true
    inngestEventId?: true
  }

  export type ExecutionMaxAggregateInputType = {
    id?: true
    workflowId?: true
    status?: true
    error?: true
    errorStack?: true
    startedAt?: true
    completedAt?: true
    inngestEventId?: true
  }

  export type ExecutionCountAggregateInputType = {
    id?: true
    workflowId?: true
    status?: true
    error?: true
    errorStack?: true
    startedAt?: true
    completedAt?: true
    inngestEventId?: true
    output?: true
    _all?: true
  }

  export type ExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Execution to aggregate.
     */
    where?: ExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executions to fetch.
     */
    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Executions
    **/
    _count?: true | ExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutionMaxAggregateInputType
  }

  export type GetExecutionAggregateType<T extends ExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecution[P]>
      : GetScalarType<T[P], AggregateExecution[P]>
  }




  export type ExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionWhereInput
    orderBy?: ExecutionOrderByWithAggregationInput | ExecutionOrderByWithAggregationInput[]
    by: ExecutionScalarFieldEnum[] | ExecutionScalarFieldEnum
    having?: ExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutionCountAggregateInputType | true
    _min?: ExecutionMinAggregateInputType
    _max?: ExecutionMaxAggregateInputType
  }

  export type ExecutionGroupByOutputType = {
    id: string
    workflowId: string
    status: $Enums.ExecutionStatus
    error: string | null
    errorStack: string | null
    startedAt: Date
    completedAt: Date | null
    inngestEventId: string
    output: JsonValue | null
    _count: ExecutionCountAggregateOutputType | null
    _min: ExecutionMinAggregateOutputType | null
    _max: ExecutionMaxAggregateOutputType | null
  }

  type GetExecutionGroupByPayload<T extends ExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutionGroupByOutputType[P]>
        }
      >
    >


  export type ExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    status?: boolean
    error?: boolean
    errorStack?: boolean
    startedAt?: boolean
    completedAt?: boolean
    inngestEventId?: boolean
    output?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["execution"]>

  export type ExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    status?: boolean
    error?: boolean
    errorStack?: boolean
    startedAt?: boolean
    completedAt?: boolean
    inngestEventId?: boolean
    output?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["execution"]>

  export type ExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    status?: boolean
    error?: boolean
    errorStack?: boolean
    startedAt?: boolean
    completedAt?: boolean
    inngestEventId?: boolean
    output?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["execution"]>

  export type ExecutionSelectScalar = {
    id?: boolean
    workflowId?: boolean
    status?: boolean
    error?: boolean
    errorStack?: boolean
    startedAt?: boolean
    completedAt?: boolean
    inngestEventId?: boolean
    output?: boolean
  }

  export type ExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowId" | "status" | "error" | "errorStack" | "startedAt" | "completedAt" | "inngestEventId" | "output", ExtArgs["result"]["execution"]>
  export type ExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type ExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type ExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }

  export type $ExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Execution"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      status: $Enums.ExecutionStatus
      error: string | null
      errorStack: string | null
      startedAt: Date
      completedAt: Date | null
      inngestEventId: string
      output: Prisma.JsonValue | null
    }, ExtArgs["result"]["execution"]>
    composites: {}
  }

  type ExecutionGetPayload<S extends boolean | null | undefined | ExecutionDefaultArgs> = $Result.GetResult<Prisma.$ExecutionPayload, S>

  type ExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExecutionCountAggregateInputType | true
    }

  export interface ExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Execution'], meta: { name: 'Execution' } }
    /**
     * Find zero or one Execution that matches the filter.
     * @param {ExecutionFindUniqueArgs} args - Arguments to find a Execution
     * @example
     * // Get one Execution
     * const execution = await prisma.execution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutionFindUniqueArgs>(args: SelectSubset<T, ExecutionFindUniqueArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Execution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExecutionFindUniqueOrThrowArgs} args - Arguments to find a Execution
     * @example
     * // Get one Execution
     * const execution = await prisma.execution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Execution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionFindFirstArgs} args - Arguments to find a Execution
     * @example
     * // Get one Execution
     * const execution = await prisma.execution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutionFindFirstArgs>(args?: SelectSubset<T, ExecutionFindFirstArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Execution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionFindFirstOrThrowArgs} args - Arguments to find a Execution
     * @example
     * // Get one Execution
     * const execution = await prisma.execution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Executions
     * const executions = await prisma.execution.findMany()
     * 
     * // Get first 10 Executions
     * const executions = await prisma.execution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executionWithIdOnly = await prisma.execution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutionFindManyArgs>(args?: SelectSubset<T, ExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Execution.
     * @param {ExecutionCreateArgs} args - Arguments to create a Execution.
     * @example
     * // Create one Execution
     * const Execution = await prisma.execution.create({
     *   data: {
     *     // ... data to create a Execution
     *   }
     * })
     * 
     */
    create<T extends ExecutionCreateArgs>(args: SelectSubset<T, ExecutionCreateArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Executions.
     * @param {ExecutionCreateManyArgs} args - Arguments to create many Executions.
     * @example
     * // Create many Executions
     * const execution = await prisma.execution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutionCreateManyArgs>(args?: SelectSubset<T, ExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Executions and returns the data saved in the database.
     * @param {ExecutionCreateManyAndReturnArgs} args - Arguments to create many Executions.
     * @example
     * // Create many Executions
     * const execution = await prisma.execution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Executions and only return the `id`
     * const executionWithIdOnly = await prisma.execution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Execution.
     * @param {ExecutionDeleteArgs} args - Arguments to delete one Execution.
     * @example
     * // Delete one Execution
     * const Execution = await prisma.execution.delete({
     *   where: {
     *     // ... filter to delete one Execution
     *   }
     * })
     * 
     */
    delete<T extends ExecutionDeleteArgs>(args: SelectSubset<T, ExecutionDeleteArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Execution.
     * @param {ExecutionUpdateArgs} args - Arguments to update one Execution.
     * @example
     * // Update one Execution
     * const execution = await prisma.execution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutionUpdateArgs>(args: SelectSubset<T, ExecutionUpdateArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Executions.
     * @param {ExecutionDeleteManyArgs} args - Arguments to filter Executions to delete.
     * @example
     * // Delete a few Executions
     * const { count } = await prisma.execution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutionDeleteManyArgs>(args?: SelectSubset<T, ExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Executions
     * const execution = await prisma.execution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutionUpdateManyArgs>(args: SelectSubset<T, ExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Executions and returns the data updated in the database.
     * @param {ExecutionUpdateManyAndReturnArgs} args - Arguments to update many Executions.
     * @example
     * // Update many Executions
     * const execution = await prisma.execution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Executions and only return the `id`
     * const executionWithIdOnly = await prisma.execution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Execution.
     * @param {ExecutionUpsertArgs} args - Arguments to update or create a Execution.
     * @example
     * // Update or create a Execution
     * const execution = await prisma.execution.upsert({
     *   create: {
     *     // ... data to create a Execution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Execution we want to update
     *   }
     * })
     */
    upsert<T extends ExecutionUpsertArgs>(args: SelectSubset<T, ExecutionUpsertArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionCountArgs} args - Arguments to filter Executions to count.
     * @example
     * // Count the number of Executions
     * const count = await prisma.execution.count({
     *   where: {
     *     // ... the filter for the Executions we want to count
     *   }
     * })
    **/
    count<T extends ExecutionCountArgs>(
      args?: Subset<T, ExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Execution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutionAggregateArgs>(args: Subset<T, ExecutionAggregateArgs>): Prisma.PrismaPromise<GetExecutionAggregateType<T>>

    /**
     * Group by Execution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutionGroupByArgs['orderBy'] }
        : { orderBy?: ExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Execution model
   */
  readonly fields: ExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Execution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Execution model
   */
  interface ExecutionFieldRefs {
    readonly id: FieldRef<"Execution", 'String'>
    readonly workflowId: FieldRef<"Execution", 'String'>
    readonly status: FieldRef<"Execution", 'ExecutionStatus'>
    readonly error: FieldRef<"Execution", 'String'>
    readonly errorStack: FieldRef<"Execution", 'String'>
    readonly startedAt: FieldRef<"Execution", 'DateTime'>
    readonly completedAt: FieldRef<"Execution", 'DateTime'>
    readonly inngestEventId: FieldRef<"Execution", 'String'>
    readonly output: FieldRef<"Execution", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Execution findUnique
   */
  export type ExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * Filter, which Execution to fetch.
     */
    where: ExecutionWhereUniqueInput
  }

  /**
   * Execution findUniqueOrThrow
   */
  export type ExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * Filter, which Execution to fetch.
     */
    where: ExecutionWhereUniqueInput
  }

  /**
   * Execution findFirst
   */
  export type ExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * Filter, which Execution to fetch.
     */
    where?: ExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executions to fetch.
     */
    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Executions.
     */
    cursor?: ExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Executions.
     */
    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]
  }

  /**
   * Execution findFirstOrThrow
   */
  export type ExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * Filter, which Execution to fetch.
     */
    where?: ExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executions to fetch.
     */
    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Executions.
     */
    cursor?: ExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Executions.
     */
    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]
  }

  /**
   * Execution findMany
   */
  export type ExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * Filter, which Executions to fetch.
     */
    where?: ExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executions to fetch.
     */
    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Executions.
     */
    cursor?: ExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executions.
     */
    skip?: number
    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]
  }

  /**
   * Execution create
   */
  export type ExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Execution.
     */
    data: XOR<ExecutionCreateInput, ExecutionUncheckedCreateInput>
  }

  /**
   * Execution createMany
   */
  export type ExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Executions.
     */
    data: ExecutionCreateManyInput | ExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Execution createManyAndReturn
   */
  export type ExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many Executions.
     */
    data: ExecutionCreateManyInput | ExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Execution update
   */
  export type ExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Execution.
     */
    data: XOR<ExecutionUpdateInput, ExecutionUncheckedUpdateInput>
    /**
     * Choose, which Execution to update.
     */
    where: ExecutionWhereUniqueInput
  }

  /**
   * Execution updateMany
   */
  export type ExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Executions.
     */
    data: XOR<ExecutionUpdateManyMutationInput, ExecutionUncheckedUpdateManyInput>
    /**
     * Filter which Executions to update
     */
    where?: ExecutionWhereInput
    /**
     * Limit how many Executions to update.
     */
    limit?: number
  }

  /**
   * Execution updateManyAndReturn
   */
  export type ExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * The data used to update Executions.
     */
    data: XOR<ExecutionUpdateManyMutationInput, ExecutionUncheckedUpdateManyInput>
    /**
     * Filter which Executions to update
     */
    where?: ExecutionWhereInput
    /**
     * Limit how many Executions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Execution upsert
   */
  export type ExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Execution to update in case it exists.
     */
    where: ExecutionWhereUniqueInput
    /**
     * In case the Execution found by the `where` argument doesn't exist, create a new Execution with this data.
     */
    create: XOR<ExecutionCreateInput, ExecutionUncheckedCreateInput>
    /**
     * In case the Execution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutionUpdateInput, ExecutionUncheckedUpdateInput>
  }

  /**
   * Execution delete
   */
  export type ExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
    /**
     * Filter which Execution to delete.
     */
    where: ExecutionWhereUniqueInput
  }

  /**
   * Execution deleteMany
   */
  export type ExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Executions to delete
     */
    where?: ExecutionWhereInput
    /**
     * Limit how many Executions to delete.
     */
    limit?: number
  }

  /**
   * Execution without action
   */
  export type ExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Execution
     */
    select?: ExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Execution
     */
    omit?: ExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    temperature: number | null
    maxStepsPerRun: number | null
  }

  export type AgentSumAggregateOutputType = {
    temperature: number | null
    maxStepsPerRun: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    context: string | null
    model: $Enums.AgentModel | null
    temperature: number | null
    safeMode: boolean | null
    llmTier: string | null
    maxStepsPerRun: number | null
    workspaceId: string | null
    avatar: string | null
    isFavorite: boolean | null
    isEnabled: boolean | null
    templateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    credentialId: string | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    context: string | null
    model: $Enums.AgentModel | null
    temperature: number | null
    safeMode: boolean | null
    llmTier: string | null
    maxStepsPerRun: number | null
    workspaceId: string | null
    avatar: string | null
    isFavorite: boolean | null
    isEnabled: boolean | null
    templateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    credentialId: string | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    systemPrompt: number
    context: number
    model: number
    temperature: number
    safeMode: number
    llmTier: number
    maxStepsPerRun: number
    evalRules: number
    workspaceId: number
    avatar: number
    tags: number
    isFavorite: number
    isEnabled: number
    templateId: number
    flowData: number
    createdAt: number
    updatedAt: number
    userId: number
    credentialId: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    temperature?: true
    maxStepsPerRun?: true
  }

  export type AgentSumAggregateInputType = {
    temperature?: true
    maxStepsPerRun?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    systemPrompt?: true
    context?: true
    model?: true
    temperature?: true
    safeMode?: true
    llmTier?: true
    maxStepsPerRun?: true
    workspaceId?: true
    avatar?: true
    isFavorite?: true
    isEnabled?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    credentialId?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    systemPrompt?: true
    context?: true
    model?: true
    temperature?: true
    safeMode?: true
    llmTier?: true
    maxStepsPerRun?: true
    workspaceId?: true
    avatar?: true
    isFavorite?: true
    isEnabled?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    credentialId?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    systemPrompt?: true
    context?: true
    model?: true
    temperature?: true
    safeMode?: true
    llmTier?: true
    maxStepsPerRun?: true
    evalRules?: true
    workspaceId?: true
    avatar?: true
    tags?: true
    isFavorite?: true
    isEnabled?: true
    templateId?: true
    flowData?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    credentialId?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    systemPrompt: string
    context: string | null
    model: $Enums.AgentModel
    temperature: number
    safeMode: boolean
    llmTier: string | null
    maxStepsPerRun: number | null
    evalRules: JsonValue | null
    workspaceId: string | null
    avatar: string | null
    tags: string[]
    isFavorite: boolean
    isEnabled: boolean
    templateId: string | null
    flowData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: string
    credentialId: string | null
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    safeMode?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    evalRules?: boolean
    workspaceId?: boolean
    avatar?: boolean
    tags?: boolean
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: boolean
    flowData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    credentialId?: boolean
    template?: boolean | Agent$templateArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credential?: boolean | Agent$credentialArgs<ExtArgs>
    conversations?: boolean | Agent$conversationsArgs<ExtArgs>
    agentTools?: boolean | Agent$agentToolsArgs<ExtArgs>
    memories?: boolean | Agent$memoriesArgs<ExtArgs>
    knowledgeDocuments?: boolean | Agent$knowledgeDocumentsArgs<ExtArgs>
    knowledgeSettings?: boolean | Agent$knowledgeSettingsArgs<ExtArgs>
    triggers?: boolean | Agent$triggersArgs<ExtArgs>
    embed?: boolean | Agent$embedArgs<ExtArgs>
    connectedTo?: boolean | Agent$connectedToArgs<ExtArgs>
    connectedFrom?: boolean | Agent$connectedFromArgs<ExtArgs>
    swarms?: boolean | Agent$swarmsArgs<ExtArgs>
    emailAddress?: boolean | Agent$emailAddressArgs<ExtArgs>
    meetingRecordings?: boolean | Agent$meetingRecordingsArgs<ExtArgs>
    phoneNumber?: boolean | Agent$phoneNumberArgs<ExtArgs>
    metrics?: boolean | Agent$metricsArgs<ExtArgs>
    traces?: boolean | Agent$tracesArgs<ExtArgs>
    insights?: boolean | Agent$insightsArgs<ExtArgs>
    feedbacks?: boolean | Agent$feedbacksArgs<ExtArgs>
    abTests?: boolean | Agent$abTestsArgs<ExtArgs>
    optimizationRuns?: boolean | Agent$optimizationRunsArgs<ExtArgs>
    modificationProposals?: boolean | Agent$modificationProposalsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    safeMode?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    evalRules?: boolean
    workspaceId?: boolean
    avatar?: boolean
    tags?: boolean
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: boolean
    flowData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    credentialId?: boolean
    template?: boolean | Agent$templateArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credential?: boolean | Agent$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    safeMode?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    evalRules?: boolean
    workspaceId?: boolean
    avatar?: boolean
    tags?: boolean
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: boolean
    flowData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    credentialId?: boolean
    template?: boolean | Agent$templateArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credential?: boolean | Agent$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    safeMode?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    evalRules?: boolean
    workspaceId?: boolean
    avatar?: boolean
    tags?: boolean
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: boolean
    flowData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    credentialId?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "systemPrompt" | "context" | "model" | "temperature" | "safeMode" | "llmTier" | "maxStepsPerRun" | "evalRules" | "workspaceId" | "avatar" | "tags" | "isFavorite" | "isEnabled" | "templateId" | "flowData" | "createdAt" | "updatedAt" | "userId" | "credentialId", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | Agent$templateArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credential?: boolean | Agent$credentialArgs<ExtArgs>
    conversations?: boolean | Agent$conversationsArgs<ExtArgs>
    agentTools?: boolean | Agent$agentToolsArgs<ExtArgs>
    memories?: boolean | Agent$memoriesArgs<ExtArgs>
    knowledgeDocuments?: boolean | Agent$knowledgeDocumentsArgs<ExtArgs>
    knowledgeSettings?: boolean | Agent$knowledgeSettingsArgs<ExtArgs>
    triggers?: boolean | Agent$triggersArgs<ExtArgs>
    embed?: boolean | Agent$embedArgs<ExtArgs>
    connectedTo?: boolean | Agent$connectedToArgs<ExtArgs>
    connectedFrom?: boolean | Agent$connectedFromArgs<ExtArgs>
    swarms?: boolean | Agent$swarmsArgs<ExtArgs>
    emailAddress?: boolean | Agent$emailAddressArgs<ExtArgs>
    meetingRecordings?: boolean | Agent$meetingRecordingsArgs<ExtArgs>
    phoneNumber?: boolean | Agent$phoneNumberArgs<ExtArgs>
    metrics?: boolean | Agent$metricsArgs<ExtArgs>
    traces?: boolean | Agent$tracesArgs<ExtArgs>
    insights?: boolean | Agent$insightsArgs<ExtArgs>
    feedbacks?: boolean | Agent$feedbacksArgs<ExtArgs>
    abTests?: boolean | Agent$abTestsArgs<ExtArgs>
    optimizationRuns?: boolean | Agent$optimizationRunsArgs<ExtArgs>
    modificationProposals?: boolean | Agent$modificationProposalsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | Agent$templateArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credential?: boolean | Agent$credentialArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | Agent$templateArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credential?: boolean | Agent$credentialArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      template: Prisma.$AgentTemplatePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      credential: Prisma.$CredentialPayload<ExtArgs> | null
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      agentTools: Prisma.$AgentToolPayload<ExtArgs>[]
      memories: Prisma.$AgentMemoryPayload<ExtArgs>[]
      knowledgeDocuments: Prisma.$KnowledgeDocumentPayload<ExtArgs>[]
      knowledgeSettings: Prisma.$KnowledgeSettingsPayload<ExtArgs> | null
      triggers: Prisma.$AgentTriggerPayload<ExtArgs>[]
      embed: Prisma.$AgentEmbedPayload<ExtArgs> | null
      connectedTo: Prisma.$AgentConnectionPayload<ExtArgs>[]
      connectedFrom: Prisma.$AgentConnectionPayload<ExtArgs>[]
      swarms: Prisma.$AgentSwarmPayload<ExtArgs>[]
      emailAddress: Prisma.$AgentEmailAddressPayload<ExtArgs> | null
      meetingRecordings: Prisma.$MeetingRecordingPayload<ExtArgs>[]
      phoneNumber: Prisma.$AgentPhoneNumberPayload<ExtArgs> | null
      metrics: Prisma.$AgentMetricPayload<ExtArgs>[]
      traces: Prisma.$AgentTracePayload<ExtArgs>[]
      insights: Prisma.$AgentInsightPayload<ExtArgs>[]
      feedbacks: Prisma.$AgentFeedbackPayload<ExtArgs>[]
      abTests: Prisma.$AgentABTestPayload<ExtArgs>[]
      optimizationRuns: Prisma.$OptimizationRunPayload<ExtArgs>[]
      modificationProposals: Prisma.$ModificationProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      systemPrompt: string
      context: string | null
      model: $Enums.AgentModel
      temperature: number
      safeMode: boolean
      llmTier: string | null
      maxStepsPerRun: number | null
      evalRules: Prisma.JsonValue | null
      workspaceId: string | null
      avatar: string | null
      tags: string[]
      isFavorite: boolean
      isEnabled: boolean
      templateId: string | null
      flowData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: string
      credentialId: string | null
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends Agent$templateArgs<ExtArgs> = {}>(args?: Subset<T, Agent$templateArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credential<T extends Agent$credentialArgs<ExtArgs> = {}>(args?: Subset<T, Agent$credentialArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conversations<T extends Agent$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agentTools<T extends Agent$agentToolsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$agentToolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memories<T extends Agent$memoriesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$memoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    knowledgeDocuments<T extends Agent$knowledgeDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$knowledgeDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    knowledgeSettings<T extends Agent$knowledgeSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$knowledgeSettingsArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    triggers<T extends Agent$triggersArgs<ExtArgs> = {}>(args?: Subset<T, Agent$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    embed<T extends Agent$embedArgs<ExtArgs> = {}>(args?: Subset<T, Agent$embedArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    connectedTo<T extends Agent$connectedToArgs<ExtArgs> = {}>(args?: Subset<T, Agent$connectedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    connectedFrom<T extends Agent$connectedFromArgs<ExtArgs> = {}>(args?: Subset<T, Agent$connectedFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    swarms<T extends Agent$swarmsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$swarmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailAddress<T extends Agent$emailAddressArgs<ExtArgs> = {}>(args?: Subset<T, Agent$emailAddressArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    meetingRecordings<T extends Agent$meetingRecordingsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$meetingRecordingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phoneNumber<T extends Agent$phoneNumberArgs<ExtArgs> = {}>(args?: Subset<T, Agent$phoneNumberArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metrics<T extends Agent$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    traces<T extends Agent$tracesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$tracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insights<T extends Agent$insightsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Agent$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Agent$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abTests<T extends Agent$abTestsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$abTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    optimizationRuns<T extends Agent$optimizationRunsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$optimizationRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modificationProposals<T extends Agent$modificationProposalsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$modificationProposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly description: FieldRef<"Agent", 'String'>
    readonly systemPrompt: FieldRef<"Agent", 'String'>
    readonly context: FieldRef<"Agent", 'String'>
    readonly model: FieldRef<"Agent", 'AgentModel'>
    readonly temperature: FieldRef<"Agent", 'Float'>
    readonly safeMode: FieldRef<"Agent", 'Boolean'>
    readonly llmTier: FieldRef<"Agent", 'String'>
    readonly maxStepsPerRun: FieldRef<"Agent", 'Int'>
    readonly evalRules: FieldRef<"Agent", 'Json'>
    readonly workspaceId: FieldRef<"Agent", 'String'>
    readonly avatar: FieldRef<"Agent", 'String'>
    readonly tags: FieldRef<"Agent", 'String[]'>
    readonly isFavorite: FieldRef<"Agent", 'Boolean'>
    readonly isEnabled: FieldRef<"Agent", 'Boolean'>
    readonly templateId: FieldRef<"Agent", 'String'>
    readonly flowData: FieldRef<"Agent", 'Json'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
    readonly userId: FieldRef<"Agent", 'String'>
    readonly credentialId: FieldRef<"Agent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.template
   */
  export type Agent$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    where?: AgentTemplateWhereInput
  }

  /**
   * Agent.credential
   */
  export type Agent$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
  }

  /**
   * Agent.conversations
   */
  export type Agent$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Agent.agentTools
   */
  export type Agent$agentToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    where?: AgentToolWhereInput
    orderBy?: AgentToolOrderByWithRelationInput | AgentToolOrderByWithRelationInput[]
    cursor?: AgentToolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentToolScalarFieldEnum | AgentToolScalarFieldEnum[]
  }

  /**
   * Agent.memories
   */
  export type Agent$memoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    where?: AgentMemoryWhereInput
    orderBy?: AgentMemoryOrderByWithRelationInput | AgentMemoryOrderByWithRelationInput[]
    cursor?: AgentMemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentMemoryScalarFieldEnum | AgentMemoryScalarFieldEnum[]
  }

  /**
   * Agent.knowledgeDocuments
   */
  export type Agent$knowledgeDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    where?: KnowledgeDocumentWhereInput
    orderBy?: KnowledgeDocumentOrderByWithRelationInput | KnowledgeDocumentOrderByWithRelationInput[]
    cursor?: KnowledgeDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeDocumentScalarFieldEnum | KnowledgeDocumentScalarFieldEnum[]
  }

  /**
   * Agent.knowledgeSettings
   */
  export type Agent$knowledgeSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    where?: KnowledgeSettingsWhereInput
  }

  /**
   * Agent.triggers
   */
  export type Agent$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    where?: AgentTriggerWhereInput
    orderBy?: AgentTriggerOrderByWithRelationInput | AgentTriggerOrderByWithRelationInput[]
    cursor?: AgentTriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentTriggerScalarFieldEnum | AgentTriggerScalarFieldEnum[]
  }

  /**
   * Agent.embed
   */
  export type Agent$embedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    where?: AgentEmbedWhereInput
  }

  /**
   * Agent.connectedTo
   */
  export type Agent$connectedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    where?: AgentConnectionWhereInput
    orderBy?: AgentConnectionOrderByWithRelationInput | AgentConnectionOrderByWithRelationInput[]
    cursor?: AgentConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentConnectionScalarFieldEnum | AgentConnectionScalarFieldEnum[]
  }

  /**
   * Agent.connectedFrom
   */
  export type Agent$connectedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    where?: AgentConnectionWhereInput
    orderBy?: AgentConnectionOrderByWithRelationInput | AgentConnectionOrderByWithRelationInput[]
    cursor?: AgentConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentConnectionScalarFieldEnum | AgentConnectionScalarFieldEnum[]
  }

  /**
   * Agent.swarms
   */
  export type Agent$swarmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    where?: AgentSwarmWhereInput
    orderBy?: AgentSwarmOrderByWithRelationInput | AgentSwarmOrderByWithRelationInput[]
    cursor?: AgentSwarmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentSwarmScalarFieldEnum | AgentSwarmScalarFieldEnum[]
  }

  /**
   * Agent.emailAddress
   */
  export type Agent$emailAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    where?: AgentEmailAddressWhereInput
  }

  /**
   * Agent.meetingRecordings
   */
  export type Agent$meetingRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    where?: MeetingRecordingWhereInput
    orderBy?: MeetingRecordingOrderByWithRelationInput | MeetingRecordingOrderByWithRelationInput[]
    cursor?: MeetingRecordingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingRecordingScalarFieldEnum | MeetingRecordingScalarFieldEnum[]
  }

  /**
   * Agent.phoneNumber
   */
  export type Agent$phoneNumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    where?: AgentPhoneNumberWhereInput
  }

  /**
   * Agent.metrics
   */
  export type Agent$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    where?: AgentMetricWhereInput
    orderBy?: AgentMetricOrderByWithRelationInput | AgentMetricOrderByWithRelationInput[]
    cursor?: AgentMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentMetricScalarFieldEnum | AgentMetricScalarFieldEnum[]
  }

  /**
   * Agent.traces
   */
  export type Agent$tracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    where?: AgentTraceWhereInput
    orderBy?: AgentTraceOrderByWithRelationInput | AgentTraceOrderByWithRelationInput[]
    cursor?: AgentTraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentTraceScalarFieldEnum | AgentTraceScalarFieldEnum[]
  }

  /**
   * Agent.insights
   */
  export type Agent$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    where?: AgentInsightWhereInput
    orderBy?: AgentInsightOrderByWithRelationInput | AgentInsightOrderByWithRelationInput[]
    cursor?: AgentInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentInsightScalarFieldEnum | AgentInsightScalarFieldEnum[]
  }

  /**
   * Agent.feedbacks
   */
  export type Agent$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    where?: AgentFeedbackWhereInput
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    cursor?: AgentFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentFeedbackScalarFieldEnum | AgentFeedbackScalarFieldEnum[]
  }

  /**
   * Agent.abTests
   */
  export type Agent$abTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    where?: AgentABTestWhereInput
    orderBy?: AgentABTestOrderByWithRelationInput | AgentABTestOrderByWithRelationInput[]
    cursor?: AgentABTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentABTestScalarFieldEnum | AgentABTestScalarFieldEnum[]
  }

  /**
   * Agent.optimizationRuns
   */
  export type Agent$optimizationRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    where?: OptimizationRunWhereInput
    orderBy?: OptimizationRunOrderByWithRelationInput | OptimizationRunOrderByWithRelationInput[]
    cursor?: OptimizationRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptimizationRunScalarFieldEnum | OptimizationRunScalarFieldEnum[]
  }

  /**
   * Agent.modificationProposals
   */
  export type Agent$modificationProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    where?: ModificationProposalWhereInput
    orderBy?: ModificationProposalOrderByWithRelationInput | ModificationProposalOrderByWithRelationInput[]
    cursor?: ModificationProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModificationProposalScalarFieldEnum | ModificationProposalScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model AgentConnection
   */

  export type AggregateAgentConnection = {
    _count: AgentConnectionCountAggregateOutputType | null
    _min: AgentConnectionMinAggregateOutputType | null
    _max: AgentConnectionMaxAggregateOutputType | null
  }

  export type AgentConnectionMinAggregateOutputType = {
    id: string | null
    sourceAgentId: string | null
    targetAgentId: string | null
    alias: string | null
    description: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentConnectionMaxAggregateOutputType = {
    id: string | null
    sourceAgentId: string | null
    targetAgentId: string | null
    alias: string | null
    description: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentConnectionCountAggregateOutputType = {
    id: number
    sourceAgentId: number
    targetAgentId: number
    alias: number
    description: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentConnectionMinAggregateInputType = {
    id?: true
    sourceAgentId?: true
    targetAgentId?: true
    alias?: true
    description?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentConnectionMaxAggregateInputType = {
    id?: true
    sourceAgentId?: true
    targetAgentId?: true
    alias?: true
    description?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentConnectionCountAggregateInputType = {
    id?: true
    sourceAgentId?: true
    targetAgentId?: true
    alias?: true
    description?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentConnection to aggregate.
     */
    where?: AgentConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConnections to fetch.
     */
    orderBy?: AgentConnectionOrderByWithRelationInput | AgentConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentConnections
    **/
    _count?: true | AgentConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentConnectionMaxAggregateInputType
  }

  export type GetAgentConnectionAggregateType<T extends AgentConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentConnection[P]>
      : GetScalarType<T[P], AggregateAgentConnection[P]>
  }




  export type AgentConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentConnectionWhereInput
    orderBy?: AgentConnectionOrderByWithAggregationInput | AgentConnectionOrderByWithAggregationInput[]
    by: AgentConnectionScalarFieldEnum[] | AgentConnectionScalarFieldEnum
    having?: AgentConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentConnectionCountAggregateInputType | true
    _min?: AgentConnectionMinAggregateInputType
    _max?: AgentConnectionMaxAggregateInputType
  }

  export type AgentConnectionGroupByOutputType = {
    id: string
    sourceAgentId: string
    targetAgentId: string
    alias: string
    description: string
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: AgentConnectionCountAggregateOutputType | null
    _min: AgentConnectionMinAggregateOutputType | null
    _max: AgentConnectionMaxAggregateOutputType | null
  }

  type GetAgentConnectionGroupByPayload<T extends AgentConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], AgentConnectionGroupByOutputType[P]>
        }
      >
    >


  export type AgentConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceAgentId?: boolean
    targetAgentId?: boolean
    alias?: boolean
    description?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceAgent?: boolean | AgentDefaultArgs<ExtArgs>
    targetAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentConnection"]>

  export type AgentConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceAgentId?: boolean
    targetAgentId?: boolean
    alias?: boolean
    description?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceAgent?: boolean | AgentDefaultArgs<ExtArgs>
    targetAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentConnection"]>

  export type AgentConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceAgentId?: boolean
    targetAgentId?: boolean
    alias?: boolean
    description?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceAgent?: boolean | AgentDefaultArgs<ExtArgs>
    targetAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentConnection"]>

  export type AgentConnectionSelectScalar = {
    id?: boolean
    sourceAgentId?: boolean
    targetAgentId?: boolean
    alias?: boolean
    description?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceAgentId" | "targetAgentId" | "alias" | "description" | "enabled" | "createdAt" | "updatedAt", ExtArgs["result"]["agentConnection"]>
  export type AgentConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceAgent?: boolean | AgentDefaultArgs<ExtArgs>
    targetAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceAgent?: boolean | AgentDefaultArgs<ExtArgs>
    targetAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceAgent?: boolean | AgentDefaultArgs<ExtArgs>
    targetAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentConnection"
    objects: {
      sourceAgent: Prisma.$AgentPayload<ExtArgs>
      targetAgent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceAgentId: string
      targetAgentId: string
      alias: string
      description: string
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentConnection"]>
    composites: {}
  }

  type AgentConnectionGetPayload<S extends boolean | null | undefined | AgentConnectionDefaultArgs> = $Result.GetResult<Prisma.$AgentConnectionPayload, S>

  type AgentConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentConnectionCountAggregateInputType | true
    }

  export interface AgentConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentConnection'], meta: { name: 'AgentConnection' } }
    /**
     * Find zero or one AgentConnection that matches the filter.
     * @param {AgentConnectionFindUniqueArgs} args - Arguments to find a AgentConnection
     * @example
     * // Get one AgentConnection
     * const agentConnection = await prisma.agentConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentConnectionFindUniqueArgs>(args: SelectSubset<T, AgentConnectionFindUniqueArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentConnectionFindUniqueOrThrowArgs} args - Arguments to find a AgentConnection
     * @example
     * // Get one AgentConnection
     * const agentConnection = await prisma.agentConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionFindFirstArgs} args - Arguments to find a AgentConnection
     * @example
     * // Get one AgentConnection
     * const agentConnection = await prisma.agentConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentConnectionFindFirstArgs>(args?: SelectSubset<T, AgentConnectionFindFirstArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionFindFirstOrThrowArgs} args - Arguments to find a AgentConnection
     * @example
     * // Get one AgentConnection
     * const agentConnection = await prisma.agentConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentConnections
     * const agentConnections = await prisma.agentConnection.findMany()
     * 
     * // Get first 10 AgentConnections
     * const agentConnections = await prisma.agentConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentConnectionWithIdOnly = await prisma.agentConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentConnectionFindManyArgs>(args?: SelectSubset<T, AgentConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentConnection.
     * @param {AgentConnectionCreateArgs} args - Arguments to create a AgentConnection.
     * @example
     * // Create one AgentConnection
     * const AgentConnection = await prisma.agentConnection.create({
     *   data: {
     *     // ... data to create a AgentConnection
     *   }
     * })
     * 
     */
    create<T extends AgentConnectionCreateArgs>(args: SelectSubset<T, AgentConnectionCreateArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentConnections.
     * @param {AgentConnectionCreateManyArgs} args - Arguments to create many AgentConnections.
     * @example
     * // Create many AgentConnections
     * const agentConnection = await prisma.agentConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentConnectionCreateManyArgs>(args?: SelectSubset<T, AgentConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentConnections and returns the data saved in the database.
     * @param {AgentConnectionCreateManyAndReturnArgs} args - Arguments to create many AgentConnections.
     * @example
     * // Create many AgentConnections
     * const agentConnection = await prisma.agentConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentConnections and only return the `id`
     * const agentConnectionWithIdOnly = await prisma.agentConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentConnection.
     * @param {AgentConnectionDeleteArgs} args - Arguments to delete one AgentConnection.
     * @example
     * // Delete one AgentConnection
     * const AgentConnection = await prisma.agentConnection.delete({
     *   where: {
     *     // ... filter to delete one AgentConnection
     *   }
     * })
     * 
     */
    delete<T extends AgentConnectionDeleteArgs>(args: SelectSubset<T, AgentConnectionDeleteArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentConnection.
     * @param {AgentConnectionUpdateArgs} args - Arguments to update one AgentConnection.
     * @example
     * // Update one AgentConnection
     * const agentConnection = await prisma.agentConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentConnectionUpdateArgs>(args: SelectSubset<T, AgentConnectionUpdateArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentConnections.
     * @param {AgentConnectionDeleteManyArgs} args - Arguments to filter AgentConnections to delete.
     * @example
     * // Delete a few AgentConnections
     * const { count } = await prisma.agentConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentConnectionDeleteManyArgs>(args?: SelectSubset<T, AgentConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentConnections
     * const agentConnection = await prisma.agentConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentConnectionUpdateManyArgs>(args: SelectSubset<T, AgentConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentConnections and returns the data updated in the database.
     * @param {AgentConnectionUpdateManyAndReturnArgs} args - Arguments to update many AgentConnections.
     * @example
     * // Update many AgentConnections
     * const agentConnection = await prisma.agentConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentConnections and only return the `id`
     * const agentConnectionWithIdOnly = await prisma.agentConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentConnection.
     * @param {AgentConnectionUpsertArgs} args - Arguments to update or create a AgentConnection.
     * @example
     * // Update or create a AgentConnection
     * const agentConnection = await prisma.agentConnection.upsert({
     *   create: {
     *     // ... data to create a AgentConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentConnection we want to update
     *   }
     * })
     */
    upsert<T extends AgentConnectionUpsertArgs>(args: SelectSubset<T, AgentConnectionUpsertArgs<ExtArgs>>): Prisma__AgentConnectionClient<$Result.GetResult<Prisma.$AgentConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionCountArgs} args - Arguments to filter AgentConnections to count.
     * @example
     * // Count the number of AgentConnections
     * const count = await prisma.agentConnection.count({
     *   where: {
     *     // ... the filter for the AgentConnections we want to count
     *   }
     * })
    **/
    count<T extends AgentConnectionCountArgs>(
      args?: Subset<T, AgentConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentConnectionAggregateArgs>(args: Subset<T, AgentConnectionAggregateArgs>): Prisma.PrismaPromise<GetAgentConnectionAggregateType<T>>

    /**
     * Group by AgentConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentConnectionGroupByArgs['orderBy'] }
        : { orderBy?: AgentConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentConnection model
   */
  readonly fields: AgentConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceAgent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetAgent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentConnection model
   */
  interface AgentConnectionFieldRefs {
    readonly id: FieldRef<"AgentConnection", 'String'>
    readonly sourceAgentId: FieldRef<"AgentConnection", 'String'>
    readonly targetAgentId: FieldRef<"AgentConnection", 'String'>
    readonly alias: FieldRef<"AgentConnection", 'String'>
    readonly description: FieldRef<"AgentConnection", 'String'>
    readonly enabled: FieldRef<"AgentConnection", 'Boolean'>
    readonly createdAt: FieldRef<"AgentConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentConnection findUnique
   */
  export type AgentConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * Filter, which AgentConnection to fetch.
     */
    where: AgentConnectionWhereUniqueInput
  }

  /**
   * AgentConnection findUniqueOrThrow
   */
  export type AgentConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * Filter, which AgentConnection to fetch.
     */
    where: AgentConnectionWhereUniqueInput
  }

  /**
   * AgentConnection findFirst
   */
  export type AgentConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * Filter, which AgentConnection to fetch.
     */
    where?: AgentConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConnections to fetch.
     */
    orderBy?: AgentConnectionOrderByWithRelationInput | AgentConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentConnections.
     */
    cursor?: AgentConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentConnections.
     */
    distinct?: AgentConnectionScalarFieldEnum | AgentConnectionScalarFieldEnum[]
  }

  /**
   * AgentConnection findFirstOrThrow
   */
  export type AgentConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * Filter, which AgentConnection to fetch.
     */
    where?: AgentConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConnections to fetch.
     */
    orderBy?: AgentConnectionOrderByWithRelationInput | AgentConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentConnections.
     */
    cursor?: AgentConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentConnections.
     */
    distinct?: AgentConnectionScalarFieldEnum | AgentConnectionScalarFieldEnum[]
  }

  /**
   * AgentConnection findMany
   */
  export type AgentConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * Filter, which AgentConnections to fetch.
     */
    where?: AgentConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConnections to fetch.
     */
    orderBy?: AgentConnectionOrderByWithRelationInput | AgentConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentConnections.
     */
    cursor?: AgentConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConnections.
     */
    skip?: number
    distinct?: AgentConnectionScalarFieldEnum | AgentConnectionScalarFieldEnum[]
  }

  /**
   * AgentConnection create
   */
  export type AgentConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentConnection.
     */
    data: XOR<AgentConnectionCreateInput, AgentConnectionUncheckedCreateInput>
  }

  /**
   * AgentConnection createMany
   */
  export type AgentConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentConnections.
     */
    data: AgentConnectionCreateManyInput | AgentConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentConnection createManyAndReturn
   */
  export type AgentConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many AgentConnections.
     */
    data: AgentConnectionCreateManyInput | AgentConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentConnection update
   */
  export type AgentConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentConnection.
     */
    data: XOR<AgentConnectionUpdateInput, AgentConnectionUncheckedUpdateInput>
    /**
     * Choose, which AgentConnection to update.
     */
    where: AgentConnectionWhereUniqueInput
  }

  /**
   * AgentConnection updateMany
   */
  export type AgentConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentConnections.
     */
    data: XOR<AgentConnectionUpdateManyMutationInput, AgentConnectionUncheckedUpdateManyInput>
    /**
     * Filter which AgentConnections to update
     */
    where?: AgentConnectionWhereInput
    /**
     * Limit how many AgentConnections to update.
     */
    limit?: number
  }

  /**
   * AgentConnection updateManyAndReturn
   */
  export type AgentConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * The data used to update AgentConnections.
     */
    data: XOR<AgentConnectionUpdateManyMutationInput, AgentConnectionUncheckedUpdateManyInput>
    /**
     * Filter which AgentConnections to update
     */
    where?: AgentConnectionWhereInput
    /**
     * Limit how many AgentConnections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentConnection upsert
   */
  export type AgentConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentConnection to update in case it exists.
     */
    where: AgentConnectionWhereUniqueInput
    /**
     * In case the AgentConnection found by the `where` argument doesn't exist, create a new AgentConnection with this data.
     */
    create: XOR<AgentConnectionCreateInput, AgentConnectionUncheckedCreateInput>
    /**
     * In case the AgentConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentConnectionUpdateInput, AgentConnectionUncheckedUpdateInput>
  }

  /**
   * AgentConnection delete
   */
  export type AgentConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
    /**
     * Filter which AgentConnection to delete.
     */
    where: AgentConnectionWhereUniqueInput
  }

  /**
   * AgentConnection deleteMany
   */
  export type AgentConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentConnections to delete
     */
    where?: AgentConnectionWhereInput
    /**
     * Limit how many AgentConnections to delete.
     */
    limit?: number
  }

  /**
   * AgentConnection without action
   */
  export type AgentConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConnection
     */
    select?: AgentConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConnection
     */
    omit?: AgentConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentConnectionInclude<ExtArgs> | null
  }


  /**
   * Model AgentTool
   */

  export type AggregateAgentTool = {
    _count: AgentToolCountAggregateOutputType | null
    _min: AgentToolMinAggregateOutputType | null
    _max: AgentToolMaxAggregateOutputType | null
  }

  export type AgentToolMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    workflowId: string | null
    composioAppKey: string | null
    composioActionName: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentToolMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    workflowId: string | null
    composioAppKey: string | null
    composioActionName: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentToolCountAggregateOutputType = {
    id: number
    agentId: number
    workflowId: number
    composioAppKey: number
    composioActionName: number
    composioConfig: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentToolMinAggregateInputType = {
    id?: true
    agentId?: true
    workflowId?: true
    composioAppKey?: true
    composioActionName?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentToolMaxAggregateInputType = {
    id?: true
    agentId?: true
    workflowId?: true
    composioAppKey?: true
    composioActionName?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentToolCountAggregateInputType = {
    id?: true
    agentId?: true
    workflowId?: true
    composioAppKey?: true
    composioActionName?: true
    composioConfig?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTool to aggregate.
     */
    where?: AgentToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTools to fetch.
     */
    orderBy?: AgentToolOrderByWithRelationInput | AgentToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentTools
    **/
    _count?: true | AgentToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentToolMaxAggregateInputType
  }

  export type GetAgentToolAggregateType<T extends AgentToolAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentTool[P]>
      : GetScalarType<T[P], AggregateAgentTool[P]>
  }




  export type AgentToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentToolWhereInput
    orderBy?: AgentToolOrderByWithAggregationInput | AgentToolOrderByWithAggregationInput[]
    by: AgentToolScalarFieldEnum[] | AgentToolScalarFieldEnum
    having?: AgentToolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentToolCountAggregateInputType | true
    _min?: AgentToolMinAggregateInputType
    _max?: AgentToolMaxAggregateInputType
  }

  export type AgentToolGroupByOutputType = {
    id: string
    agentId: string
    workflowId: string | null
    composioAppKey: string | null
    composioActionName: string | null
    composioConfig: JsonValue | null
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: AgentToolCountAggregateOutputType | null
    _min: AgentToolMinAggregateOutputType | null
    _max: AgentToolMaxAggregateOutputType | null
  }

  type GetAgentToolGroupByPayload<T extends AgentToolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentToolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentToolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentToolGroupByOutputType[P]>
            : GetScalarType<T[P], AgentToolGroupByOutputType[P]>
        }
      >
    >


  export type AgentToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    workflowId?: boolean
    composioAppKey?: boolean
    composioActionName?: boolean
    composioConfig?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workflow?: boolean | AgentTool$workflowArgs<ExtArgs>
  }, ExtArgs["result"]["agentTool"]>

  export type AgentToolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    workflowId?: boolean
    composioAppKey?: boolean
    composioActionName?: boolean
    composioConfig?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workflow?: boolean | AgentTool$workflowArgs<ExtArgs>
  }, ExtArgs["result"]["agentTool"]>

  export type AgentToolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    workflowId?: boolean
    composioAppKey?: boolean
    composioActionName?: boolean
    composioConfig?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workflow?: boolean | AgentTool$workflowArgs<ExtArgs>
  }, ExtArgs["result"]["agentTool"]>

  export type AgentToolSelectScalar = {
    id?: boolean
    agentId?: boolean
    workflowId?: boolean
    composioAppKey?: boolean
    composioActionName?: boolean
    composioConfig?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "workflowId" | "composioAppKey" | "composioActionName" | "composioConfig" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["agentTool"]>
  export type AgentToolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workflow?: boolean | AgentTool$workflowArgs<ExtArgs>
  }
  export type AgentToolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workflow?: boolean | AgentTool$workflowArgs<ExtArgs>
  }
  export type AgentToolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workflow?: boolean | AgentTool$workflowArgs<ExtArgs>
  }

  export type $AgentToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentTool"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      workflow: Prisma.$WorkflowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      workflowId: string | null
      composioAppKey: string | null
      composioActionName: string | null
      composioConfig: Prisma.JsonValue | null
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentTool"]>
    composites: {}
  }

  type AgentToolGetPayload<S extends boolean | null | undefined | AgentToolDefaultArgs> = $Result.GetResult<Prisma.$AgentToolPayload, S>

  type AgentToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentToolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentToolCountAggregateInputType | true
    }

  export interface AgentToolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentTool'], meta: { name: 'AgentTool' } }
    /**
     * Find zero or one AgentTool that matches the filter.
     * @param {AgentToolFindUniqueArgs} args - Arguments to find a AgentTool
     * @example
     * // Get one AgentTool
     * const agentTool = await prisma.agentTool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentToolFindUniqueArgs>(args: SelectSubset<T, AgentToolFindUniqueArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentTool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentToolFindUniqueOrThrowArgs} args - Arguments to find a AgentTool
     * @example
     * // Get one AgentTool
     * const agentTool = await prisma.agentTool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentToolFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentToolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolFindFirstArgs} args - Arguments to find a AgentTool
     * @example
     * // Get one AgentTool
     * const agentTool = await prisma.agentTool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentToolFindFirstArgs>(args?: SelectSubset<T, AgentToolFindFirstArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolFindFirstOrThrowArgs} args - Arguments to find a AgentTool
     * @example
     * // Get one AgentTool
     * const agentTool = await prisma.agentTool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentToolFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentToolFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentTools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentTools
     * const agentTools = await prisma.agentTool.findMany()
     * 
     * // Get first 10 AgentTools
     * const agentTools = await prisma.agentTool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentToolWithIdOnly = await prisma.agentTool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentToolFindManyArgs>(args?: SelectSubset<T, AgentToolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentTool.
     * @param {AgentToolCreateArgs} args - Arguments to create a AgentTool.
     * @example
     * // Create one AgentTool
     * const AgentTool = await prisma.agentTool.create({
     *   data: {
     *     // ... data to create a AgentTool
     *   }
     * })
     * 
     */
    create<T extends AgentToolCreateArgs>(args: SelectSubset<T, AgentToolCreateArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentTools.
     * @param {AgentToolCreateManyArgs} args - Arguments to create many AgentTools.
     * @example
     * // Create many AgentTools
     * const agentTool = await prisma.agentTool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentToolCreateManyArgs>(args?: SelectSubset<T, AgentToolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentTools and returns the data saved in the database.
     * @param {AgentToolCreateManyAndReturnArgs} args - Arguments to create many AgentTools.
     * @example
     * // Create many AgentTools
     * const agentTool = await prisma.agentTool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentTools and only return the `id`
     * const agentToolWithIdOnly = await prisma.agentTool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentToolCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentToolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentTool.
     * @param {AgentToolDeleteArgs} args - Arguments to delete one AgentTool.
     * @example
     * // Delete one AgentTool
     * const AgentTool = await prisma.agentTool.delete({
     *   where: {
     *     // ... filter to delete one AgentTool
     *   }
     * })
     * 
     */
    delete<T extends AgentToolDeleteArgs>(args: SelectSubset<T, AgentToolDeleteArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentTool.
     * @param {AgentToolUpdateArgs} args - Arguments to update one AgentTool.
     * @example
     * // Update one AgentTool
     * const agentTool = await prisma.agentTool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentToolUpdateArgs>(args: SelectSubset<T, AgentToolUpdateArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentTools.
     * @param {AgentToolDeleteManyArgs} args - Arguments to filter AgentTools to delete.
     * @example
     * // Delete a few AgentTools
     * const { count } = await prisma.agentTool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentToolDeleteManyArgs>(args?: SelectSubset<T, AgentToolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentTools
     * const agentTool = await prisma.agentTool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentToolUpdateManyArgs>(args: SelectSubset<T, AgentToolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTools and returns the data updated in the database.
     * @param {AgentToolUpdateManyAndReturnArgs} args - Arguments to update many AgentTools.
     * @example
     * // Update many AgentTools
     * const agentTool = await prisma.agentTool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentTools and only return the `id`
     * const agentToolWithIdOnly = await prisma.agentTool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentToolUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentToolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentTool.
     * @param {AgentToolUpsertArgs} args - Arguments to update or create a AgentTool.
     * @example
     * // Update or create a AgentTool
     * const agentTool = await prisma.agentTool.upsert({
     *   create: {
     *     // ... data to create a AgentTool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentTool we want to update
     *   }
     * })
     */
    upsert<T extends AgentToolUpsertArgs>(args: SelectSubset<T, AgentToolUpsertArgs<ExtArgs>>): Prisma__AgentToolClient<$Result.GetResult<Prisma.$AgentToolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolCountArgs} args - Arguments to filter AgentTools to count.
     * @example
     * // Count the number of AgentTools
     * const count = await prisma.agentTool.count({
     *   where: {
     *     // ... the filter for the AgentTools we want to count
     *   }
     * })
    **/
    count<T extends AgentToolCountArgs>(
      args?: Subset<T, AgentToolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentToolAggregateArgs>(args: Subset<T, AgentToolAggregateArgs>): Prisma.PrismaPromise<GetAgentToolAggregateType<T>>

    /**
     * Group by AgentTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentToolGroupByArgs['orderBy'] }
        : { orderBy?: AgentToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentTool model
   */
  readonly fields: AgentToolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentTool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentToolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workflow<T extends AgentTool$workflowArgs<ExtArgs> = {}>(args?: Subset<T, AgentTool$workflowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentTool model
   */
  interface AgentToolFieldRefs {
    readonly id: FieldRef<"AgentTool", 'String'>
    readonly agentId: FieldRef<"AgentTool", 'String'>
    readonly workflowId: FieldRef<"AgentTool", 'String'>
    readonly composioAppKey: FieldRef<"AgentTool", 'String'>
    readonly composioActionName: FieldRef<"AgentTool", 'String'>
    readonly composioConfig: FieldRef<"AgentTool", 'Json'>
    readonly name: FieldRef<"AgentTool", 'String'>
    readonly description: FieldRef<"AgentTool", 'String'>
    readonly createdAt: FieldRef<"AgentTool", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentTool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentTool findUnique
   */
  export type AgentToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * Filter, which AgentTool to fetch.
     */
    where: AgentToolWhereUniqueInput
  }

  /**
   * AgentTool findUniqueOrThrow
   */
  export type AgentToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * Filter, which AgentTool to fetch.
     */
    where: AgentToolWhereUniqueInput
  }

  /**
   * AgentTool findFirst
   */
  export type AgentToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * Filter, which AgentTool to fetch.
     */
    where?: AgentToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTools to fetch.
     */
    orderBy?: AgentToolOrderByWithRelationInput | AgentToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTools.
     */
    cursor?: AgentToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTools.
     */
    distinct?: AgentToolScalarFieldEnum | AgentToolScalarFieldEnum[]
  }

  /**
   * AgentTool findFirstOrThrow
   */
  export type AgentToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * Filter, which AgentTool to fetch.
     */
    where?: AgentToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTools to fetch.
     */
    orderBy?: AgentToolOrderByWithRelationInput | AgentToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTools.
     */
    cursor?: AgentToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTools.
     */
    distinct?: AgentToolScalarFieldEnum | AgentToolScalarFieldEnum[]
  }

  /**
   * AgentTool findMany
   */
  export type AgentToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * Filter, which AgentTools to fetch.
     */
    where?: AgentToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTools to fetch.
     */
    orderBy?: AgentToolOrderByWithRelationInput | AgentToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentTools.
     */
    cursor?: AgentToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTools.
     */
    skip?: number
    distinct?: AgentToolScalarFieldEnum | AgentToolScalarFieldEnum[]
  }

  /**
   * AgentTool create
   */
  export type AgentToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentTool.
     */
    data: XOR<AgentToolCreateInput, AgentToolUncheckedCreateInput>
  }

  /**
   * AgentTool createMany
   */
  export type AgentToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentTools.
     */
    data: AgentToolCreateManyInput | AgentToolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTool createManyAndReturn
   */
  export type AgentToolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * The data used to create many AgentTools.
     */
    data: AgentToolCreateManyInput | AgentToolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTool update
   */
  export type AgentToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentTool.
     */
    data: XOR<AgentToolUpdateInput, AgentToolUncheckedUpdateInput>
    /**
     * Choose, which AgentTool to update.
     */
    where: AgentToolWhereUniqueInput
  }

  /**
   * AgentTool updateMany
   */
  export type AgentToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentTools.
     */
    data: XOR<AgentToolUpdateManyMutationInput, AgentToolUncheckedUpdateManyInput>
    /**
     * Filter which AgentTools to update
     */
    where?: AgentToolWhereInput
    /**
     * Limit how many AgentTools to update.
     */
    limit?: number
  }

  /**
   * AgentTool updateManyAndReturn
   */
  export type AgentToolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * The data used to update AgentTools.
     */
    data: XOR<AgentToolUpdateManyMutationInput, AgentToolUncheckedUpdateManyInput>
    /**
     * Filter which AgentTools to update
     */
    where?: AgentToolWhereInput
    /**
     * Limit how many AgentTools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTool upsert
   */
  export type AgentToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentTool to update in case it exists.
     */
    where: AgentToolWhereUniqueInput
    /**
     * In case the AgentTool found by the `where` argument doesn't exist, create a new AgentTool with this data.
     */
    create: XOR<AgentToolCreateInput, AgentToolUncheckedCreateInput>
    /**
     * In case the AgentTool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentToolUpdateInput, AgentToolUncheckedUpdateInput>
  }

  /**
   * AgentTool delete
   */
  export type AgentToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
    /**
     * Filter which AgentTool to delete.
     */
    where: AgentToolWhereUniqueInput
  }

  /**
   * AgentTool deleteMany
   */
  export type AgentToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTools to delete
     */
    where?: AgentToolWhereInput
    /**
     * Limit how many AgentTools to delete.
     */
    limit?: number
  }

  /**
   * AgentTool.workflow
   */
  export type AgentTool$workflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
  }

  /**
   * AgentTool without action
   */
  export type AgentToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTool
     */
    select?: AgentToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTool
     */
    omit?: AgentToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentToolInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    title: string | null
    agentId: string | null
    isArchived: boolean | null
    isPinned: boolean | null
    shareToken: string | null
    source: $Enums.ConversationSource | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    agentId: string | null
    isArchived: boolean | null
    isPinned: boolean | null
    shareToken: string | null
    source: $Enums.ConversationSource | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    title: number
    agentId: number
    isArchived: number
    isPinned: number
    shareToken: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    title?: true
    agentId?: true
    isArchived?: true
    isPinned?: true
    shareToken?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    title?: true
    agentId?: true
    isArchived?: true
    isPinned?: true
    shareToken?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    title?: true
    agentId?: true
    isArchived?: true
    isPinned?: true
    shareToken?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    title: string | null
    agentId: string
    isArchived: boolean
    isPinned: boolean
    shareToken: string | null
    source: $Enums.ConversationSource
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    agentId?: boolean
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    activities?: boolean | Conversation$activitiesArgs<ExtArgs>
    traces?: boolean | Conversation$tracesArgs<ExtArgs>
    evaluation?: boolean | Conversation$evaluationArgs<ExtArgs>
    feedbacks?: boolean | Conversation$feedbacksArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    agentId?: boolean
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    agentId?: boolean
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    title?: boolean
    agentId?: boolean
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "agentId" | "isArchived" | "isPinned" | "shareToken" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    activities?: boolean | Conversation$activitiesArgs<ExtArgs>
    traces?: boolean | Conversation$tracesArgs<ExtArgs>
    evaluation?: boolean | Conversation$evaluationArgs<ExtArgs>
    feedbacks?: boolean | Conversation$feedbacksArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      activities: Prisma.$ConversationActivityPayload<ExtArgs>[]
      traces: Prisma.$AgentTracePayload<ExtArgs>[]
      evaluation: Prisma.$ConversationEvaluationPayload<ExtArgs> | null
      feedbacks: Prisma.$AgentFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      agentId: string
      isArchived: boolean
      isPinned: boolean
      shareToken: string | null
      source: $Enums.ConversationSource
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Conversation$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    traces<T extends Conversation$tracesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$tracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluation<T extends Conversation$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$evaluationArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedbacks<T extends Conversation$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly agentId: FieldRef<"Conversation", 'String'>
    readonly isArchived: FieldRef<"Conversation", 'Boolean'>
    readonly isPinned: FieldRef<"Conversation", 'Boolean'>
    readonly shareToken: FieldRef<"Conversation", 'String'>
    readonly source: FieldRef<"Conversation", 'ConversationSource'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.activities
   */
  export type Conversation$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    where?: ConversationActivityWhereInput
    orderBy?: ConversationActivityOrderByWithRelationInput | ConversationActivityOrderByWithRelationInput[]
    cursor?: ConversationActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationActivityScalarFieldEnum | ConversationActivityScalarFieldEnum[]
  }

  /**
   * Conversation.traces
   */
  export type Conversation$tracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    where?: AgentTraceWhereInput
    orderBy?: AgentTraceOrderByWithRelationInput | AgentTraceOrderByWithRelationInput[]
    cursor?: AgentTraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentTraceScalarFieldEnum | AgentTraceScalarFieldEnum[]
  }

  /**
   * Conversation.evaluation
   */
  export type Conversation$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    where?: ConversationEvaluationWhereInput
  }

  /**
   * Conversation.feedbacks
   */
  export type Conversation$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    where?: AgentFeedbackWhereInput
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    cursor?: AgentFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentFeedbackScalarFieldEnum | AgentFeedbackScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    toolName: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    toolName: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    toolName: number
    toolInput: number
    toolOutput: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    toolName?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    toolName?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    toolName?: true
    toolInput?: true
    toolOutput?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    toolName: string | null
    toolInput: JsonValue | null
    toolOutput: JsonValue | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "role" | "content" | "toolName" | "toolInput" | "toolOutput" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: $Enums.MessageRole
      content: string
      toolName: string | null
      toolInput: Prisma.JsonValue | null
      toolOutput: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'MessageRole'>
    readonly content: FieldRef<"Message", 'String'>
    readonly toolName: FieldRef<"Message", 'String'>
    readonly toolInput: FieldRef<"Message", 'Json'>
    readonly toolOutput: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ConversationActivity
   */

  export type AggregateConversationActivity = {
    _count: ConversationActivityCountAggregateOutputType | null
    _min: ConversationActivityMinAggregateOutputType | null
    _max: ConversationActivityMaxAggregateOutputType | null
  }

  export type ConversationActivityMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    type: $Enums.ActivityType | null
    title: string | null
    requiresConfirmation: boolean | null
    confirmedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
  }

  export type ConversationActivityMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    type: $Enums.ActivityType | null
    title: string | null
    requiresConfirmation: boolean | null
    confirmedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
  }

  export type ConversationActivityCountAggregateOutputType = {
    id: number
    conversationId: number
    type: number
    title: number
    details: number
    requiresConfirmation: number
    confirmedAt: number
    rejectedAt: number
    createdAt: number
    _all: number
  }


  export type ConversationActivityMinAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    title?: true
    requiresConfirmation?: true
    confirmedAt?: true
    rejectedAt?: true
    createdAt?: true
  }

  export type ConversationActivityMaxAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    title?: true
    requiresConfirmation?: true
    confirmedAt?: true
    rejectedAt?: true
    createdAt?: true
  }

  export type ConversationActivityCountAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    title?: true
    details?: true
    requiresConfirmation?: true
    confirmedAt?: true
    rejectedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationActivity to aggregate.
     */
    where?: ConversationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationActivities to fetch.
     */
    orderBy?: ConversationActivityOrderByWithRelationInput | ConversationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationActivities
    **/
    _count?: true | ConversationActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationActivityMaxAggregateInputType
  }

  export type GetConversationActivityAggregateType<T extends ConversationActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationActivity[P]>
      : GetScalarType<T[P], AggregateConversationActivity[P]>
  }




  export type ConversationActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationActivityWhereInput
    orderBy?: ConversationActivityOrderByWithAggregationInput | ConversationActivityOrderByWithAggregationInput[]
    by: ConversationActivityScalarFieldEnum[] | ConversationActivityScalarFieldEnum
    having?: ConversationActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationActivityCountAggregateInputType | true
    _min?: ConversationActivityMinAggregateInputType
    _max?: ConversationActivityMaxAggregateInputType
  }

  export type ConversationActivityGroupByOutputType = {
    id: string
    conversationId: string
    type: $Enums.ActivityType
    title: string
    details: JsonValue | null
    requiresConfirmation: boolean
    confirmedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date
    _count: ConversationActivityCountAggregateOutputType | null
    _min: ConversationActivityMinAggregateOutputType | null
    _max: ConversationActivityMaxAggregateOutputType | null
  }

  type GetConversationActivityGroupByPayload<T extends ConversationActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationActivityGroupByOutputType[P]>
        }
      >
    >


  export type ConversationActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    title?: boolean
    details?: boolean
    requiresConfirmation?: boolean
    confirmedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationActivity"]>

  export type ConversationActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    title?: boolean
    details?: boolean
    requiresConfirmation?: boolean
    confirmedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationActivity"]>

  export type ConversationActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    title?: boolean
    details?: boolean
    requiresConfirmation?: boolean
    confirmedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationActivity"]>

  export type ConversationActivitySelectScalar = {
    id?: boolean
    conversationId?: boolean
    type?: boolean
    title?: boolean
    details?: boolean
    requiresConfirmation?: boolean
    confirmedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
  }

  export type ConversationActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "type" | "title" | "details" | "requiresConfirmation" | "confirmedAt" | "rejectedAt" | "createdAt", ExtArgs["result"]["conversationActivity"]>
  export type ConversationActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ConversationActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationActivity"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      type: $Enums.ActivityType
      title: string
      details: Prisma.JsonValue | null
      requiresConfirmation: boolean
      confirmedAt: Date | null
      rejectedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["conversationActivity"]>
    composites: {}
  }

  type ConversationActivityGetPayload<S extends boolean | null | undefined | ConversationActivityDefaultArgs> = $Result.GetResult<Prisma.$ConversationActivityPayload, S>

  type ConversationActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationActivityCountAggregateInputType | true
    }

  export interface ConversationActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationActivity'], meta: { name: 'ConversationActivity' } }
    /**
     * Find zero or one ConversationActivity that matches the filter.
     * @param {ConversationActivityFindUniqueArgs} args - Arguments to find a ConversationActivity
     * @example
     * // Get one ConversationActivity
     * const conversationActivity = await prisma.conversationActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationActivityFindUniqueArgs>(args: SelectSubset<T, ConversationActivityFindUniqueArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationActivityFindUniqueOrThrowArgs} args - Arguments to find a ConversationActivity
     * @example
     * // Get one ConversationActivity
     * const conversationActivity = await prisma.conversationActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityFindFirstArgs} args - Arguments to find a ConversationActivity
     * @example
     * // Get one ConversationActivity
     * const conversationActivity = await prisma.conversationActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationActivityFindFirstArgs>(args?: SelectSubset<T, ConversationActivityFindFirstArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityFindFirstOrThrowArgs} args - Arguments to find a ConversationActivity
     * @example
     * // Get one ConversationActivity
     * const conversationActivity = await prisma.conversationActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationActivities
     * const conversationActivities = await prisma.conversationActivity.findMany()
     * 
     * // Get first 10 ConversationActivities
     * const conversationActivities = await prisma.conversationActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationActivityWithIdOnly = await prisma.conversationActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationActivityFindManyArgs>(args?: SelectSubset<T, ConversationActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationActivity.
     * @param {ConversationActivityCreateArgs} args - Arguments to create a ConversationActivity.
     * @example
     * // Create one ConversationActivity
     * const ConversationActivity = await prisma.conversationActivity.create({
     *   data: {
     *     // ... data to create a ConversationActivity
     *   }
     * })
     * 
     */
    create<T extends ConversationActivityCreateArgs>(args: SelectSubset<T, ConversationActivityCreateArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationActivities.
     * @param {ConversationActivityCreateManyArgs} args - Arguments to create many ConversationActivities.
     * @example
     * // Create many ConversationActivities
     * const conversationActivity = await prisma.conversationActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationActivityCreateManyArgs>(args?: SelectSubset<T, ConversationActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationActivities and returns the data saved in the database.
     * @param {ConversationActivityCreateManyAndReturnArgs} args - Arguments to create many ConversationActivities.
     * @example
     * // Create many ConversationActivities
     * const conversationActivity = await prisma.conversationActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationActivities and only return the `id`
     * const conversationActivityWithIdOnly = await prisma.conversationActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationActivity.
     * @param {ConversationActivityDeleteArgs} args - Arguments to delete one ConversationActivity.
     * @example
     * // Delete one ConversationActivity
     * const ConversationActivity = await prisma.conversationActivity.delete({
     *   where: {
     *     // ... filter to delete one ConversationActivity
     *   }
     * })
     * 
     */
    delete<T extends ConversationActivityDeleteArgs>(args: SelectSubset<T, ConversationActivityDeleteArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationActivity.
     * @param {ConversationActivityUpdateArgs} args - Arguments to update one ConversationActivity.
     * @example
     * // Update one ConversationActivity
     * const conversationActivity = await prisma.conversationActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationActivityUpdateArgs>(args: SelectSubset<T, ConversationActivityUpdateArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationActivities.
     * @param {ConversationActivityDeleteManyArgs} args - Arguments to filter ConversationActivities to delete.
     * @example
     * // Delete a few ConversationActivities
     * const { count } = await prisma.conversationActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationActivityDeleteManyArgs>(args?: SelectSubset<T, ConversationActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationActivities
     * const conversationActivity = await prisma.conversationActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationActivityUpdateManyArgs>(args: SelectSubset<T, ConversationActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationActivities and returns the data updated in the database.
     * @param {ConversationActivityUpdateManyAndReturnArgs} args - Arguments to update many ConversationActivities.
     * @example
     * // Update many ConversationActivities
     * const conversationActivity = await prisma.conversationActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationActivities and only return the `id`
     * const conversationActivityWithIdOnly = await prisma.conversationActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationActivity.
     * @param {ConversationActivityUpsertArgs} args - Arguments to update or create a ConversationActivity.
     * @example
     * // Update or create a ConversationActivity
     * const conversationActivity = await prisma.conversationActivity.upsert({
     *   create: {
     *     // ... data to create a ConversationActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationActivity we want to update
     *   }
     * })
     */
    upsert<T extends ConversationActivityUpsertArgs>(args: SelectSubset<T, ConversationActivityUpsertArgs<ExtArgs>>): Prisma__ConversationActivityClient<$Result.GetResult<Prisma.$ConversationActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityCountArgs} args - Arguments to filter ConversationActivities to count.
     * @example
     * // Count the number of ConversationActivities
     * const count = await prisma.conversationActivity.count({
     *   where: {
     *     // ... the filter for the ConversationActivities we want to count
     *   }
     * })
    **/
    count<T extends ConversationActivityCountArgs>(
      args?: Subset<T, ConversationActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationActivityAggregateArgs>(args: Subset<T, ConversationActivityAggregateArgs>): Prisma.PrismaPromise<GetConversationActivityAggregateType<T>>

    /**
     * Group by ConversationActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationActivityGroupByArgs['orderBy'] }
        : { orderBy?: ConversationActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationActivity model
   */
  readonly fields: ConversationActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationActivity model
   */
  interface ConversationActivityFieldRefs {
    readonly id: FieldRef<"ConversationActivity", 'String'>
    readonly conversationId: FieldRef<"ConversationActivity", 'String'>
    readonly type: FieldRef<"ConversationActivity", 'ActivityType'>
    readonly title: FieldRef<"ConversationActivity", 'String'>
    readonly details: FieldRef<"ConversationActivity", 'Json'>
    readonly requiresConfirmation: FieldRef<"ConversationActivity", 'Boolean'>
    readonly confirmedAt: FieldRef<"ConversationActivity", 'DateTime'>
    readonly rejectedAt: FieldRef<"ConversationActivity", 'DateTime'>
    readonly createdAt: FieldRef<"ConversationActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationActivity findUnique
   */
  export type ConversationActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * Filter, which ConversationActivity to fetch.
     */
    where: ConversationActivityWhereUniqueInput
  }

  /**
   * ConversationActivity findUniqueOrThrow
   */
  export type ConversationActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * Filter, which ConversationActivity to fetch.
     */
    where: ConversationActivityWhereUniqueInput
  }

  /**
   * ConversationActivity findFirst
   */
  export type ConversationActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * Filter, which ConversationActivity to fetch.
     */
    where?: ConversationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationActivities to fetch.
     */
    orderBy?: ConversationActivityOrderByWithRelationInput | ConversationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationActivities.
     */
    cursor?: ConversationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationActivities.
     */
    distinct?: ConversationActivityScalarFieldEnum | ConversationActivityScalarFieldEnum[]
  }

  /**
   * ConversationActivity findFirstOrThrow
   */
  export type ConversationActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * Filter, which ConversationActivity to fetch.
     */
    where?: ConversationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationActivities to fetch.
     */
    orderBy?: ConversationActivityOrderByWithRelationInput | ConversationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationActivities.
     */
    cursor?: ConversationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationActivities.
     */
    distinct?: ConversationActivityScalarFieldEnum | ConversationActivityScalarFieldEnum[]
  }

  /**
   * ConversationActivity findMany
   */
  export type ConversationActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * Filter, which ConversationActivities to fetch.
     */
    where?: ConversationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationActivities to fetch.
     */
    orderBy?: ConversationActivityOrderByWithRelationInput | ConversationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationActivities.
     */
    cursor?: ConversationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationActivities.
     */
    skip?: number
    distinct?: ConversationActivityScalarFieldEnum | ConversationActivityScalarFieldEnum[]
  }

  /**
   * ConversationActivity create
   */
  export type ConversationActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationActivity.
     */
    data: XOR<ConversationActivityCreateInput, ConversationActivityUncheckedCreateInput>
  }

  /**
   * ConversationActivity createMany
   */
  export type ConversationActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationActivities.
     */
    data: ConversationActivityCreateManyInput | ConversationActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationActivity createManyAndReturn
   */
  export type ConversationActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationActivities.
     */
    data: ConversationActivityCreateManyInput | ConversationActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationActivity update
   */
  export type ConversationActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationActivity.
     */
    data: XOR<ConversationActivityUpdateInput, ConversationActivityUncheckedUpdateInput>
    /**
     * Choose, which ConversationActivity to update.
     */
    where: ConversationActivityWhereUniqueInput
  }

  /**
   * ConversationActivity updateMany
   */
  export type ConversationActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationActivities.
     */
    data: XOR<ConversationActivityUpdateManyMutationInput, ConversationActivityUncheckedUpdateManyInput>
    /**
     * Filter which ConversationActivities to update
     */
    where?: ConversationActivityWhereInput
    /**
     * Limit how many ConversationActivities to update.
     */
    limit?: number
  }

  /**
   * ConversationActivity updateManyAndReturn
   */
  export type ConversationActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * The data used to update ConversationActivities.
     */
    data: XOR<ConversationActivityUpdateManyMutationInput, ConversationActivityUncheckedUpdateManyInput>
    /**
     * Filter which ConversationActivities to update
     */
    where?: ConversationActivityWhereInput
    /**
     * Limit how many ConversationActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationActivity upsert
   */
  export type ConversationActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationActivity to update in case it exists.
     */
    where: ConversationActivityWhereUniqueInput
    /**
     * In case the ConversationActivity found by the `where` argument doesn't exist, create a new ConversationActivity with this data.
     */
    create: XOR<ConversationActivityCreateInput, ConversationActivityUncheckedCreateInput>
    /**
     * In case the ConversationActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationActivityUpdateInput, ConversationActivityUncheckedUpdateInput>
  }

  /**
   * ConversationActivity delete
   */
  export type ConversationActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
    /**
     * Filter which ConversationActivity to delete.
     */
    where: ConversationActivityWhereUniqueInput
  }

  /**
   * ConversationActivity deleteMany
   */
  export type ConversationActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationActivities to delete
     */
    where?: ConversationActivityWhereInput
    /**
     * Limit how many ConversationActivities to delete.
     */
    limit?: number
  }

  /**
   * ConversationActivity without action
   */
  export type ConversationActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationActivity
     */
    select?: ConversationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationActivity
     */
    omit?: ConversationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationActivityInclude<ExtArgs> | null
  }


  /**
   * Model AgentMemory
   */

  export type AggregateAgentMemory = {
    _count: AgentMemoryCountAggregateOutputType | null
    _avg: AgentMemoryAvgAggregateOutputType | null
    _sum: AgentMemorySumAggregateOutputType | null
    _min: AgentMemoryMinAggregateOutputType | null
    _max: AgentMemoryMaxAggregateOutputType | null
  }

  export type AgentMemoryAvgAggregateOutputType = {
    embedding: number | null
  }

  export type AgentMemorySumAggregateOutputType = {
    embedding: number[]
  }

  export type AgentMemoryMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    key: string | null
    value: string | null
    category: $Enums.MemoryCategory | null
    source: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMemoryMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    key: string | null
    value: string | null
    category: $Enums.MemoryCategory | null
    source: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMemoryCountAggregateOutputType = {
    id: number
    agentId: number
    key: number
    value: number
    category: number
    embedding: number
    source: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentMemoryAvgAggregateInputType = {
    embedding?: true
  }

  export type AgentMemorySumAggregateInputType = {
    embedding?: true
  }

  export type AgentMemoryMinAggregateInputType = {
    id?: true
    agentId?: true
    key?: true
    value?: true
    category?: true
    source?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMemoryMaxAggregateInputType = {
    id?: true
    agentId?: true
    key?: true
    value?: true
    category?: true
    source?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMemoryCountAggregateInputType = {
    id?: true
    agentId?: true
    key?: true
    value?: true
    category?: true
    embedding?: true
    source?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentMemoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentMemory to aggregate.
     */
    where?: AgentMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMemories to fetch.
     */
    orderBy?: AgentMemoryOrderByWithRelationInput | AgentMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMemories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentMemories
    **/
    _count?: true | AgentMemoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentMemoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentMemorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMemoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMemoryMaxAggregateInputType
  }

  export type GetAgentMemoryAggregateType<T extends AgentMemoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentMemory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentMemory[P]>
      : GetScalarType<T[P], AggregateAgentMemory[P]>
  }




  export type AgentMemoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentMemoryWhereInput
    orderBy?: AgentMemoryOrderByWithAggregationInput | AgentMemoryOrderByWithAggregationInput[]
    by: AgentMemoryScalarFieldEnum[] | AgentMemoryScalarFieldEnum
    having?: AgentMemoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentMemoryCountAggregateInputType | true
    _avg?: AgentMemoryAvgAggregateInputType
    _sum?: AgentMemorySumAggregateInputType
    _min?: AgentMemoryMinAggregateInputType
    _max?: AgentMemoryMaxAggregateInputType
  }

  export type AgentMemoryGroupByOutputType = {
    id: string
    agentId: string
    key: string
    value: string
    category: $Enums.MemoryCategory
    embedding: number[]
    source: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AgentMemoryCountAggregateOutputType | null
    _avg: AgentMemoryAvgAggregateOutputType | null
    _sum: AgentMemorySumAggregateOutputType | null
    _min: AgentMemoryMinAggregateOutputType | null
    _max: AgentMemoryMaxAggregateOutputType | null
  }

  type GetAgentMemoryGroupByPayload<T extends AgentMemoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentMemoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentMemoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentMemoryGroupByOutputType[P]>
            : GetScalarType<T[P], AgentMemoryGroupByOutputType[P]>
        }
      >
    >


  export type AgentMemorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    embedding?: boolean
    source?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentMemory"]>

  export type AgentMemorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    embedding?: boolean
    source?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentMemory"]>

  export type AgentMemorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    embedding?: boolean
    source?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentMemory"]>

  export type AgentMemorySelectScalar = {
    id?: boolean
    agentId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    embedding?: boolean
    source?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentMemoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "key" | "value" | "category" | "embedding" | "source" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["agentMemory"]>
  export type AgentMemoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentMemoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentMemoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentMemoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentMemory"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      key: string
      value: string
      category: $Enums.MemoryCategory
      embedding: number[]
      source: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentMemory"]>
    composites: {}
  }

  type AgentMemoryGetPayload<S extends boolean | null | undefined | AgentMemoryDefaultArgs> = $Result.GetResult<Prisma.$AgentMemoryPayload, S>

  type AgentMemoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentMemoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentMemoryCountAggregateInputType | true
    }

  export interface AgentMemoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentMemory'], meta: { name: 'AgentMemory' } }
    /**
     * Find zero or one AgentMemory that matches the filter.
     * @param {AgentMemoryFindUniqueArgs} args - Arguments to find a AgentMemory
     * @example
     * // Get one AgentMemory
     * const agentMemory = await prisma.agentMemory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentMemoryFindUniqueArgs>(args: SelectSubset<T, AgentMemoryFindUniqueArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentMemory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentMemoryFindUniqueOrThrowArgs} args - Arguments to find a AgentMemory
     * @example
     * // Get one AgentMemory
     * const agentMemory = await prisma.agentMemory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentMemoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentMemoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentMemory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryFindFirstArgs} args - Arguments to find a AgentMemory
     * @example
     * // Get one AgentMemory
     * const agentMemory = await prisma.agentMemory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentMemoryFindFirstArgs>(args?: SelectSubset<T, AgentMemoryFindFirstArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentMemory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryFindFirstOrThrowArgs} args - Arguments to find a AgentMemory
     * @example
     * // Get one AgentMemory
     * const agentMemory = await prisma.agentMemory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentMemoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentMemoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentMemories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentMemories
     * const agentMemories = await prisma.agentMemory.findMany()
     * 
     * // Get first 10 AgentMemories
     * const agentMemories = await prisma.agentMemory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentMemoryWithIdOnly = await prisma.agentMemory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentMemoryFindManyArgs>(args?: SelectSubset<T, AgentMemoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentMemory.
     * @param {AgentMemoryCreateArgs} args - Arguments to create a AgentMemory.
     * @example
     * // Create one AgentMemory
     * const AgentMemory = await prisma.agentMemory.create({
     *   data: {
     *     // ... data to create a AgentMemory
     *   }
     * })
     * 
     */
    create<T extends AgentMemoryCreateArgs>(args: SelectSubset<T, AgentMemoryCreateArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentMemories.
     * @param {AgentMemoryCreateManyArgs} args - Arguments to create many AgentMemories.
     * @example
     * // Create many AgentMemories
     * const agentMemory = await prisma.agentMemory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentMemoryCreateManyArgs>(args?: SelectSubset<T, AgentMemoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentMemories and returns the data saved in the database.
     * @param {AgentMemoryCreateManyAndReturnArgs} args - Arguments to create many AgentMemories.
     * @example
     * // Create many AgentMemories
     * const agentMemory = await prisma.agentMemory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentMemories and only return the `id`
     * const agentMemoryWithIdOnly = await prisma.agentMemory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentMemoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentMemoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentMemory.
     * @param {AgentMemoryDeleteArgs} args - Arguments to delete one AgentMemory.
     * @example
     * // Delete one AgentMemory
     * const AgentMemory = await prisma.agentMemory.delete({
     *   where: {
     *     // ... filter to delete one AgentMemory
     *   }
     * })
     * 
     */
    delete<T extends AgentMemoryDeleteArgs>(args: SelectSubset<T, AgentMemoryDeleteArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentMemory.
     * @param {AgentMemoryUpdateArgs} args - Arguments to update one AgentMemory.
     * @example
     * // Update one AgentMemory
     * const agentMemory = await prisma.agentMemory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentMemoryUpdateArgs>(args: SelectSubset<T, AgentMemoryUpdateArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentMemories.
     * @param {AgentMemoryDeleteManyArgs} args - Arguments to filter AgentMemories to delete.
     * @example
     * // Delete a few AgentMemories
     * const { count } = await prisma.agentMemory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentMemoryDeleteManyArgs>(args?: SelectSubset<T, AgentMemoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentMemories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentMemories
     * const agentMemory = await prisma.agentMemory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentMemoryUpdateManyArgs>(args: SelectSubset<T, AgentMemoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentMemories and returns the data updated in the database.
     * @param {AgentMemoryUpdateManyAndReturnArgs} args - Arguments to update many AgentMemories.
     * @example
     * // Update many AgentMemories
     * const agentMemory = await prisma.agentMemory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentMemories and only return the `id`
     * const agentMemoryWithIdOnly = await prisma.agentMemory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentMemoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentMemoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentMemory.
     * @param {AgentMemoryUpsertArgs} args - Arguments to update or create a AgentMemory.
     * @example
     * // Update or create a AgentMemory
     * const agentMemory = await prisma.agentMemory.upsert({
     *   create: {
     *     // ... data to create a AgentMemory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentMemory we want to update
     *   }
     * })
     */
    upsert<T extends AgentMemoryUpsertArgs>(args: SelectSubset<T, AgentMemoryUpsertArgs<ExtArgs>>): Prisma__AgentMemoryClient<$Result.GetResult<Prisma.$AgentMemoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentMemories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryCountArgs} args - Arguments to filter AgentMemories to count.
     * @example
     * // Count the number of AgentMemories
     * const count = await prisma.agentMemory.count({
     *   where: {
     *     // ... the filter for the AgentMemories we want to count
     *   }
     * })
    **/
    count<T extends AgentMemoryCountArgs>(
      args?: Subset<T, AgentMemoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentMemoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentMemory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentMemoryAggregateArgs>(args: Subset<T, AgentMemoryAggregateArgs>): Prisma.PrismaPromise<GetAgentMemoryAggregateType<T>>

    /**
     * Group by AgentMemory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMemoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentMemoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentMemoryGroupByArgs['orderBy'] }
        : { orderBy?: AgentMemoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentMemoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentMemoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentMemory model
   */
  readonly fields: AgentMemoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentMemory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentMemoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentMemory model
   */
  interface AgentMemoryFieldRefs {
    readonly id: FieldRef<"AgentMemory", 'String'>
    readonly agentId: FieldRef<"AgentMemory", 'String'>
    readonly key: FieldRef<"AgentMemory", 'String'>
    readonly value: FieldRef<"AgentMemory", 'String'>
    readonly category: FieldRef<"AgentMemory", 'MemoryCategory'>
    readonly embedding: FieldRef<"AgentMemory", 'Float[]'>
    readonly source: FieldRef<"AgentMemory", 'String'>
    readonly expiresAt: FieldRef<"AgentMemory", 'DateTime'>
    readonly createdAt: FieldRef<"AgentMemory", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentMemory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentMemory findUnique
   */
  export type AgentMemoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * Filter, which AgentMemory to fetch.
     */
    where: AgentMemoryWhereUniqueInput
  }

  /**
   * AgentMemory findUniqueOrThrow
   */
  export type AgentMemoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * Filter, which AgentMemory to fetch.
     */
    where: AgentMemoryWhereUniqueInput
  }

  /**
   * AgentMemory findFirst
   */
  export type AgentMemoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * Filter, which AgentMemory to fetch.
     */
    where?: AgentMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMemories to fetch.
     */
    orderBy?: AgentMemoryOrderByWithRelationInput | AgentMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentMemories.
     */
    cursor?: AgentMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMemories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentMemories.
     */
    distinct?: AgentMemoryScalarFieldEnum | AgentMemoryScalarFieldEnum[]
  }

  /**
   * AgentMemory findFirstOrThrow
   */
  export type AgentMemoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * Filter, which AgentMemory to fetch.
     */
    where?: AgentMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMemories to fetch.
     */
    orderBy?: AgentMemoryOrderByWithRelationInput | AgentMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentMemories.
     */
    cursor?: AgentMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMemories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentMemories.
     */
    distinct?: AgentMemoryScalarFieldEnum | AgentMemoryScalarFieldEnum[]
  }

  /**
   * AgentMemory findMany
   */
  export type AgentMemoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * Filter, which AgentMemories to fetch.
     */
    where?: AgentMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMemories to fetch.
     */
    orderBy?: AgentMemoryOrderByWithRelationInput | AgentMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentMemories.
     */
    cursor?: AgentMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMemories.
     */
    skip?: number
    distinct?: AgentMemoryScalarFieldEnum | AgentMemoryScalarFieldEnum[]
  }

  /**
   * AgentMemory create
   */
  export type AgentMemoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentMemory.
     */
    data: XOR<AgentMemoryCreateInput, AgentMemoryUncheckedCreateInput>
  }

  /**
   * AgentMemory createMany
   */
  export type AgentMemoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentMemories.
     */
    data: AgentMemoryCreateManyInput | AgentMemoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentMemory createManyAndReturn
   */
  export type AgentMemoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * The data used to create many AgentMemories.
     */
    data: AgentMemoryCreateManyInput | AgentMemoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentMemory update
   */
  export type AgentMemoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentMemory.
     */
    data: XOR<AgentMemoryUpdateInput, AgentMemoryUncheckedUpdateInput>
    /**
     * Choose, which AgentMemory to update.
     */
    where: AgentMemoryWhereUniqueInput
  }

  /**
   * AgentMemory updateMany
   */
  export type AgentMemoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentMemories.
     */
    data: XOR<AgentMemoryUpdateManyMutationInput, AgentMemoryUncheckedUpdateManyInput>
    /**
     * Filter which AgentMemories to update
     */
    where?: AgentMemoryWhereInput
    /**
     * Limit how many AgentMemories to update.
     */
    limit?: number
  }

  /**
   * AgentMemory updateManyAndReturn
   */
  export type AgentMemoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * The data used to update AgentMemories.
     */
    data: XOR<AgentMemoryUpdateManyMutationInput, AgentMemoryUncheckedUpdateManyInput>
    /**
     * Filter which AgentMemories to update
     */
    where?: AgentMemoryWhereInput
    /**
     * Limit how many AgentMemories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentMemory upsert
   */
  export type AgentMemoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentMemory to update in case it exists.
     */
    where: AgentMemoryWhereUniqueInput
    /**
     * In case the AgentMemory found by the `where` argument doesn't exist, create a new AgentMemory with this data.
     */
    create: XOR<AgentMemoryCreateInput, AgentMemoryUncheckedCreateInput>
    /**
     * In case the AgentMemory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentMemoryUpdateInput, AgentMemoryUncheckedUpdateInput>
  }

  /**
   * AgentMemory delete
   */
  export type AgentMemoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
    /**
     * Filter which AgentMemory to delete.
     */
    where: AgentMemoryWhereUniqueInput
  }

  /**
   * AgentMemory deleteMany
   */
  export type AgentMemoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentMemories to delete
     */
    where?: AgentMemoryWhereInput
    /**
     * Limit how many AgentMemories to delete.
     */
    limit?: number
  }

  /**
   * AgentMemory without action
   */
  export type AgentMemoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMemory
     */
    select?: AgentMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMemory
     */
    omit?: AgentMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMemoryInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeDocument
   */

  export type AggregateKnowledgeDocument = {
    _count: KnowledgeDocumentCountAggregateOutputType | null
    _avg: KnowledgeDocumentAvgAggregateOutputType | null
    _sum: KnowledgeDocumentSumAggregateOutputType | null
    _min: KnowledgeDocumentMinAggregateOutputType | null
    _max: KnowledgeDocumentMaxAggregateOutputType | null
  }

  export type KnowledgeDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type KnowledgeDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type KnowledgeDocumentMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    content: string | null
    source: string | null
    mimeType: string | null
    fileSize: number | null
    sourceType: $Enums.KnowledgeSourceType | null
    externalId: string | null
    externalUrl: string | null
    syncStatus: $Enums.KnowledgeSyncStatus | null
    lastSyncedAt: Date | null
    syncError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeDocumentMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    content: string | null
    source: string | null
    mimeType: string | null
    fileSize: number | null
    sourceType: $Enums.KnowledgeSourceType | null
    externalId: string | null
    externalUrl: string | null
    syncStatus: $Enums.KnowledgeSyncStatus | null
    lastSyncedAt: Date | null
    syncError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeDocumentCountAggregateOutputType = {
    id: number
    agentId: number
    title: number
    content: number
    source: number
    mimeType: number
    fileSize: number
    sourceType: number
    externalId: number
    externalUrl: number
    syncStatus: number
    lastSyncedAt: number
    syncError: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type KnowledgeDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type KnowledgeDocumentMinAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    content?: true
    source?: true
    mimeType?: true
    fileSize?: true
    sourceType?: true
    externalId?: true
    externalUrl?: true
    syncStatus?: true
    lastSyncedAt?: true
    syncError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeDocumentMaxAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    content?: true
    source?: true
    mimeType?: true
    fileSize?: true
    sourceType?: true
    externalId?: true
    externalUrl?: true
    syncStatus?: true
    lastSyncedAt?: true
    syncError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeDocumentCountAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    content?: true
    source?: true
    mimeType?: true
    fileSize?: true
    sourceType?: true
    externalId?: true
    externalUrl?: true
    syncStatus?: true
    lastSyncedAt?: true
    syncError?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeDocument to aggregate.
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeDocuments to fetch.
     */
    orderBy?: KnowledgeDocumentOrderByWithRelationInput | KnowledgeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeDocuments
    **/
    _count?: true | KnowledgeDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeDocumentMaxAggregateInputType
  }

  export type GetKnowledgeDocumentAggregateType<T extends KnowledgeDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeDocument[P]>
      : GetScalarType<T[P], AggregateKnowledgeDocument[P]>
  }




  export type KnowledgeDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeDocumentWhereInput
    orderBy?: KnowledgeDocumentOrderByWithAggregationInput | KnowledgeDocumentOrderByWithAggregationInput[]
    by: KnowledgeDocumentScalarFieldEnum[] | KnowledgeDocumentScalarFieldEnum
    having?: KnowledgeDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeDocumentCountAggregateInputType | true
    _avg?: KnowledgeDocumentAvgAggregateInputType
    _sum?: KnowledgeDocumentSumAggregateInputType
    _min?: KnowledgeDocumentMinAggregateInputType
    _max?: KnowledgeDocumentMaxAggregateInputType
  }

  export type KnowledgeDocumentGroupByOutputType = {
    id: string
    agentId: string
    title: string
    content: string
    source: string | null
    mimeType: string
    fileSize: number | null
    sourceType: $Enums.KnowledgeSourceType
    externalId: string | null
    externalUrl: string | null
    syncStatus: $Enums.KnowledgeSyncStatus
    lastSyncedAt: Date | null
    syncError: string | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeDocumentCountAggregateOutputType | null
    _avg: KnowledgeDocumentAvgAggregateOutputType | null
    _sum: KnowledgeDocumentSumAggregateOutputType | null
    _min: KnowledgeDocumentMinAggregateOutputType | null
    _max: KnowledgeDocumentMaxAggregateOutputType | null
  }

  type GetKnowledgeDocumentGroupByPayload<T extends KnowledgeDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeDocumentGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    mimeType?: boolean
    fileSize?: boolean
    sourceType?: boolean
    externalId?: boolean
    externalUrl?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    chunks?: boolean | KnowledgeDocument$chunksArgs<ExtArgs>
    _count?: boolean | KnowledgeDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeDocument"]>

  export type KnowledgeDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    mimeType?: boolean
    fileSize?: boolean
    sourceType?: boolean
    externalId?: boolean
    externalUrl?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeDocument"]>

  export type KnowledgeDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    mimeType?: boolean
    fileSize?: boolean
    sourceType?: boolean
    externalId?: boolean
    externalUrl?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeDocument"]>

  export type KnowledgeDocumentSelectScalar = {
    id?: boolean
    agentId?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    mimeType?: boolean
    fileSize?: boolean
    sourceType?: boolean
    externalId?: boolean
    externalUrl?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "title" | "content" | "source" | "mimeType" | "fileSize" | "sourceType" | "externalId" | "externalUrl" | "syncStatus" | "lastSyncedAt" | "syncError" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeDocument"]>
  export type KnowledgeDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    chunks?: boolean | KnowledgeDocument$chunksArgs<ExtArgs>
    _count?: boolean | KnowledgeDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type KnowledgeDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $KnowledgeDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeDocument"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      chunks: Prisma.$KnowledgeChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      title: string
      content: string
      source: string | null
      mimeType: string
      fileSize: number | null
      sourceType: $Enums.KnowledgeSourceType
      externalId: string | null
      externalUrl: string | null
      syncStatus: $Enums.KnowledgeSyncStatus
      lastSyncedAt: Date | null
      syncError: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeDocument"]>
    composites: {}
  }

  type KnowledgeDocumentGetPayload<S extends boolean | null | undefined | KnowledgeDocumentDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeDocumentPayload, S>

  type KnowledgeDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeDocumentCountAggregateInputType | true
    }

  export interface KnowledgeDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeDocument'], meta: { name: 'KnowledgeDocument' } }
    /**
     * Find zero or one KnowledgeDocument that matches the filter.
     * @param {KnowledgeDocumentFindUniqueArgs} args - Arguments to find a KnowledgeDocument
     * @example
     * // Get one KnowledgeDocument
     * const knowledgeDocument = await prisma.knowledgeDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeDocumentFindUniqueArgs>(args: SelectSubset<T, KnowledgeDocumentFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeDocumentFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeDocument
     * @example
     * // Get one KnowledgeDocument
     * const knowledgeDocument = await prisma.knowledgeDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentFindFirstArgs} args - Arguments to find a KnowledgeDocument
     * @example
     * // Get one KnowledgeDocument
     * const knowledgeDocument = await prisma.knowledgeDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeDocumentFindFirstArgs>(args?: SelectSubset<T, KnowledgeDocumentFindFirstArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentFindFirstOrThrowArgs} args - Arguments to find a KnowledgeDocument
     * @example
     * // Get one KnowledgeDocument
     * const knowledgeDocument = await prisma.knowledgeDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeDocuments
     * const knowledgeDocuments = await prisma.knowledgeDocument.findMany()
     * 
     * // Get first 10 KnowledgeDocuments
     * const knowledgeDocuments = await prisma.knowledgeDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeDocumentWithIdOnly = await prisma.knowledgeDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeDocumentFindManyArgs>(args?: SelectSubset<T, KnowledgeDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeDocument.
     * @param {KnowledgeDocumentCreateArgs} args - Arguments to create a KnowledgeDocument.
     * @example
     * // Create one KnowledgeDocument
     * const KnowledgeDocument = await prisma.knowledgeDocument.create({
     *   data: {
     *     // ... data to create a KnowledgeDocument
     *   }
     * })
     * 
     */
    create<T extends KnowledgeDocumentCreateArgs>(args: SelectSubset<T, KnowledgeDocumentCreateArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeDocuments.
     * @param {KnowledgeDocumentCreateManyArgs} args - Arguments to create many KnowledgeDocuments.
     * @example
     * // Create many KnowledgeDocuments
     * const knowledgeDocument = await prisma.knowledgeDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeDocumentCreateManyArgs>(args?: SelectSubset<T, KnowledgeDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeDocuments and returns the data saved in the database.
     * @param {KnowledgeDocumentCreateManyAndReturnArgs} args - Arguments to create many KnowledgeDocuments.
     * @example
     * // Create many KnowledgeDocuments
     * const knowledgeDocument = await prisma.knowledgeDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeDocuments and only return the `id`
     * const knowledgeDocumentWithIdOnly = await prisma.knowledgeDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeDocument.
     * @param {KnowledgeDocumentDeleteArgs} args - Arguments to delete one KnowledgeDocument.
     * @example
     * // Delete one KnowledgeDocument
     * const KnowledgeDocument = await prisma.knowledgeDocument.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeDocument
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeDocumentDeleteArgs>(args: SelectSubset<T, KnowledgeDocumentDeleteArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeDocument.
     * @param {KnowledgeDocumentUpdateArgs} args - Arguments to update one KnowledgeDocument.
     * @example
     * // Update one KnowledgeDocument
     * const knowledgeDocument = await prisma.knowledgeDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeDocumentUpdateArgs>(args: SelectSubset<T, KnowledgeDocumentUpdateArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeDocuments.
     * @param {KnowledgeDocumentDeleteManyArgs} args - Arguments to filter KnowledgeDocuments to delete.
     * @example
     * // Delete a few KnowledgeDocuments
     * const { count } = await prisma.knowledgeDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeDocumentDeleteManyArgs>(args?: SelectSubset<T, KnowledgeDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeDocuments
     * const knowledgeDocument = await prisma.knowledgeDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeDocumentUpdateManyArgs>(args: SelectSubset<T, KnowledgeDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeDocuments and returns the data updated in the database.
     * @param {KnowledgeDocumentUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeDocuments.
     * @example
     * // Update many KnowledgeDocuments
     * const knowledgeDocument = await prisma.knowledgeDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeDocuments and only return the `id`
     * const knowledgeDocumentWithIdOnly = await prisma.knowledgeDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeDocument.
     * @param {KnowledgeDocumentUpsertArgs} args - Arguments to update or create a KnowledgeDocument.
     * @example
     * // Update or create a KnowledgeDocument
     * const knowledgeDocument = await prisma.knowledgeDocument.upsert({
     *   create: {
     *     // ... data to create a KnowledgeDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeDocument we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeDocumentUpsertArgs>(args: SelectSubset<T, KnowledgeDocumentUpsertArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentCountArgs} args - Arguments to filter KnowledgeDocuments to count.
     * @example
     * // Count the number of KnowledgeDocuments
     * const count = await prisma.knowledgeDocument.count({
     *   where: {
     *     // ... the filter for the KnowledgeDocuments we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeDocumentCountArgs>(
      args?: Subset<T, KnowledgeDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeDocumentAggregateArgs>(args: Subset<T, KnowledgeDocumentAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeDocumentAggregateType<T>>

    /**
     * Group by KnowledgeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeDocumentGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeDocument model
   */
  readonly fields: KnowledgeDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chunks<T extends KnowledgeDocument$chunksArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeDocument$chunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeDocument model
   */
  interface KnowledgeDocumentFieldRefs {
    readonly id: FieldRef<"KnowledgeDocument", 'String'>
    readonly agentId: FieldRef<"KnowledgeDocument", 'String'>
    readonly title: FieldRef<"KnowledgeDocument", 'String'>
    readonly content: FieldRef<"KnowledgeDocument", 'String'>
    readonly source: FieldRef<"KnowledgeDocument", 'String'>
    readonly mimeType: FieldRef<"KnowledgeDocument", 'String'>
    readonly fileSize: FieldRef<"KnowledgeDocument", 'Int'>
    readonly sourceType: FieldRef<"KnowledgeDocument", 'KnowledgeSourceType'>
    readonly externalId: FieldRef<"KnowledgeDocument", 'String'>
    readonly externalUrl: FieldRef<"KnowledgeDocument", 'String'>
    readonly syncStatus: FieldRef<"KnowledgeDocument", 'KnowledgeSyncStatus'>
    readonly lastSyncedAt: FieldRef<"KnowledgeDocument", 'DateTime'>
    readonly syncError: FieldRef<"KnowledgeDocument", 'String'>
    readonly createdAt: FieldRef<"KnowledgeDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeDocument findUnique
   */
  export type KnowledgeDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeDocument to fetch.
     */
    where: KnowledgeDocumentWhereUniqueInput
  }

  /**
   * KnowledgeDocument findUniqueOrThrow
   */
  export type KnowledgeDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeDocument to fetch.
     */
    where: KnowledgeDocumentWhereUniqueInput
  }

  /**
   * KnowledgeDocument findFirst
   */
  export type KnowledgeDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeDocument to fetch.
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeDocuments to fetch.
     */
    orderBy?: KnowledgeDocumentOrderByWithRelationInput | KnowledgeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeDocuments.
     */
    cursor?: KnowledgeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeDocuments.
     */
    distinct?: KnowledgeDocumentScalarFieldEnum | KnowledgeDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeDocument findFirstOrThrow
   */
  export type KnowledgeDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeDocument to fetch.
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeDocuments to fetch.
     */
    orderBy?: KnowledgeDocumentOrderByWithRelationInput | KnowledgeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeDocuments.
     */
    cursor?: KnowledgeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeDocuments.
     */
    distinct?: KnowledgeDocumentScalarFieldEnum | KnowledgeDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeDocument findMany
   */
  export type KnowledgeDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeDocuments to fetch.
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeDocuments to fetch.
     */
    orderBy?: KnowledgeDocumentOrderByWithRelationInput | KnowledgeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeDocuments.
     */
    cursor?: KnowledgeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeDocuments.
     */
    skip?: number
    distinct?: KnowledgeDocumentScalarFieldEnum | KnowledgeDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeDocument create
   */
  export type KnowledgeDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeDocument.
     */
    data: XOR<KnowledgeDocumentCreateInput, KnowledgeDocumentUncheckedCreateInput>
  }

  /**
   * KnowledgeDocument createMany
   */
  export type KnowledgeDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeDocuments.
     */
    data: KnowledgeDocumentCreateManyInput | KnowledgeDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeDocument createManyAndReturn
   */
  export type KnowledgeDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeDocuments.
     */
    data: KnowledgeDocumentCreateManyInput | KnowledgeDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeDocument update
   */
  export type KnowledgeDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeDocument.
     */
    data: XOR<KnowledgeDocumentUpdateInput, KnowledgeDocumentUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeDocument to update.
     */
    where: KnowledgeDocumentWhereUniqueInput
  }

  /**
   * KnowledgeDocument updateMany
   */
  export type KnowledgeDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeDocuments.
     */
    data: XOR<KnowledgeDocumentUpdateManyMutationInput, KnowledgeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeDocuments to update
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * Limit how many KnowledgeDocuments to update.
     */
    limit?: number
  }

  /**
   * KnowledgeDocument updateManyAndReturn
   */
  export type KnowledgeDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeDocuments.
     */
    data: XOR<KnowledgeDocumentUpdateManyMutationInput, KnowledgeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeDocuments to update
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * Limit how many KnowledgeDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeDocument upsert
   */
  export type KnowledgeDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeDocument to update in case it exists.
     */
    where: KnowledgeDocumentWhereUniqueInput
    /**
     * In case the KnowledgeDocument found by the `where` argument doesn't exist, create a new KnowledgeDocument with this data.
     */
    create: XOR<KnowledgeDocumentCreateInput, KnowledgeDocumentUncheckedCreateInput>
    /**
     * In case the KnowledgeDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeDocumentUpdateInput, KnowledgeDocumentUncheckedUpdateInput>
  }

  /**
   * KnowledgeDocument delete
   */
  export type KnowledgeDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeDocument to delete.
     */
    where: KnowledgeDocumentWhereUniqueInput
  }

  /**
   * KnowledgeDocument deleteMany
   */
  export type KnowledgeDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeDocuments to delete
     */
    where?: KnowledgeDocumentWhereInput
    /**
     * Limit how many KnowledgeDocuments to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeDocument.chunks
   */
  export type KnowledgeDocument$chunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    where?: KnowledgeChunkWhereInput
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    cursor?: KnowledgeChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeDocument without action
   */
  export type KnowledgeDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeDocument
     */
    select?: KnowledgeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeDocument
     */
    omit?: KnowledgeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeDocumentInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeChunk
   */

  export type AggregateKnowledgeChunk = {
    _count: KnowledgeChunkCountAggregateOutputType | null
    _avg: KnowledgeChunkAvgAggregateOutputType | null
    _sum: KnowledgeChunkSumAggregateOutputType | null
    _min: KnowledgeChunkMinAggregateOutputType | null
    _max: KnowledgeChunkMaxAggregateOutputType | null
  }

  export type KnowledgeChunkAvgAggregateOutputType = {
    embedding: number | null
    position: number | null
    pageNumber: number | null
  }

  export type KnowledgeChunkSumAggregateOutputType = {
    embedding: number[]
    position: number | null
    pageNumber: number | null
  }

  export type KnowledgeChunkMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    content: string | null
    position: number | null
    pageNumber: number | null
    heading: string | null
    createdAt: Date | null
  }

  export type KnowledgeChunkMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    content: string | null
    position: number | null
    pageNumber: number | null
    heading: string | null
    createdAt: Date | null
  }

  export type KnowledgeChunkCountAggregateOutputType = {
    id: number
    documentId: number
    content: number
    embedding: number
    position: number
    pageNumber: number
    heading: number
    createdAt: number
    _all: number
  }


  export type KnowledgeChunkAvgAggregateInputType = {
    embedding?: true
    position?: true
    pageNumber?: true
  }

  export type KnowledgeChunkSumAggregateInputType = {
    embedding?: true
    position?: true
    pageNumber?: true
  }

  export type KnowledgeChunkMinAggregateInputType = {
    id?: true
    documentId?: true
    content?: true
    position?: true
    pageNumber?: true
    heading?: true
    createdAt?: true
  }

  export type KnowledgeChunkMaxAggregateInputType = {
    id?: true
    documentId?: true
    content?: true
    position?: true
    pageNumber?: true
    heading?: true
    createdAt?: true
  }

  export type KnowledgeChunkCountAggregateInputType = {
    id?: true
    documentId?: true
    content?: true
    embedding?: true
    position?: true
    pageNumber?: true
    heading?: true
    createdAt?: true
    _all?: true
  }

  export type KnowledgeChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeChunk to aggregate.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeChunks
    **/
    _count?: true | KnowledgeChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeChunkMaxAggregateInputType
  }

  export type GetKnowledgeChunkAggregateType<T extends KnowledgeChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeChunk[P]>
      : GetScalarType<T[P], AggregateKnowledgeChunk[P]>
  }




  export type KnowledgeChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeChunkWhereInput
    orderBy?: KnowledgeChunkOrderByWithAggregationInput | KnowledgeChunkOrderByWithAggregationInput[]
    by: KnowledgeChunkScalarFieldEnum[] | KnowledgeChunkScalarFieldEnum
    having?: KnowledgeChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeChunkCountAggregateInputType | true
    _avg?: KnowledgeChunkAvgAggregateInputType
    _sum?: KnowledgeChunkSumAggregateInputType
    _min?: KnowledgeChunkMinAggregateInputType
    _max?: KnowledgeChunkMaxAggregateInputType
  }

  export type KnowledgeChunkGroupByOutputType = {
    id: string
    documentId: string
    content: string
    embedding: number[]
    position: number
    pageNumber: number | null
    heading: string | null
    createdAt: Date
    _count: KnowledgeChunkCountAggregateOutputType | null
    _avg: KnowledgeChunkAvgAggregateOutputType | null
    _sum: KnowledgeChunkSumAggregateOutputType | null
    _min: KnowledgeChunkMinAggregateOutputType | null
    _max: KnowledgeChunkMaxAggregateOutputType | null
  }

  type GetKnowledgeChunkGroupByPayload<T extends KnowledgeChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeChunkGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeChunkGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    content?: boolean
    embedding?: boolean
    position?: boolean
    pageNumber?: boolean
    heading?: boolean
    createdAt?: boolean
    document?: boolean | KnowledgeDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeChunk"]>

  export type KnowledgeChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    content?: boolean
    embedding?: boolean
    position?: boolean
    pageNumber?: boolean
    heading?: boolean
    createdAt?: boolean
    document?: boolean | KnowledgeDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeChunk"]>

  export type KnowledgeChunkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    content?: boolean
    embedding?: boolean
    position?: boolean
    pageNumber?: boolean
    heading?: boolean
    createdAt?: boolean
    document?: boolean | KnowledgeDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeChunk"]>

  export type KnowledgeChunkSelectScalar = {
    id?: boolean
    documentId?: boolean
    content?: boolean
    embedding?: boolean
    position?: boolean
    pageNumber?: boolean
    heading?: boolean
    createdAt?: boolean
  }

  export type KnowledgeChunkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "content" | "embedding" | "position" | "pageNumber" | "heading" | "createdAt", ExtArgs["result"]["knowledgeChunk"]>
  export type KnowledgeChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | KnowledgeDocumentDefaultArgs<ExtArgs>
  }
  export type KnowledgeChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | KnowledgeDocumentDefaultArgs<ExtArgs>
  }
  export type KnowledgeChunkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | KnowledgeDocumentDefaultArgs<ExtArgs>
  }

  export type $KnowledgeChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeChunk"
    objects: {
      document: Prisma.$KnowledgeDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      content: string
      embedding: number[]
      position: number
      pageNumber: number | null
      heading: string | null
      createdAt: Date
    }, ExtArgs["result"]["knowledgeChunk"]>
    composites: {}
  }

  type KnowledgeChunkGetPayload<S extends boolean | null | undefined | KnowledgeChunkDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeChunkPayload, S>

  type KnowledgeChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeChunkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeChunkCountAggregateInputType | true
    }

  export interface KnowledgeChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeChunk'], meta: { name: 'KnowledgeChunk' } }
    /**
     * Find zero or one KnowledgeChunk that matches the filter.
     * @param {KnowledgeChunkFindUniqueArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeChunkFindUniqueArgs>(args: SelectSubset<T, KnowledgeChunkFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeChunk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeChunkFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkFindFirstArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeChunkFindFirstArgs>(args?: SelectSubset<T, KnowledgeChunkFindFirstArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkFindFirstOrThrowArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeChunks
     * const knowledgeChunks = await prisma.knowledgeChunk.findMany()
     * 
     * // Get first 10 KnowledgeChunks
     * const knowledgeChunks = await prisma.knowledgeChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeChunkWithIdOnly = await prisma.knowledgeChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeChunkFindManyArgs>(args?: SelectSubset<T, KnowledgeChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeChunk.
     * @param {KnowledgeChunkCreateArgs} args - Arguments to create a KnowledgeChunk.
     * @example
     * // Create one KnowledgeChunk
     * const KnowledgeChunk = await prisma.knowledgeChunk.create({
     *   data: {
     *     // ... data to create a KnowledgeChunk
     *   }
     * })
     * 
     */
    create<T extends KnowledgeChunkCreateArgs>(args: SelectSubset<T, KnowledgeChunkCreateArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeChunks.
     * @param {KnowledgeChunkCreateManyArgs} args - Arguments to create many KnowledgeChunks.
     * @example
     * // Create many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeChunkCreateManyArgs>(args?: SelectSubset<T, KnowledgeChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeChunks and returns the data saved in the database.
     * @param {KnowledgeChunkCreateManyAndReturnArgs} args - Arguments to create many KnowledgeChunks.
     * @example
     * // Create many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeChunks and only return the `id`
     * const knowledgeChunkWithIdOnly = await prisma.knowledgeChunk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeChunk.
     * @param {KnowledgeChunkDeleteArgs} args - Arguments to delete one KnowledgeChunk.
     * @example
     * // Delete one KnowledgeChunk
     * const KnowledgeChunk = await prisma.knowledgeChunk.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeChunk
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeChunkDeleteArgs>(args: SelectSubset<T, KnowledgeChunkDeleteArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeChunk.
     * @param {KnowledgeChunkUpdateArgs} args - Arguments to update one KnowledgeChunk.
     * @example
     * // Update one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeChunkUpdateArgs>(args: SelectSubset<T, KnowledgeChunkUpdateArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeChunks.
     * @param {KnowledgeChunkDeleteManyArgs} args - Arguments to filter KnowledgeChunks to delete.
     * @example
     * // Delete a few KnowledgeChunks
     * const { count } = await prisma.knowledgeChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeChunkDeleteManyArgs>(args?: SelectSubset<T, KnowledgeChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeChunkUpdateManyArgs>(args: SelectSubset<T, KnowledgeChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeChunks and returns the data updated in the database.
     * @param {KnowledgeChunkUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeChunks.
     * @example
     * // Update many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeChunks and only return the `id`
     * const knowledgeChunkWithIdOnly = await prisma.knowledgeChunk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeChunkUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeChunkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeChunk.
     * @param {KnowledgeChunkUpsertArgs} args - Arguments to update or create a KnowledgeChunk.
     * @example
     * // Update or create a KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.upsert({
     *   create: {
     *     // ... data to create a KnowledgeChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeChunk we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeChunkUpsertArgs>(args: SelectSubset<T, KnowledgeChunkUpsertArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkCountArgs} args - Arguments to filter KnowledgeChunks to count.
     * @example
     * // Count the number of KnowledgeChunks
     * const count = await prisma.knowledgeChunk.count({
     *   where: {
     *     // ... the filter for the KnowledgeChunks we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeChunkCountArgs>(
      args?: Subset<T, KnowledgeChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeChunkAggregateArgs>(args: Subset<T, KnowledgeChunkAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeChunkAggregateType<T>>

    /**
     * Group by KnowledgeChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeChunkGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeChunk model
   */
  readonly fields: KnowledgeChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends KnowledgeDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeDocumentDefaultArgs<ExtArgs>>): Prisma__KnowledgeDocumentClient<$Result.GetResult<Prisma.$KnowledgeDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeChunk model
   */
  interface KnowledgeChunkFieldRefs {
    readonly id: FieldRef<"KnowledgeChunk", 'String'>
    readonly documentId: FieldRef<"KnowledgeChunk", 'String'>
    readonly content: FieldRef<"KnowledgeChunk", 'String'>
    readonly embedding: FieldRef<"KnowledgeChunk", 'Float[]'>
    readonly position: FieldRef<"KnowledgeChunk", 'Int'>
    readonly pageNumber: FieldRef<"KnowledgeChunk", 'Int'>
    readonly heading: FieldRef<"KnowledgeChunk", 'String'>
    readonly createdAt: FieldRef<"KnowledgeChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeChunk findUnique
   */
  export type KnowledgeChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk findUniqueOrThrow
   */
  export type KnowledgeChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk findFirst
   */
  export type KnowledgeChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeChunks.
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeChunks.
     */
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeChunk findFirstOrThrow
   */
  export type KnowledgeChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeChunks.
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeChunks.
     */
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeChunk findMany
   */
  export type KnowledgeChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunks to fetch.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeChunks.
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeChunk create
   */
  export type KnowledgeChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeChunk.
     */
    data: XOR<KnowledgeChunkCreateInput, KnowledgeChunkUncheckedCreateInput>
  }

  /**
   * KnowledgeChunk createMany
   */
  export type KnowledgeChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeChunks.
     */
    data: KnowledgeChunkCreateManyInput | KnowledgeChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeChunk createManyAndReturn
   */
  export type KnowledgeChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeChunks.
     */
    data: KnowledgeChunkCreateManyInput | KnowledgeChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeChunk update
   */
  export type KnowledgeChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeChunk.
     */
    data: XOR<KnowledgeChunkUpdateInput, KnowledgeChunkUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeChunk to update.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk updateMany
   */
  export type KnowledgeChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeChunks.
     */
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeChunks to update
     */
    where?: KnowledgeChunkWhereInput
    /**
     * Limit how many KnowledgeChunks to update.
     */
    limit?: number
  }

  /**
   * KnowledgeChunk updateManyAndReturn
   */
  export type KnowledgeChunkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeChunks.
     */
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeChunks to update
     */
    where?: KnowledgeChunkWhereInput
    /**
     * Limit how many KnowledgeChunks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeChunk upsert
   */
  export type KnowledgeChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeChunk to update in case it exists.
     */
    where: KnowledgeChunkWhereUniqueInput
    /**
     * In case the KnowledgeChunk found by the `where` argument doesn't exist, create a new KnowledgeChunk with this data.
     */
    create: XOR<KnowledgeChunkCreateInput, KnowledgeChunkUncheckedCreateInput>
    /**
     * In case the KnowledgeChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeChunkUpdateInput, KnowledgeChunkUncheckedUpdateInput>
  }

  /**
   * KnowledgeChunk delete
   */
  export type KnowledgeChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeChunk to delete.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk deleteMany
   */
  export type KnowledgeChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeChunks to delete
     */
    where?: KnowledgeChunkWhereInput
    /**
     * Limit how many KnowledgeChunks to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeChunk without action
   */
  export type KnowledgeChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeSettings
   */

  export type AggregateKnowledgeSettings = {
    _count: KnowledgeSettingsCountAggregateOutputType | null
    _avg: KnowledgeSettingsAvgAggregateOutputType | null
    _sum: KnowledgeSettingsSumAggregateOutputType | null
    _min: KnowledgeSettingsMinAggregateOutputType | null
    _max: KnowledgeSettingsMaxAggregateOutputType | null
  }

  export type KnowledgeSettingsAvgAggregateOutputType = {
    searchFuzziness: number | null
    maxResults: number | null
    refreshInterval: number | null
  }

  export type KnowledgeSettingsSumAggregateOutputType = {
    searchFuzziness: number | null
    maxResults: number | null
    refreshInterval: number | null
  }

  export type KnowledgeSettingsMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    searchFuzziness: number | null
    maxResults: number | null
    autoRefresh: boolean | null
    refreshInterval: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeSettingsMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    searchFuzziness: number | null
    maxResults: number | null
    autoRefresh: boolean | null
    refreshInterval: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeSettingsCountAggregateOutputType = {
    id: number
    agentId: number
    searchFuzziness: number
    maxResults: number
    autoRefresh: number
    refreshInterval: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeSettingsAvgAggregateInputType = {
    searchFuzziness?: true
    maxResults?: true
    refreshInterval?: true
  }

  export type KnowledgeSettingsSumAggregateInputType = {
    searchFuzziness?: true
    maxResults?: true
    refreshInterval?: true
  }

  export type KnowledgeSettingsMinAggregateInputType = {
    id?: true
    agentId?: true
    searchFuzziness?: true
    maxResults?: true
    autoRefresh?: true
    refreshInterval?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeSettingsMaxAggregateInputType = {
    id?: true
    agentId?: true
    searchFuzziness?: true
    maxResults?: true
    autoRefresh?: true
    refreshInterval?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeSettingsCountAggregateInputType = {
    id?: true
    agentId?: true
    searchFuzziness?: true
    maxResults?: true
    autoRefresh?: true
    refreshInterval?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeSettings to aggregate.
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeSettings to fetch.
     */
    orderBy?: KnowledgeSettingsOrderByWithRelationInput | KnowledgeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeSettings
    **/
    _count?: true | KnowledgeSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeSettingsMaxAggregateInputType
  }

  export type GetKnowledgeSettingsAggregateType<T extends KnowledgeSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeSettings[P]>
      : GetScalarType<T[P], AggregateKnowledgeSettings[P]>
  }




  export type KnowledgeSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeSettingsWhereInput
    orderBy?: KnowledgeSettingsOrderByWithAggregationInput | KnowledgeSettingsOrderByWithAggregationInput[]
    by: KnowledgeSettingsScalarFieldEnum[] | KnowledgeSettingsScalarFieldEnum
    having?: KnowledgeSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeSettingsCountAggregateInputType | true
    _avg?: KnowledgeSettingsAvgAggregateInputType
    _sum?: KnowledgeSettingsSumAggregateInputType
    _min?: KnowledgeSettingsMinAggregateInputType
    _max?: KnowledgeSettingsMaxAggregateInputType
  }

  export type KnowledgeSettingsGroupByOutputType = {
    id: string
    agentId: string
    searchFuzziness: number
    maxResults: number
    autoRefresh: boolean
    refreshInterval: number
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeSettingsCountAggregateOutputType | null
    _avg: KnowledgeSettingsAvgAggregateOutputType | null
    _sum: KnowledgeSettingsSumAggregateOutputType | null
    _min: KnowledgeSettingsMinAggregateOutputType | null
    _max: KnowledgeSettingsMaxAggregateOutputType | null
  }

  type GetKnowledgeSettingsGroupByPayload<T extends KnowledgeSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeSettingsGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    searchFuzziness?: boolean
    maxResults?: boolean
    autoRefresh?: boolean
    refreshInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeSettings"]>

  export type KnowledgeSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    searchFuzziness?: boolean
    maxResults?: boolean
    autoRefresh?: boolean
    refreshInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeSettings"]>

  export type KnowledgeSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    searchFuzziness?: boolean
    maxResults?: boolean
    autoRefresh?: boolean
    refreshInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeSettings"]>

  export type KnowledgeSettingsSelectScalar = {
    id?: boolean
    agentId?: boolean
    searchFuzziness?: boolean
    maxResults?: boolean
    autoRefresh?: boolean
    refreshInterval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "searchFuzziness" | "maxResults" | "autoRefresh" | "refreshInterval" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeSettings"]>
  export type KnowledgeSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type KnowledgeSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type KnowledgeSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $KnowledgeSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeSettings"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      searchFuzziness: number
      maxResults: number
      autoRefresh: boolean
      refreshInterval: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeSettings"]>
    composites: {}
  }

  type KnowledgeSettingsGetPayload<S extends boolean | null | undefined | KnowledgeSettingsDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeSettingsPayload, S>

  type KnowledgeSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeSettingsCountAggregateInputType | true
    }

  export interface KnowledgeSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeSettings'], meta: { name: 'KnowledgeSettings' } }
    /**
     * Find zero or one KnowledgeSettings that matches the filter.
     * @param {KnowledgeSettingsFindUniqueArgs} args - Arguments to find a KnowledgeSettings
     * @example
     * // Get one KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeSettingsFindUniqueArgs>(args: SelectSubset<T, KnowledgeSettingsFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeSettingsFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeSettings
     * @example
     * // Get one KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsFindFirstArgs} args - Arguments to find a KnowledgeSettings
     * @example
     * // Get one KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeSettingsFindFirstArgs>(args?: SelectSubset<T, KnowledgeSettingsFindFirstArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsFindFirstOrThrowArgs} args - Arguments to find a KnowledgeSettings
     * @example
     * // Get one KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.findMany()
     * 
     * // Get first 10 KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeSettingsWithIdOnly = await prisma.knowledgeSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeSettingsFindManyArgs>(args?: SelectSubset<T, KnowledgeSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeSettings.
     * @param {KnowledgeSettingsCreateArgs} args - Arguments to create a KnowledgeSettings.
     * @example
     * // Create one KnowledgeSettings
     * const KnowledgeSettings = await prisma.knowledgeSettings.create({
     *   data: {
     *     // ... data to create a KnowledgeSettings
     *   }
     * })
     * 
     */
    create<T extends KnowledgeSettingsCreateArgs>(args: SelectSubset<T, KnowledgeSettingsCreateArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeSettings.
     * @param {KnowledgeSettingsCreateManyArgs} args - Arguments to create many KnowledgeSettings.
     * @example
     * // Create many KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeSettingsCreateManyArgs>(args?: SelectSubset<T, KnowledgeSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeSettings and returns the data saved in the database.
     * @param {KnowledgeSettingsCreateManyAndReturnArgs} args - Arguments to create many KnowledgeSettings.
     * @example
     * // Create many KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeSettings and only return the `id`
     * const knowledgeSettingsWithIdOnly = await prisma.knowledgeSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeSettings.
     * @param {KnowledgeSettingsDeleteArgs} args - Arguments to delete one KnowledgeSettings.
     * @example
     * // Delete one KnowledgeSettings
     * const KnowledgeSettings = await prisma.knowledgeSettings.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeSettings
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeSettingsDeleteArgs>(args: SelectSubset<T, KnowledgeSettingsDeleteArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeSettings.
     * @param {KnowledgeSettingsUpdateArgs} args - Arguments to update one KnowledgeSettings.
     * @example
     * // Update one KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeSettingsUpdateArgs>(args: SelectSubset<T, KnowledgeSettingsUpdateArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeSettings.
     * @param {KnowledgeSettingsDeleteManyArgs} args - Arguments to filter KnowledgeSettings to delete.
     * @example
     * // Delete a few KnowledgeSettings
     * const { count } = await prisma.knowledgeSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeSettingsDeleteManyArgs>(args?: SelectSubset<T, KnowledgeSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeSettingsUpdateManyArgs>(args: SelectSubset<T, KnowledgeSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeSettings and returns the data updated in the database.
     * @param {KnowledgeSettingsUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeSettings.
     * @example
     * // Update many KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeSettings and only return the `id`
     * const knowledgeSettingsWithIdOnly = await prisma.knowledgeSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeSettings.
     * @param {KnowledgeSettingsUpsertArgs} args - Arguments to update or create a KnowledgeSettings.
     * @example
     * // Update or create a KnowledgeSettings
     * const knowledgeSettings = await prisma.knowledgeSettings.upsert({
     *   create: {
     *     // ... data to create a KnowledgeSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeSettings we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeSettingsUpsertArgs>(args: SelectSubset<T, KnowledgeSettingsUpsertArgs<ExtArgs>>): Prisma__KnowledgeSettingsClient<$Result.GetResult<Prisma.$KnowledgeSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsCountArgs} args - Arguments to filter KnowledgeSettings to count.
     * @example
     * // Count the number of KnowledgeSettings
     * const count = await prisma.knowledgeSettings.count({
     *   where: {
     *     // ... the filter for the KnowledgeSettings we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeSettingsCountArgs>(
      args?: Subset<T, KnowledgeSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeSettingsAggregateArgs>(args: Subset<T, KnowledgeSettingsAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeSettingsAggregateType<T>>

    /**
     * Group by KnowledgeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeSettingsGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeSettings model
   */
  readonly fields: KnowledgeSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeSettings model
   */
  interface KnowledgeSettingsFieldRefs {
    readonly id: FieldRef<"KnowledgeSettings", 'String'>
    readonly agentId: FieldRef<"KnowledgeSettings", 'String'>
    readonly searchFuzziness: FieldRef<"KnowledgeSettings", 'Int'>
    readonly maxResults: FieldRef<"KnowledgeSettings", 'Int'>
    readonly autoRefresh: FieldRef<"KnowledgeSettings", 'Boolean'>
    readonly refreshInterval: FieldRef<"KnowledgeSettings", 'Int'>
    readonly createdAt: FieldRef<"KnowledgeSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeSettings findUnique
   */
  export type KnowledgeSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeSettings to fetch.
     */
    where: KnowledgeSettingsWhereUniqueInput
  }

  /**
   * KnowledgeSettings findUniqueOrThrow
   */
  export type KnowledgeSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeSettings to fetch.
     */
    where: KnowledgeSettingsWhereUniqueInput
  }

  /**
   * KnowledgeSettings findFirst
   */
  export type KnowledgeSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeSettings to fetch.
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeSettings to fetch.
     */
    orderBy?: KnowledgeSettingsOrderByWithRelationInput | KnowledgeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeSettings.
     */
    cursor?: KnowledgeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeSettings.
     */
    distinct?: KnowledgeSettingsScalarFieldEnum | KnowledgeSettingsScalarFieldEnum[]
  }

  /**
   * KnowledgeSettings findFirstOrThrow
   */
  export type KnowledgeSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeSettings to fetch.
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeSettings to fetch.
     */
    orderBy?: KnowledgeSettingsOrderByWithRelationInput | KnowledgeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeSettings.
     */
    cursor?: KnowledgeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeSettings.
     */
    distinct?: KnowledgeSettingsScalarFieldEnum | KnowledgeSettingsScalarFieldEnum[]
  }

  /**
   * KnowledgeSettings findMany
   */
  export type KnowledgeSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeSettings to fetch.
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeSettings to fetch.
     */
    orderBy?: KnowledgeSettingsOrderByWithRelationInput | KnowledgeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeSettings.
     */
    cursor?: KnowledgeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeSettings.
     */
    skip?: number
    distinct?: KnowledgeSettingsScalarFieldEnum | KnowledgeSettingsScalarFieldEnum[]
  }

  /**
   * KnowledgeSettings create
   */
  export type KnowledgeSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeSettings.
     */
    data: XOR<KnowledgeSettingsCreateInput, KnowledgeSettingsUncheckedCreateInput>
  }

  /**
   * KnowledgeSettings createMany
   */
  export type KnowledgeSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeSettings.
     */
    data: KnowledgeSettingsCreateManyInput | KnowledgeSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeSettings createManyAndReturn
   */
  export type KnowledgeSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeSettings.
     */
    data: KnowledgeSettingsCreateManyInput | KnowledgeSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeSettings update
   */
  export type KnowledgeSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeSettings.
     */
    data: XOR<KnowledgeSettingsUpdateInput, KnowledgeSettingsUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeSettings to update.
     */
    where: KnowledgeSettingsWhereUniqueInput
  }

  /**
   * KnowledgeSettings updateMany
   */
  export type KnowledgeSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeSettings.
     */
    data: XOR<KnowledgeSettingsUpdateManyMutationInput, KnowledgeSettingsUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeSettings to update
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * Limit how many KnowledgeSettings to update.
     */
    limit?: number
  }

  /**
   * KnowledgeSettings updateManyAndReturn
   */
  export type KnowledgeSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeSettings.
     */
    data: XOR<KnowledgeSettingsUpdateManyMutationInput, KnowledgeSettingsUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeSettings to update
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * Limit how many KnowledgeSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeSettings upsert
   */
  export type KnowledgeSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeSettings to update in case it exists.
     */
    where: KnowledgeSettingsWhereUniqueInput
    /**
     * In case the KnowledgeSettings found by the `where` argument doesn't exist, create a new KnowledgeSettings with this data.
     */
    create: XOR<KnowledgeSettingsCreateInput, KnowledgeSettingsUncheckedCreateInput>
    /**
     * In case the KnowledgeSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeSettingsUpdateInput, KnowledgeSettingsUncheckedUpdateInput>
  }

  /**
   * KnowledgeSettings delete
   */
  export type KnowledgeSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeSettings to delete.
     */
    where: KnowledgeSettingsWhereUniqueInput
  }

  /**
   * KnowledgeSettings deleteMany
   */
  export type KnowledgeSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeSettings to delete
     */
    where?: KnowledgeSettingsWhereInput
    /**
     * Limit how many KnowledgeSettings to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeSettings without action
   */
  export type KnowledgeSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeSettings
     */
    select?: KnowledgeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeSettings
     */
    omit?: KnowledgeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeSettingsInclude<ExtArgs> | null
  }


  /**
   * Model AgentTrigger
   */

  export type AggregateAgentTrigger = {
    _count: AgentTriggerCountAggregateOutputType | null
    _min: AgentTriggerMinAggregateOutputType | null
    _max: AgentTriggerMaxAggregateOutputType | null
  }

  export type AgentTriggerMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    name: string | null
    type: $Enums.TriggerType | null
    enabled: boolean | null
    cronExpression: string | null
    nextRunAt: Date | null
    lastRunAt: Date | null
    webhookSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentTriggerMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    name: string | null
    type: $Enums.TriggerType | null
    enabled: boolean | null
    cronExpression: string | null
    nextRunAt: Date | null
    lastRunAt: Date | null
    webhookSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentTriggerCountAggregateOutputType = {
    id: number
    agentId: number
    name: number
    type: number
    enabled: number
    config: number
    cronExpression: number
    nextRunAt: number
    lastRunAt: number
    webhookSecret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentTriggerMinAggregateInputType = {
    id?: true
    agentId?: true
    name?: true
    type?: true
    enabled?: true
    cronExpression?: true
    nextRunAt?: true
    lastRunAt?: true
    webhookSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentTriggerMaxAggregateInputType = {
    id?: true
    agentId?: true
    name?: true
    type?: true
    enabled?: true
    cronExpression?: true
    nextRunAt?: true
    lastRunAt?: true
    webhookSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentTriggerCountAggregateInputType = {
    id?: true
    agentId?: true
    name?: true
    type?: true
    enabled?: true
    config?: true
    cronExpression?: true
    nextRunAt?: true
    lastRunAt?: true
    webhookSecret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentTriggerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTrigger to aggregate.
     */
    where?: AgentTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTriggers to fetch.
     */
    orderBy?: AgentTriggerOrderByWithRelationInput | AgentTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTriggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentTriggers
    **/
    _count?: true | AgentTriggerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentTriggerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentTriggerMaxAggregateInputType
  }

  export type GetAgentTriggerAggregateType<T extends AgentTriggerAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentTrigger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentTrigger[P]>
      : GetScalarType<T[P], AggregateAgentTrigger[P]>
  }




  export type AgentTriggerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTriggerWhereInput
    orderBy?: AgentTriggerOrderByWithAggregationInput | AgentTriggerOrderByWithAggregationInput[]
    by: AgentTriggerScalarFieldEnum[] | AgentTriggerScalarFieldEnum
    having?: AgentTriggerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentTriggerCountAggregateInputType | true
    _min?: AgentTriggerMinAggregateInputType
    _max?: AgentTriggerMaxAggregateInputType
  }

  export type AgentTriggerGroupByOutputType = {
    id: string
    agentId: string
    name: string
    type: $Enums.TriggerType
    enabled: boolean
    config: JsonValue
    cronExpression: string | null
    nextRunAt: Date | null
    lastRunAt: Date | null
    webhookSecret: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgentTriggerCountAggregateOutputType | null
    _min: AgentTriggerMinAggregateOutputType | null
    _max: AgentTriggerMaxAggregateOutputType | null
  }

  type GetAgentTriggerGroupByPayload<T extends AgentTriggerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentTriggerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentTriggerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentTriggerGroupByOutputType[P]>
            : GetScalarType<T[P], AgentTriggerGroupByOutputType[P]>
        }
      >
    >


  export type AgentTriggerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    name?: boolean
    type?: boolean
    enabled?: boolean
    config?: boolean
    cronExpression?: boolean
    nextRunAt?: boolean
    lastRunAt?: boolean
    webhookSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTrigger"]>

  export type AgentTriggerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    name?: boolean
    type?: boolean
    enabled?: boolean
    config?: boolean
    cronExpression?: boolean
    nextRunAt?: boolean
    lastRunAt?: boolean
    webhookSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTrigger"]>

  export type AgentTriggerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    name?: boolean
    type?: boolean
    enabled?: boolean
    config?: boolean
    cronExpression?: boolean
    nextRunAt?: boolean
    lastRunAt?: boolean
    webhookSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTrigger"]>

  export type AgentTriggerSelectScalar = {
    id?: boolean
    agentId?: boolean
    name?: boolean
    type?: boolean
    enabled?: boolean
    config?: boolean
    cronExpression?: boolean
    nextRunAt?: boolean
    lastRunAt?: boolean
    webhookSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentTriggerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "name" | "type" | "enabled" | "config" | "cronExpression" | "nextRunAt" | "lastRunAt" | "webhookSecret" | "createdAt" | "updatedAt", ExtArgs["result"]["agentTrigger"]>
  export type AgentTriggerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentTriggerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentTriggerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentTriggerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentTrigger"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      name: string
      type: $Enums.TriggerType
      enabled: boolean
      config: Prisma.JsonValue
      cronExpression: string | null
      nextRunAt: Date | null
      lastRunAt: Date | null
      webhookSecret: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentTrigger"]>
    composites: {}
  }

  type AgentTriggerGetPayload<S extends boolean | null | undefined | AgentTriggerDefaultArgs> = $Result.GetResult<Prisma.$AgentTriggerPayload, S>

  type AgentTriggerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentTriggerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentTriggerCountAggregateInputType | true
    }

  export interface AgentTriggerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentTrigger'], meta: { name: 'AgentTrigger' } }
    /**
     * Find zero or one AgentTrigger that matches the filter.
     * @param {AgentTriggerFindUniqueArgs} args - Arguments to find a AgentTrigger
     * @example
     * // Get one AgentTrigger
     * const agentTrigger = await prisma.agentTrigger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentTriggerFindUniqueArgs>(args: SelectSubset<T, AgentTriggerFindUniqueArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentTrigger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentTriggerFindUniqueOrThrowArgs} args - Arguments to find a AgentTrigger
     * @example
     * // Get one AgentTrigger
     * const agentTrigger = await prisma.agentTrigger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentTriggerFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentTriggerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTrigger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerFindFirstArgs} args - Arguments to find a AgentTrigger
     * @example
     * // Get one AgentTrigger
     * const agentTrigger = await prisma.agentTrigger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentTriggerFindFirstArgs>(args?: SelectSubset<T, AgentTriggerFindFirstArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTrigger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerFindFirstOrThrowArgs} args - Arguments to find a AgentTrigger
     * @example
     * // Get one AgentTrigger
     * const agentTrigger = await prisma.agentTrigger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentTriggerFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentTriggerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentTriggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentTriggers
     * const agentTriggers = await prisma.agentTrigger.findMany()
     * 
     * // Get first 10 AgentTriggers
     * const agentTriggers = await prisma.agentTrigger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentTriggerWithIdOnly = await prisma.agentTrigger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentTriggerFindManyArgs>(args?: SelectSubset<T, AgentTriggerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentTrigger.
     * @param {AgentTriggerCreateArgs} args - Arguments to create a AgentTrigger.
     * @example
     * // Create one AgentTrigger
     * const AgentTrigger = await prisma.agentTrigger.create({
     *   data: {
     *     // ... data to create a AgentTrigger
     *   }
     * })
     * 
     */
    create<T extends AgentTriggerCreateArgs>(args: SelectSubset<T, AgentTriggerCreateArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentTriggers.
     * @param {AgentTriggerCreateManyArgs} args - Arguments to create many AgentTriggers.
     * @example
     * // Create many AgentTriggers
     * const agentTrigger = await prisma.agentTrigger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentTriggerCreateManyArgs>(args?: SelectSubset<T, AgentTriggerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentTriggers and returns the data saved in the database.
     * @param {AgentTriggerCreateManyAndReturnArgs} args - Arguments to create many AgentTriggers.
     * @example
     * // Create many AgentTriggers
     * const agentTrigger = await prisma.agentTrigger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentTriggers and only return the `id`
     * const agentTriggerWithIdOnly = await prisma.agentTrigger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentTriggerCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentTriggerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentTrigger.
     * @param {AgentTriggerDeleteArgs} args - Arguments to delete one AgentTrigger.
     * @example
     * // Delete one AgentTrigger
     * const AgentTrigger = await prisma.agentTrigger.delete({
     *   where: {
     *     // ... filter to delete one AgentTrigger
     *   }
     * })
     * 
     */
    delete<T extends AgentTriggerDeleteArgs>(args: SelectSubset<T, AgentTriggerDeleteArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentTrigger.
     * @param {AgentTriggerUpdateArgs} args - Arguments to update one AgentTrigger.
     * @example
     * // Update one AgentTrigger
     * const agentTrigger = await prisma.agentTrigger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentTriggerUpdateArgs>(args: SelectSubset<T, AgentTriggerUpdateArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentTriggers.
     * @param {AgentTriggerDeleteManyArgs} args - Arguments to filter AgentTriggers to delete.
     * @example
     * // Delete a few AgentTriggers
     * const { count } = await prisma.agentTrigger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentTriggerDeleteManyArgs>(args?: SelectSubset<T, AgentTriggerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTriggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentTriggers
     * const agentTrigger = await prisma.agentTrigger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentTriggerUpdateManyArgs>(args: SelectSubset<T, AgentTriggerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTriggers and returns the data updated in the database.
     * @param {AgentTriggerUpdateManyAndReturnArgs} args - Arguments to update many AgentTriggers.
     * @example
     * // Update many AgentTriggers
     * const agentTrigger = await prisma.agentTrigger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentTriggers and only return the `id`
     * const agentTriggerWithIdOnly = await prisma.agentTrigger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentTriggerUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentTriggerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentTrigger.
     * @param {AgentTriggerUpsertArgs} args - Arguments to update or create a AgentTrigger.
     * @example
     * // Update or create a AgentTrigger
     * const agentTrigger = await prisma.agentTrigger.upsert({
     *   create: {
     *     // ... data to create a AgentTrigger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentTrigger we want to update
     *   }
     * })
     */
    upsert<T extends AgentTriggerUpsertArgs>(args: SelectSubset<T, AgentTriggerUpsertArgs<ExtArgs>>): Prisma__AgentTriggerClient<$Result.GetResult<Prisma.$AgentTriggerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentTriggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerCountArgs} args - Arguments to filter AgentTriggers to count.
     * @example
     * // Count the number of AgentTriggers
     * const count = await prisma.agentTrigger.count({
     *   where: {
     *     // ... the filter for the AgentTriggers we want to count
     *   }
     * })
    **/
    count<T extends AgentTriggerCountArgs>(
      args?: Subset<T, AgentTriggerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentTriggerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentTrigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentTriggerAggregateArgs>(args: Subset<T, AgentTriggerAggregateArgs>): Prisma.PrismaPromise<GetAgentTriggerAggregateType<T>>

    /**
     * Group by AgentTrigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTriggerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentTriggerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentTriggerGroupByArgs['orderBy'] }
        : { orderBy?: AgentTriggerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentTriggerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentTriggerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentTrigger model
   */
  readonly fields: AgentTriggerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentTrigger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentTriggerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentTrigger model
   */
  interface AgentTriggerFieldRefs {
    readonly id: FieldRef<"AgentTrigger", 'String'>
    readonly agentId: FieldRef<"AgentTrigger", 'String'>
    readonly name: FieldRef<"AgentTrigger", 'String'>
    readonly type: FieldRef<"AgentTrigger", 'TriggerType'>
    readonly enabled: FieldRef<"AgentTrigger", 'Boolean'>
    readonly config: FieldRef<"AgentTrigger", 'Json'>
    readonly cronExpression: FieldRef<"AgentTrigger", 'String'>
    readonly nextRunAt: FieldRef<"AgentTrigger", 'DateTime'>
    readonly lastRunAt: FieldRef<"AgentTrigger", 'DateTime'>
    readonly webhookSecret: FieldRef<"AgentTrigger", 'String'>
    readonly createdAt: FieldRef<"AgentTrigger", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentTrigger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentTrigger findUnique
   */
  export type AgentTriggerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrigger to fetch.
     */
    where: AgentTriggerWhereUniqueInput
  }

  /**
   * AgentTrigger findUniqueOrThrow
   */
  export type AgentTriggerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrigger to fetch.
     */
    where: AgentTriggerWhereUniqueInput
  }

  /**
   * AgentTrigger findFirst
   */
  export type AgentTriggerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrigger to fetch.
     */
    where?: AgentTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTriggers to fetch.
     */
    orderBy?: AgentTriggerOrderByWithRelationInput | AgentTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTriggers.
     */
    cursor?: AgentTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTriggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTriggers.
     */
    distinct?: AgentTriggerScalarFieldEnum | AgentTriggerScalarFieldEnum[]
  }

  /**
   * AgentTrigger findFirstOrThrow
   */
  export type AgentTriggerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrigger to fetch.
     */
    where?: AgentTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTriggers to fetch.
     */
    orderBy?: AgentTriggerOrderByWithRelationInput | AgentTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTriggers.
     */
    cursor?: AgentTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTriggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTriggers.
     */
    distinct?: AgentTriggerScalarFieldEnum | AgentTriggerScalarFieldEnum[]
  }

  /**
   * AgentTrigger findMany
   */
  export type AgentTriggerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * Filter, which AgentTriggers to fetch.
     */
    where?: AgentTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTriggers to fetch.
     */
    orderBy?: AgentTriggerOrderByWithRelationInput | AgentTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentTriggers.
     */
    cursor?: AgentTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTriggers.
     */
    skip?: number
    distinct?: AgentTriggerScalarFieldEnum | AgentTriggerScalarFieldEnum[]
  }

  /**
   * AgentTrigger create
   */
  export type AgentTriggerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentTrigger.
     */
    data: XOR<AgentTriggerCreateInput, AgentTriggerUncheckedCreateInput>
  }

  /**
   * AgentTrigger createMany
   */
  export type AgentTriggerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentTriggers.
     */
    data: AgentTriggerCreateManyInput | AgentTriggerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTrigger createManyAndReturn
   */
  export type AgentTriggerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * The data used to create many AgentTriggers.
     */
    data: AgentTriggerCreateManyInput | AgentTriggerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTrigger update
   */
  export type AgentTriggerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentTrigger.
     */
    data: XOR<AgentTriggerUpdateInput, AgentTriggerUncheckedUpdateInput>
    /**
     * Choose, which AgentTrigger to update.
     */
    where: AgentTriggerWhereUniqueInput
  }

  /**
   * AgentTrigger updateMany
   */
  export type AgentTriggerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentTriggers.
     */
    data: XOR<AgentTriggerUpdateManyMutationInput, AgentTriggerUncheckedUpdateManyInput>
    /**
     * Filter which AgentTriggers to update
     */
    where?: AgentTriggerWhereInput
    /**
     * Limit how many AgentTriggers to update.
     */
    limit?: number
  }

  /**
   * AgentTrigger updateManyAndReturn
   */
  export type AgentTriggerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * The data used to update AgentTriggers.
     */
    data: XOR<AgentTriggerUpdateManyMutationInput, AgentTriggerUncheckedUpdateManyInput>
    /**
     * Filter which AgentTriggers to update
     */
    where?: AgentTriggerWhereInput
    /**
     * Limit how many AgentTriggers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTrigger upsert
   */
  export type AgentTriggerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentTrigger to update in case it exists.
     */
    where: AgentTriggerWhereUniqueInput
    /**
     * In case the AgentTrigger found by the `where` argument doesn't exist, create a new AgentTrigger with this data.
     */
    create: XOR<AgentTriggerCreateInput, AgentTriggerUncheckedCreateInput>
    /**
     * In case the AgentTrigger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentTriggerUpdateInput, AgentTriggerUncheckedUpdateInput>
  }

  /**
   * AgentTrigger delete
   */
  export type AgentTriggerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
    /**
     * Filter which AgentTrigger to delete.
     */
    where: AgentTriggerWhereUniqueInput
  }

  /**
   * AgentTrigger deleteMany
   */
  export type AgentTriggerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTriggers to delete
     */
    where?: AgentTriggerWhereInput
    /**
     * Limit how many AgentTriggers to delete.
     */
    limit?: number
  }

  /**
   * AgentTrigger without action
   */
  export type AgentTriggerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrigger
     */
    select?: AgentTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrigger
     */
    omit?: AgentTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTriggerInclude<ExtArgs> | null
  }


  /**
   * Model AgentTemplate
   */

  export type AggregateAgentTemplate = {
    _count: AgentTemplateCountAggregateOutputType | null
    _avg: AgentTemplateAvgAggregateOutputType | null
    _sum: AgentTemplateSumAggregateOutputType | null
    _min: AgentTemplateMinAggregateOutputType | null
    _max: AgentTemplateMaxAggregateOutputType | null
  }

  export type AgentTemplateAvgAggregateOutputType = {
    temperature: number | null
    maxStepsPerRun: number | null
    usageCount: number | null
    rating: number | null
    reviewCount: number | null
  }

  export type AgentTemplateSumAggregateOutputType = {
    temperature: number | null
    maxStepsPerRun: number | null
    usageCount: number | null
    rating: number | null
    reviewCount: number | null
  }

  export type AgentTemplateMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    subtitle: string | null
    description: string | null
    category: $Enums.TemplateCategory | null
    role: $Enums.TemplateRole | null
    useCase: $Enums.TemplateUseCase | null
    systemPrompt: string | null
    context: string | null
    model: $Enums.AgentModel | null
    temperature: number | null
    llmTier: string | null
    maxStepsPerRun: number | null
    icon: string | null
    color: string | null
    coverImage: string | null
    isPublic: boolean | null
    isFeatured: boolean | null
    createdById: string | null
    createdByName: string | null
    usageCount: number | null
    rating: number | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentTemplateMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    subtitle: string | null
    description: string | null
    category: $Enums.TemplateCategory | null
    role: $Enums.TemplateRole | null
    useCase: $Enums.TemplateUseCase | null
    systemPrompt: string | null
    context: string | null
    model: $Enums.AgentModel | null
    temperature: number | null
    llmTier: string | null
    maxStepsPerRun: number | null
    icon: string | null
    color: string | null
    coverImage: string | null
    isPublic: boolean | null
    isFeatured: boolean | null
    createdById: string | null
    createdByName: string | null
    usageCount: number | null
    rating: number | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentTemplateCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    subtitle: number
    description: number
    category: number
    role: number
    useCase: number
    systemPrompt: number
    context: number
    model: number
    temperature: number
    trigger: number
    llmTier: number
    maxStepsPerRun: number
    fetchSources: number
    actions: number
    evalRules: number
    suggestedTools: number
    suggestedTriggers: number
    suggestedIntegrations: number
    flowData: number
    defaultTriggers: number
    defaultTools: number
    icon: number
    color: number
    coverImage: number
    isPublic: number
    isFeatured: number
    createdById: number
    createdByName: number
    usageCount: number
    rating: number
    reviewCount: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentTemplateAvgAggregateInputType = {
    temperature?: true
    maxStepsPerRun?: true
    usageCount?: true
    rating?: true
    reviewCount?: true
  }

  export type AgentTemplateSumAggregateInputType = {
    temperature?: true
    maxStepsPerRun?: true
    usageCount?: true
    rating?: true
    reviewCount?: true
  }

  export type AgentTemplateMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    subtitle?: true
    description?: true
    category?: true
    role?: true
    useCase?: true
    systemPrompt?: true
    context?: true
    model?: true
    temperature?: true
    llmTier?: true
    maxStepsPerRun?: true
    icon?: true
    color?: true
    coverImage?: true
    isPublic?: true
    isFeatured?: true
    createdById?: true
    createdByName?: true
    usageCount?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentTemplateMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    subtitle?: true
    description?: true
    category?: true
    role?: true
    useCase?: true
    systemPrompt?: true
    context?: true
    model?: true
    temperature?: true
    llmTier?: true
    maxStepsPerRun?: true
    icon?: true
    color?: true
    coverImage?: true
    isPublic?: true
    isFeatured?: true
    createdById?: true
    createdByName?: true
    usageCount?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentTemplateCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    subtitle?: true
    description?: true
    category?: true
    role?: true
    useCase?: true
    systemPrompt?: true
    context?: true
    model?: true
    temperature?: true
    trigger?: true
    llmTier?: true
    maxStepsPerRun?: true
    fetchSources?: true
    actions?: true
    evalRules?: true
    suggestedTools?: true
    suggestedTriggers?: true
    suggestedIntegrations?: true
    flowData?: true
    defaultTriggers?: true
    defaultTools?: true
    icon?: true
    color?: true
    coverImage?: true
    isPublic?: true
    isFeatured?: true
    createdById?: true
    createdByName?: true
    usageCount?: true
    rating?: true
    reviewCount?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTemplate to aggregate.
     */
    where?: AgentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTemplates to fetch.
     */
    orderBy?: AgentTemplateOrderByWithRelationInput | AgentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentTemplates
    **/
    _count?: true | AgentTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentTemplateMaxAggregateInputType
  }

  export type GetAgentTemplateAggregateType<T extends AgentTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentTemplate[P]>
      : GetScalarType<T[P], AggregateAgentTemplate[P]>
  }




  export type AgentTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTemplateWhereInput
    orderBy?: AgentTemplateOrderByWithAggregationInput | AgentTemplateOrderByWithAggregationInput[]
    by: AgentTemplateScalarFieldEnum[] | AgentTemplateScalarFieldEnum
    having?: AgentTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentTemplateCountAggregateInputType | true
    _avg?: AgentTemplateAvgAggregateInputType
    _sum?: AgentTemplateSumAggregateInputType
    _min?: AgentTemplateMinAggregateInputType
    _max?: AgentTemplateMaxAggregateInputType
  }

  export type AgentTemplateGroupByOutputType = {
    id: string
    slug: string | null
    name: string
    subtitle: string | null
    description: string
    category: $Enums.TemplateCategory
    role: $Enums.TemplateRole | null
    useCase: $Enums.TemplateUseCase | null
    systemPrompt: string
    context: string | null
    model: $Enums.AgentModel
    temperature: number
    trigger: JsonValue
    llmTier: string
    maxStepsPerRun: number
    fetchSources: JsonValue
    actions: JsonValue
    evalRules: JsonValue
    suggestedTools: JsonValue
    suggestedTriggers: JsonValue
    suggestedIntegrations: string[]
    flowData: JsonValue
    defaultTriggers: JsonValue
    defaultTools: JsonValue
    icon: string | null
    color: string | null
    coverImage: string | null
    isPublic: boolean
    isFeatured: boolean
    createdById: string | null
    createdByName: string | null
    usageCount: number
    rating: number
    reviewCount: number
    tags: string[]
    createdAt: Date
    updatedAt: Date
    _count: AgentTemplateCountAggregateOutputType | null
    _avg: AgentTemplateAvgAggregateOutputType | null
    _sum: AgentTemplateSumAggregateOutputType | null
    _min: AgentTemplateMinAggregateOutputType | null
    _max: AgentTemplateMaxAggregateOutputType | null
  }

  type GetAgentTemplateGroupByPayload<T extends AgentTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], AgentTemplateGroupByOutputType[P]>
        }
      >
    >


  export type AgentTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    category?: boolean
    role?: boolean
    useCase?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    trigger?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    fetchSources?: boolean
    actions?: boolean
    evalRules?: boolean
    suggestedTools?: boolean
    suggestedTriggers?: boolean
    suggestedIntegrations?: boolean
    flowData?: boolean
    defaultTriggers?: boolean
    defaultTools?: boolean
    icon?: boolean
    color?: boolean
    coverImage?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: boolean
    createdByName?: boolean
    usageCount?: boolean
    rating?: boolean
    reviewCount?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agents?: boolean | AgentTemplate$agentsArgs<ExtArgs>
    _count?: boolean | AgentTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTemplate"]>

  export type AgentTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    category?: boolean
    role?: boolean
    useCase?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    trigger?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    fetchSources?: boolean
    actions?: boolean
    evalRules?: boolean
    suggestedTools?: boolean
    suggestedTriggers?: boolean
    suggestedIntegrations?: boolean
    flowData?: boolean
    defaultTriggers?: boolean
    defaultTools?: boolean
    icon?: boolean
    color?: boolean
    coverImage?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: boolean
    createdByName?: boolean
    usageCount?: boolean
    rating?: boolean
    reviewCount?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentTemplate"]>

  export type AgentTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    category?: boolean
    role?: boolean
    useCase?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    trigger?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    fetchSources?: boolean
    actions?: boolean
    evalRules?: boolean
    suggestedTools?: boolean
    suggestedTriggers?: boolean
    suggestedIntegrations?: boolean
    flowData?: boolean
    defaultTriggers?: boolean
    defaultTools?: boolean
    icon?: boolean
    color?: boolean
    coverImage?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: boolean
    createdByName?: boolean
    usageCount?: boolean
    rating?: boolean
    reviewCount?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentTemplate"]>

  export type AgentTemplateSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    subtitle?: boolean
    description?: boolean
    category?: boolean
    role?: boolean
    useCase?: boolean
    systemPrompt?: boolean
    context?: boolean
    model?: boolean
    temperature?: boolean
    trigger?: boolean
    llmTier?: boolean
    maxStepsPerRun?: boolean
    fetchSources?: boolean
    actions?: boolean
    evalRules?: boolean
    suggestedTools?: boolean
    suggestedTriggers?: boolean
    suggestedIntegrations?: boolean
    flowData?: boolean
    defaultTriggers?: boolean
    defaultTools?: boolean
    icon?: boolean
    color?: boolean
    coverImage?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: boolean
    createdByName?: boolean
    usageCount?: boolean
    rating?: boolean
    reviewCount?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "subtitle" | "description" | "category" | "role" | "useCase" | "systemPrompt" | "context" | "model" | "temperature" | "trigger" | "llmTier" | "maxStepsPerRun" | "fetchSources" | "actions" | "evalRules" | "suggestedTools" | "suggestedTriggers" | "suggestedIntegrations" | "flowData" | "defaultTriggers" | "defaultTools" | "icon" | "color" | "coverImage" | "isPublic" | "isFeatured" | "createdById" | "createdByName" | "usageCount" | "rating" | "reviewCount" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["agentTemplate"]>
  export type AgentTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentTemplate$agentsArgs<ExtArgs>
    _count?: boolean | AgentTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgentTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgentTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentTemplate"
    objects: {
      agents: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string | null
      name: string
      subtitle: string | null
      description: string
      category: $Enums.TemplateCategory
      role: $Enums.TemplateRole | null
      useCase: $Enums.TemplateUseCase | null
      systemPrompt: string
      context: string | null
      model: $Enums.AgentModel
      temperature: number
      trigger: Prisma.JsonValue
      llmTier: string
      maxStepsPerRun: number
      fetchSources: Prisma.JsonValue
      actions: Prisma.JsonValue
      evalRules: Prisma.JsonValue
      suggestedTools: Prisma.JsonValue
      suggestedTriggers: Prisma.JsonValue
      suggestedIntegrations: string[]
      flowData: Prisma.JsonValue
      defaultTriggers: Prisma.JsonValue
      defaultTools: Prisma.JsonValue
      icon: string | null
      color: string | null
      coverImage: string | null
      isPublic: boolean
      isFeatured: boolean
      createdById: string | null
      createdByName: string | null
      usageCount: number
      rating: number
      reviewCount: number
      tags: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentTemplate"]>
    composites: {}
  }

  type AgentTemplateGetPayload<S extends boolean | null | undefined | AgentTemplateDefaultArgs> = $Result.GetResult<Prisma.$AgentTemplatePayload, S>

  type AgentTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentTemplateCountAggregateInputType | true
    }

  export interface AgentTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentTemplate'], meta: { name: 'AgentTemplate' } }
    /**
     * Find zero or one AgentTemplate that matches the filter.
     * @param {AgentTemplateFindUniqueArgs} args - Arguments to find a AgentTemplate
     * @example
     * // Get one AgentTemplate
     * const agentTemplate = await prisma.agentTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentTemplateFindUniqueArgs>(args: SelectSubset<T, AgentTemplateFindUniqueArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentTemplateFindUniqueOrThrowArgs} args - Arguments to find a AgentTemplate
     * @example
     * // Get one AgentTemplate
     * const agentTemplate = await prisma.agentTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateFindFirstArgs} args - Arguments to find a AgentTemplate
     * @example
     * // Get one AgentTemplate
     * const agentTemplate = await prisma.agentTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentTemplateFindFirstArgs>(args?: SelectSubset<T, AgentTemplateFindFirstArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateFindFirstOrThrowArgs} args - Arguments to find a AgentTemplate
     * @example
     * // Get one AgentTemplate
     * const agentTemplate = await prisma.agentTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentTemplates
     * const agentTemplates = await prisma.agentTemplate.findMany()
     * 
     * // Get first 10 AgentTemplates
     * const agentTemplates = await prisma.agentTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentTemplateWithIdOnly = await prisma.agentTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentTemplateFindManyArgs>(args?: SelectSubset<T, AgentTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentTemplate.
     * @param {AgentTemplateCreateArgs} args - Arguments to create a AgentTemplate.
     * @example
     * // Create one AgentTemplate
     * const AgentTemplate = await prisma.agentTemplate.create({
     *   data: {
     *     // ... data to create a AgentTemplate
     *   }
     * })
     * 
     */
    create<T extends AgentTemplateCreateArgs>(args: SelectSubset<T, AgentTemplateCreateArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentTemplates.
     * @param {AgentTemplateCreateManyArgs} args - Arguments to create many AgentTemplates.
     * @example
     * // Create many AgentTemplates
     * const agentTemplate = await prisma.agentTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentTemplateCreateManyArgs>(args?: SelectSubset<T, AgentTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentTemplates and returns the data saved in the database.
     * @param {AgentTemplateCreateManyAndReturnArgs} args - Arguments to create many AgentTemplates.
     * @example
     * // Create many AgentTemplates
     * const agentTemplate = await prisma.agentTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentTemplates and only return the `id`
     * const agentTemplateWithIdOnly = await prisma.agentTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentTemplate.
     * @param {AgentTemplateDeleteArgs} args - Arguments to delete one AgentTemplate.
     * @example
     * // Delete one AgentTemplate
     * const AgentTemplate = await prisma.agentTemplate.delete({
     *   where: {
     *     // ... filter to delete one AgentTemplate
     *   }
     * })
     * 
     */
    delete<T extends AgentTemplateDeleteArgs>(args: SelectSubset<T, AgentTemplateDeleteArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentTemplate.
     * @param {AgentTemplateUpdateArgs} args - Arguments to update one AgentTemplate.
     * @example
     * // Update one AgentTemplate
     * const agentTemplate = await prisma.agentTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentTemplateUpdateArgs>(args: SelectSubset<T, AgentTemplateUpdateArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentTemplates.
     * @param {AgentTemplateDeleteManyArgs} args - Arguments to filter AgentTemplates to delete.
     * @example
     * // Delete a few AgentTemplates
     * const { count } = await prisma.agentTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentTemplateDeleteManyArgs>(args?: SelectSubset<T, AgentTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentTemplates
     * const agentTemplate = await prisma.agentTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentTemplateUpdateManyArgs>(args: SelectSubset<T, AgentTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTemplates and returns the data updated in the database.
     * @param {AgentTemplateUpdateManyAndReturnArgs} args - Arguments to update many AgentTemplates.
     * @example
     * // Update many AgentTemplates
     * const agentTemplate = await prisma.agentTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentTemplates and only return the `id`
     * const agentTemplateWithIdOnly = await prisma.agentTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentTemplate.
     * @param {AgentTemplateUpsertArgs} args - Arguments to update or create a AgentTemplate.
     * @example
     * // Update or create a AgentTemplate
     * const agentTemplate = await prisma.agentTemplate.upsert({
     *   create: {
     *     // ... data to create a AgentTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentTemplate we want to update
     *   }
     * })
     */
    upsert<T extends AgentTemplateUpsertArgs>(args: SelectSubset<T, AgentTemplateUpsertArgs<ExtArgs>>): Prisma__AgentTemplateClient<$Result.GetResult<Prisma.$AgentTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateCountArgs} args - Arguments to filter AgentTemplates to count.
     * @example
     * // Count the number of AgentTemplates
     * const count = await prisma.agentTemplate.count({
     *   where: {
     *     // ... the filter for the AgentTemplates we want to count
     *   }
     * })
    **/
    count<T extends AgentTemplateCountArgs>(
      args?: Subset<T, AgentTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentTemplateAggregateArgs>(args: Subset<T, AgentTemplateAggregateArgs>): Prisma.PrismaPromise<GetAgentTemplateAggregateType<T>>

    /**
     * Group by AgentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentTemplateGroupByArgs['orderBy'] }
        : { orderBy?: AgentTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentTemplate model
   */
  readonly fields: AgentTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agents<T extends AgentTemplate$agentsArgs<ExtArgs> = {}>(args?: Subset<T, AgentTemplate$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentTemplate model
   */
  interface AgentTemplateFieldRefs {
    readonly id: FieldRef<"AgentTemplate", 'String'>
    readonly slug: FieldRef<"AgentTemplate", 'String'>
    readonly name: FieldRef<"AgentTemplate", 'String'>
    readonly subtitle: FieldRef<"AgentTemplate", 'String'>
    readonly description: FieldRef<"AgentTemplate", 'String'>
    readonly category: FieldRef<"AgentTemplate", 'TemplateCategory'>
    readonly role: FieldRef<"AgentTemplate", 'TemplateRole'>
    readonly useCase: FieldRef<"AgentTemplate", 'TemplateUseCase'>
    readonly systemPrompt: FieldRef<"AgentTemplate", 'String'>
    readonly context: FieldRef<"AgentTemplate", 'String'>
    readonly model: FieldRef<"AgentTemplate", 'AgentModel'>
    readonly temperature: FieldRef<"AgentTemplate", 'Float'>
    readonly trigger: FieldRef<"AgentTemplate", 'Json'>
    readonly llmTier: FieldRef<"AgentTemplate", 'String'>
    readonly maxStepsPerRun: FieldRef<"AgentTemplate", 'Int'>
    readonly fetchSources: FieldRef<"AgentTemplate", 'Json'>
    readonly actions: FieldRef<"AgentTemplate", 'Json'>
    readonly evalRules: FieldRef<"AgentTemplate", 'Json'>
    readonly suggestedTools: FieldRef<"AgentTemplate", 'Json'>
    readonly suggestedTriggers: FieldRef<"AgentTemplate", 'Json'>
    readonly suggestedIntegrations: FieldRef<"AgentTemplate", 'String[]'>
    readonly flowData: FieldRef<"AgentTemplate", 'Json'>
    readonly defaultTriggers: FieldRef<"AgentTemplate", 'Json'>
    readonly defaultTools: FieldRef<"AgentTemplate", 'Json'>
    readonly icon: FieldRef<"AgentTemplate", 'String'>
    readonly color: FieldRef<"AgentTemplate", 'String'>
    readonly coverImage: FieldRef<"AgentTemplate", 'String'>
    readonly isPublic: FieldRef<"AgentTemplate", 'Boolean'>
    readonly isFeatured: FieldRef<"AgentTemplate", 'Boolean'>
    readonly createdById: FieldRef<"AgentTemplate", 'String'>
    readonly createdByName: FieldRef<"AgentTemplate", 'String'>
    readonly usageCount: FieldRef<"AgentTemplate", 'Int'>
    readonly rating: FieldRef<"AgentTemplate", 'Float'>
    readonly reviewCount: FieldRef<"AgentTemplate", 'Int'>
    readonly tags: FieldRef<"AgentTemplate", 'String[]'>
    readonly createdAt: FieldRef<"AgentTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentTemplate findUnique
   */
  export type AgentTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AgentTemplate to fetch.
     */
    where: AgentTemplateWhereUniqueInput
  }

  /**
   * AgentTemplate findUniqueOrThrow
   */
  export type AgentTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AgentTemplate to fetch.
     */
    where: AgentTemplateWhereUniqueInput
  }

  /**
   * AgentTemplate findFirst
   */
  export type AgentTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AgentTemplate to fetch.
     */
    where?: AgentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTemplates to fetch.
     */
    orderBy?: AgentTemplateOrderByWithRelationInput | AgentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTemplates.
     */
    cursor?: AgentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTemplates.
     */
    distinct?: AgentTemplateScalarFieldEnum | AgentTemplateScalarFieldEnum[]
  }

  /**
   * AgentTemplate findFirstOrThrow
   */
  export type AgentTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AgentTemplate to fetch.
     */
    where?: AgentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTemplates to fetch.
     */
    orderBy?: AgentTemplateOrderByWithRelationInput | AgentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTemplates.
     */
    cursor?: AgentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTemplates.
     */
    distinct?: AgentTemplateScalarFieldEnum | AgentTemplateScalarFieldEnum[]
  }

  /**
   * AgentTemplate findMany
   */
  export type AgentTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AgentTemplates to fetch.
     */
    where?: AgentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTemplates to fetch.
     */
    orderBy?: AgentTemplateOrderByWithRelationInput | AgentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentTemplates.
     */
    cursor?: AgentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTemplates.
     */
    skip?: number
    distinct?: AgentTemplateScalarFieldEnum | AgentTemplateScalarFieldEnum[]
  }

  /**
   * AgentTemplate create
   */
  export type AgentTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentTemplate.
     */
    data: XOR<AgentTemplateCreateInput, AgentTemplateUncheckedCreateInput>
  }

  /**
   * AgentTemplate createMany
   */
  export type AgentTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentTemplates.
     */
    data: AgentTemplateCreateManyInput | AgentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTemplate createManyAndReturn
   */
  export type AgentTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many AgentTemplates.
     */
    data: AgentTemplateCreateManyInput | AgentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTemplate update
   */
  export type AgentTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentTemplate.
     */
    data: XOR<AgentTemplateUpdateInput, AgentTemplateUncheckedUpdateInput>
    /**
     * Choose, which AgentTemplate to update.
     */
    where: AgentTemplateWhereUniqueInput
  }

  /**
   * AgentTemplate updateMany
   */
  export type AgentTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentTemplates.
     */
    data: XOR<AgentTemplateUpdateManyMutationInput, AgentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AgentTemplates to update
     */
    where?: AgentTemplateWhereInput
    /**
     * Limit how many AgentTemplates to update.
     */
    limit?: number
  }

  /**
   * AgentTemplate updateManyAndReturn
   */
  export type AgentTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * The data used to update AgentTemplates.
     */
    data: XOR<AgentTemplateUpdateManyMutationInput, AgentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AgentTemplates to update
     */
    where?: AgentTemplateWhereInput
    /**
     * Limit how many AgentTemplates to update.
     */
    limit?: number
  }

  /**
   * AgentTemplate upsert
   */
  export type AgentTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentTemplate to update in case it exists.
     */
    where: AgentTemplateWhereUniqueInput
    /**
     * In case the AgentTemplate found by the `where` argument doesn't exist, create a new AgentTemplate with this data.
     */
    create: XOR<AgentTemplateCreateInput, AgentTemplateUncheckedCreateInput>
    /**
     * In case the AgentTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentTemplateUpdateInput, AgentTemplateUncheckedUpdateInput>
  }

  /**
   * AgentTemplate delete
   */
  export type AgentTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
    /**
     * Filter which AgentTemplate to delete.
     */
    where: AgentTemplateWhereUniqueInput
  }

  /**
   * AgentTemplate deleteMany
   */
  export type AgentTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTemplates to delete
     */
    where?: AgentTemplateWhereInput
    /**
     * Limit how many AgentTemplates to delete.
     */
    limit?: number
  }

  /**
   * AgentTemplate.agents
   */
  export type AgentTemplate$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * AgentTemplate without action
   */
  export type AgentTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTemplate
     */
    select?: AgentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTemplate
     */
    omit?: AgentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTemplateInclude<ExtArgs> | null
  }


  /**
   * Model AgentEmbed
   */

  export type AggregateAgentEmbed = {
    _count: AgentEmbedCountAggregateOutputType | null
    _avg: AgentEmbedAvgAggregateOutputType | null
    _sum: AgentEmbedSumAggregateOutputType | null
    _min: AgentEmbedMinAggregateOutputType | null
    _max: AgentEmbedMaxAggregateOutputType | null
  }

  export type AgentEmbedAvgAggregateOutputType = {
    buttonSize: number | null
    windowWidth: number | null
    windowHeight: number | null
    autoOpenDelay: number | null
    totalConversations: number | null
  }

  export type AgentEmbedSumAggregateOutputType = {
    buttonSize: number | null
    windowWidth: number | null
    windowHeight: number | null
    autoOpenDelay: number | null
    totalConversations: number | null
  }

  export type AgentEmbedMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    enabled: boolean | null
    displayName: string | null
    welcomeMessage: string | null
    logo: string | null
    accentColor: string | null
    backgroundColor: string | null
    textColor: string | null
    userBubbleColor: string | null
    botBubbleColor: string | null
    position: $Enums.EmbedPosition | null
    buttonSize: number | null
    windowWidth: number | null
    windowHeight: number | null
    autoOpen: boolean | null
    autoOpenDelay: number | null
    showBranding: boolean | null
    collectEmail: boolean | null
    requireEmail: boolean | null
    customCss: string | null
    totalConversations: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentEmbedMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    enabled: boolean | null
    displayName: string | null
    welcomeMessage: string | null
    logo: string | null
    accentColor: string | null
    backgroundColor: string | null
    textColor: string | null
    userBubbleColor: string | null
    botBubbleColor: string | null
    position: $Enums.EmbedPosition | null
    buttonSize: number | null
    windowWidth: number | null
    windowHeight: number | null
    autoOpen: boolean | null
    autoOpenDelay: number | null
    showBranding: boolean | null
    collectEmail: boolean | null
    requireEmail: boolean | null
    customCss: string | null
    totalConversations: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentEmbedCountAggregateOutputType = {
    id: number
    agentId: number
    enabled: number
    allowedDomains: number
    displayName: number
    welcomeMessage: number
    logo: number
    accentColor: number
    backgroundColor: number
    textColor: number
    userBubbleColor: number
    botBubbleColor: number
    position: number
    buttonSize: number
    windowWidth: number
    windowHeight: number
    autoOpen: number
    autoOpenDelay: number
    showBranding: number
    collectEmail: number
    requireEmail: number
    conversationStarters: number
    customCss: number
    totalConversations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentEmbedAvgAggregateInputType = {
    buttonSize?: true
    windowWidth?: true
    windowHeight?: true
    autoOpenDelay?: true
    totalConversations?: true
  }

  export type AgentEmbedSumAggregateInputType = {
    buttonSize?: true
    windowWidth?: true
    windowHeight?: true
    autoOpenDelay?: true
    totalConversations?: true
  }

  export type AgentEmbedMinAggregateInputType = {
    id?: true
    agentId?: true
    enabled?: true
    displayName?: true
    welcomeMessage?: true
    logo?: true
    accentColor?: true
    backgroundColor?: true
    textColor?: true
    userBubbleColor?: true
    botBubbleColor?: true
    position?: true
    buttonSize?: true
    windowWidth?: true
    windowHeight?: true
    autoOpen?: true
    autoOpenDelay?: true
    showBranding?: true
    collectEmail?: true
    requireEmail?: true
    customCss?: true
    totalConversations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentEmbedMaxAggregateInputType = {
    id?: true
    agentId?: true
    enabled?: true
    displayName?: true
    welcomeMessage?: true
    logo?: true
    accentColor?: true
    backgroundColor?: true
    textColor?: true
    userBubbleColor?: true
    botBubbleColor?: true
    position?: true
    buttonSize?: true
    windowWidth?: true
    windowHeight?: true
    autoOpen?: true
    autoOpenDelay?: true
    showBranding?: true
    collectEmail?: true
    requireEmail?: true
    customCss?: true
    totalConversations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentEmbedCountAggregateInputType = {
    id?: true
    agentId?: true
    enabled?: true
    allowedDomains?: true
    displayName?: true
    welcomeMessage?: true
    logo?: true
    accentColor?: true
    backgroundColor?: true
    textColor?: true
    userBubbleColor?: true
    botBubbleColor?: true
    position?: true
    buttonSize?: true
    windowWidth?: true
    windowHeight?: true
    autoOpen?: true
    autoOpenDelay?: true
    showBranding?: true
    collectEmail?: true
    requireEmail?: true
    conversationStarters?: true
    customCss?: true
    totalConversations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentEmbedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentEmbed to aggregate.
     */
    where?: AgentEmbedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmbeds to fetch.
     */
    orderBy?: AgentEmbedOrderByWithRelationInput | AgentEmbedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentEmbedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmbeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentEmbeds
    **/
    _count?: true | AgentEmbedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentEmbedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentEmbedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentEmbedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentEmbedMaxAggregateInputType
  }

  export type GetAgentEmbedAggregateType<T extends AgentEmbedAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentEmbed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentEmbed[P]>
      : GetScalarType<T[P], AggregateAgentEmbed[P]>
  }




  export type AgentEmbedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentEmbedWhereInput
    orderBy?: AgentEmbedOrderByWithAggregationInput | AgentEmbedOrderByWithAggregationInput[]
    by: AgentEmbedScalarFieldEnum[] | AgentEmbedScalarFieldEnum
    having?: AgentEmbedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentEmbedCountAggregateInputType | true
    _avg?: AgentEmbedAvgAggregateInputType
    _sum?: AgentEmbedSumAggregateInputType
    _min?: AgentEmbedMinAggregateInputType
    _max?: AgentEmbedMaxAggregateInputType
  }

  export type AgentEmbedGroupByOutputType = {
    id: string
    agentId: string
    enabled: boolean
    allowedDomains: string[]
    displayName: string | null
    welcomeMessage: string | null
    logo: string | null
    accentColor: string
    backgroundColor: string
    textColor: string
    userBubbleColor: string
    botBubbleColor: string
    position: $Enums.EmbedPosition
    buttonSize: number
    windowWidth: number
    windowHeight: number
    autoOpen: boolean
    autoOpenDelay: number
    showBranding: boolean
    collectEmail: boolean
    requireEmail: boolean
    conversationStarters: JsonValue
    customCss: string | null
    totalConversations: number
    createdAt: Date
    updatedAt: Date
    _count: AgentEmbedCountAggregateOutputType | null
    _avg: AgentEmbedAvgAggregateOutputType | null
    _sum: AgentEmbedSumAggregateOutputType | null
    _min: AgentEmbedMinAggregateOutputType | null
    _max: AgentEmbedMaxAggregateOutputType | null
  }

  type GetAgentEmbedGroupByPayload<T extends AgentEmbedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentEmbedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentEmbedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentEmbedGroupByOutputType[P]>
            : GetScalarType<T[P], AgentEmbedGroupByOutputType[P]>
        }
      >
    >


  export type AgentEmbedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    enabled?: boolean
    allowedDomains?: boolean
    displayName?: boolean
    welcomeMessage?: boolean
    logo?: boolean
    accentColor?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    userBubbleColor?: boolean
    botBubbleColor?: boolean
    position?: boolean
    buttonSize?: boolean
    windowWidth?: boolean
    windowHeight?: boolean
    autoOpen?: boolean
    autoOpenDelay?: boolean
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: boolean
    customCss?: boolean
    totalConversations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentEmbed"]>

  export type AgentEmbedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    enabled?: boolean
    allowedDomains?: boolean
    displayName?: boolean
    welcomeMessage?: boolean
    logo?: boolean
    accentColor?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    userBubbleColor?: boolean
    botBubbleColor?: boolean
    position?: boolean
    buttonSize?: boolean
    windowWidth?: boolean
    windowHeight?: boolean
    autoOpen?: boolean
    autoOpenDelay?: boolean
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: boolean
    customCss?: boolean
    totalConversations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentEmbed"]>

  export type AgentEmbedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    enabled?: boolean
    allowedDomains?: boolean
    displayName?: boolean
    welcomeMessage?: boolean
    logo?: boolean
    accentColor?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    userBubbleColor?: boolean
    botBubbleColor?: boolean
    position?: boolean
    buttonSize?: boolean
    windowWidth?: boolean
    windowHeight?: boolean
    autoOpen?: boolean
    autoOpenDelay?: boolean
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: boolean
    customCss?: boolean
    totalConversations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentEmbed"]>

  export type AgentEmbedSelectScalar = {
    id?: boolean
    agentId?: boolean
    enabled?: boolean
    allowedDomains?: boolean
    displayName?: boolean
    welcomeMessage?: boolean
    logo?: boolean
    accentColor?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    userBubbleColor?: boolean
    botBubbleColor?: boolean
    position?: boolean
    buttonSize?: boolean
    windowWidth?: boolean
    windowHeight?: boolean
    autoOpen?: boolean
    autoOpenDelay?: boolean
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: boolean
    customCss?: boolean
    totalConversations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentEmbedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "enabled" | "allowedDomains" | "displayName" | "welcomeMessage" | "logo" | "accentColor" | "backgroundColor" | "textColor" | "userBubbleColor" | "botBubbleColor" | "position" | "buttonSize" | "windowWidth" | "windowHeight" | "autoOpen" | "autoOpenDelay" | "showBranding" | "collectEmail" | "requireEmail" | "conversationStarters" | "customCss" | "totalConversations" | "createdAt" | "updatedAt", ExtArgs["result"]["agentEmbed"]>
  export type AgentEmbedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentEmbedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentEmbedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentEmbedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentEmbed"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      enabled: boolean
      allowedDomains: string[]
      displayName: string | null
      welcomeMessage: string | null
      logo: string | null
      accentColor: string
      backgroundColor: string
      textColor: string
      userBubbleColor: string
      botBubbleColor: string
      position: $Enums.EmbedPosition
      buttonSize: number
      windowWidth: number
      windowHeight: number
      autoOpen: boolean
      autoOpenDelay: number
      showBranding: boolean
      collectEmail: boolean
      requireEmail: boolean
      conversationStarters: Prisma.JsonValue
      customCss: string | null
      totalConversations: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentEmbed"]>
    composites: {}
  }

  type AgentEmbedGetPayload<S extends boolean | null | undefined | AgentEmbedDefaultArgs> = $Result.GetResult<Prisma.$AgentEmbedPayload, S>

  type AgentEmbedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentEmbedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentEmbedCountAggregateInputType | true
    }

  export interface AgentEmbedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentEmbed'], meta: { name: 'AgentEmbed' } }
    /**
     * Find zero or one AgentEmbed that matches the filter.
     * @param {AgentEmbedFindUniqueArgs} args - Arguments to find a AgentEmbed
     * @example
     * // Get one AgentEmbed
     * const agentEmbed = await prisma.agentEmbed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentEmbedFindUniqueArgs>(args: SelectSubset<T, AgentEmbedFindUniqueArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentEmbed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentEmbedFindUniqueOrThrowArgs} args - Arguments to find a AgentEmbed
     * @example
     * // Get one AgentEmbed
     * const agentEmbed = await prisma.agentEmbed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentEmbedFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentEmbedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentEmbed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedFindFirstArgs} args - Arguments to find a AgentEmbed
     * @example
     * // Get one AgentEmbed
     * const agentEmbed = await prisma.agentEmbed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentEmbedFindFirstArgs>(args?: SelectSubset<T, AgentEmbedFindFirstArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentEmbed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedFindFirstOrThrowArgs} args - Arguments to find a AgentEmbed
     * @example
     * // Get one AgentEmbed
     * const agentEmbed = await prisma.agentEmbed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentEmbedFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentEmbedFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentEmbeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentEmbeds
     * const agentEmbeds = await prisma.agentEmbed.findMany()
     * 
     * // Get first 10 AgentEmbeds
     * const agentEmbeds = await prisma.agentEmbed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentEmbedWithIdOnly = await prisma.agentEmbed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentEmbedFindManyArgs>(args?: SelectSubset<T, AgentEmbedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentEmbed.
     * @param {AgentEmbedCreateArgs} args - Arguments to create a AgentEmbed.
     * @example
     * // Create one AgentEmbed
     * const AgentEmbed = await prisma.agentEmbed.create({
     *   data: {
     *     // ... data to create a AgentEmbed
     *   }
     * })
     * 
     */
    create<T extends AgentEmbedCreateArgs>(args: SelectSubset<T, AgentEmbedCreateArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentEmbeds.
     * @param {AgentEmbedCreateManyArgs} args - Arguments to create many AgentEmbeds.
     * @example
     * // Create many AgentEmbeds
     * const agentEmbed = await prisma.agentEmbed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentEmbedCreateManyArgs>(args?: SelectSubset<T, AgentEmbedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentEmbeds and returns the data saved in the database.
     * @param {AgentEmbedCreateManyAndReturnArgs} args - Arguments to create many AgentEmbeds.
     * @example
     * // Create many AgentEmbeds
     * const agentEmbed = await prisma.agentEmbed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentEmbeds and only return the `id`
     * const agentEmbedWithIdOnly = await prisma.agentEmbed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentEmbedCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentEmbedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentEmbed.
     * @param {AgentEmbedDeleteArgs} args - Arguments to delete one AgentEmbed.
     * @example
     * // Delete one AgentEmbed
     * const AgentEmbed = await prisma.agentEmbed.delete({
     *   where: {
     *     // ... filter to delete one AgentEmbed
     *   }
     * })
     * 
     */
    delete<T extends AgentEmbedDeleteArgs>(args: SelectSubset<T, AgentEmbedDeleteArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentEmbed.
     * @param {AgentEmbedUpdateArgs} args - Arguments to update one AgentEmbed.
     * @example
     * // Update one AgentEmbed
     * const agentEmbed = await prisma.agentEmbed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentEmbedUpdateArgs>(args: SelectSubset<T, AgentEmbedUpdateArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentEmbeds.
     * @param {AgentEmbedDeleteManyArgs} args - Arguments to filter AgentEmbeds to delete.
     * @example
     * // Delete a few AgentEmbeds
     * const { count } = await prisma.agentEmbed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentEmbedDeleteManyArgs>(args?: SelectSubset<T, AgentEmbedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentEmbeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentEmbeds
     * const agentEmbed = await prisma.agentEmbed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentEmbedUpdateManyArgs>(args: SelectSubset<T, AgentEmbedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentEmbeds and returns the data updated in the database.
     * @param {AgentEmbedUpdateManyAndReturnArgs} args - Arguments to update many AgentEmbeds.
     * @example
     * // Update many AgentEmbeds
     * const agentEmbed = await prisma.agentEmbed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentEmbeds and only return the `id`
     * const agentEmbedWithIdOnly = await prisma.agentEmbed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentEmbedUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentEmbedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentEmbed.
     * @param {AgentEmbedUpsertArgs} args - Arguments to update or create a AgentEmbed.
     * @example
     * // Update or create a AgentEmbed
     * const agentEmbed = await prisma.agentEmbed.upsert({
     *   create: {
     *     // ... data to create a AgentEmbed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentEmbed we want to update
     *   }
     * })
     */
    upsert<T extends AgentEmbedUpsertArgs>(args: SelectSubset<T, AgentEmbedUpsertArgs<ExtArgs>>): Prisma__AgentEmbedClient<$Result.GetResult<Prisma.$AgentEmbedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentEmbeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedCountArgs} args - Arguments to filter AgentEmbeds to count.
     * @example
     * // Count the number of AgentEmbeds
     * const count = await prisma.agentEmbed.count({
     *   where: {
     *     // ... the filter for the AgentEmbeds we want to count
     *   }
     * })
    **/
    count<T extends AgentEmbedCountArgs>(
      args?: Subset<T, AgentEmbedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentEmbedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentEmbed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentEmbedAggregateArgs>(args: Subset<T, AgentEmbedAggregateArgs>): Prisma.PrismaPromise<GetAgentEmbedAggregateType<T>>

    /**
     * Group by AgentEmbed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmbedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentEmbedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentEmbedGroupByArgs['orderBy'] }
        : { orderBy?: AgentEmbedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentEmbedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentEmbedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentEmbed model
   */
  readonly fields: AgentEmbedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentEmbed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentEmbedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentEmbed model
   */
  interface AgentEmbedFieldRefs {
    readonly id: FieldRef<"AgentEmbed", 'String'>
    readonly agentId: FieldRef<"AgentEmbed", 'String'>
    readonly enabled: FieldRef<"AgentEmbed", 'Boolean'>
    readonly allowedDomains: FieldRef<"AgentEmbed", 'String[]'>
    readonly displayName: FieldRef<"AgentEmbed", 'String'>
    readonly welcomeMessage: FieldRef<"AgentEmbed", 'String'>
    readonly logo: FieldRef<"AgentEmbed", 'String'>
    readonly accentColor: FieldRef<"AgentEmbed", 'String'>
    readonly backgroundColor: FieldRef<"AgentEmbed", 'String'>
    readonly textColor: FieldRef<"AgentEmbed", 'String'>
    readonly userBubbleColor: FieldRef<"AgentEmbed", 'String'>
    readonly botBubbleColor: FieldRef<"AgentEmbed", 'String'>
    readonly position: FieldRef<"AgentEmbed", 'EmbedPosition'>
    readonly buttonSize: FieldRef<"AgentEmbed", 'Int'>
    readonly windowWidth: FieldRef<"AgentEmbed", 'Int'>
    readonly windowHeight: FieldRef<"AgentEmbed", 'Int'>
    readonly autoOpen: FieldRef<"AgentEmbed", 'Boolean'>
    readonly autoOpenDelay: FieldRef<"AgentEmbed", 'Int'>
    readonly showBranding: FieldRef<"AgentEmbed", 'Boolean'>
    readonly collectEmail: FieldRef<"AgentEmbed", 'Boolean'>
    readonly requireEmail: FieldRef<"AgentEmbed", 'Boolean'>
    readonly conversationStarters: FieldRef<"AgentEmbed", 'Json'>
    readonly customCss: FieldRef<"AgentEmbed", 'String'>
    readonly totalConversations: FieldRef<"AgentEmbed", 'Int'>
    readonly createdAt: FieldRef<"AgentEmbed", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentEmbed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentEmbed findUnique
   */
  export type AgentEmbedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmbed to fetch.
     */
    where: AgentEmbedWhereUniqueInput
  }

  /**
   * AgentEmbed findUniqueOrThrow
   */
  export type AgentEmbedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmbed to fetch.
     */
    where: AgentEmbedWhereUniqueInput
  }

  /**
   * AgentEmbed findFirst
   */
  export type AgentEmbedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmbed to fetch.
     */
    where?: AgentEmbedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmbeds to fetch.
     */
    orderBy?: AgentEmbedOrderByWithRelationInput | AgentEmbedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentEmbeds.
     */
    cursor?: AgentEmbedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmbeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentEmbeds.
     */
    distinct?: AgentEmbedScalarFieldEnum | AgentEmbedScalarFieldEnum[]
  }

  /**
   * AgentEmbed findFirstOrThrow
   */
  export type AgentEmbedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmbed to fetch.
     */
    where?: AgentEmbedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmbeds to fetch.
     */
    orderBy?: AgentEmbedOrderByWithRelationInput | AgentEmbedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentEmbeds.
     */
    cursor?: AgentEmbedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmbeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentEmbeds.
     */
    distinct?: AgentEmbedScalarFieldEnum | AgentEmbedScalarFieldEnum[]
  }

  /**
   * AgentEmbed findMany
   */
  export type AgentEmbedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmbeds to fetch.
     */
    where?: AgentEmbedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmbeds to fetch.
     */
    orderBy?: AgentEmbedOrderByWithRelationInput | AgentEmbedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentEmbeds.
     */
    cursor?: AgentEmbedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmbeds.
     */
    skip?: number
    distinct?: AgentEmbedScalarFieldEnum | AgentEmbedScalarFieldEnum[]
  }

  /**
   * AgentEmbed create
   */
  export type AgentEmbedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentEmbed.
     */
    data: XOR<AgentEmbedCreateInput, AgentEmbedUncheckedCreateInput>
  }

  /**
   * AgentEmbed createMany
   */
  export type AgentEmbedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentEmbeds.
     */
    data: AgentEmbedCreateManyInput | AgentEmbedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentEmbed createManyAndReturn
   */
  export type AgentEmbedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * The data used to create many AgentEmbeds.
     */
    data: AgentEmbedCreateManyInput | AgentEmbedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentEmbed update
   */
  export type AgentEmbedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentEmbed.
     */
    data: XOR<AgentEmbedUpdateInput, AgentEmbedUncheckedUpdateInput>
    /**
     * Choose, which AgentEmbed to update.
     */
    where: AgentEmbedWhereUniqueInput
  }

  /**
   * AgentEmbed updateMany
   */
  export type AgentEmbedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentEmbeds.
     */
    data: XOR<AgentEmbedUpdateManyMutationInput, AgentEmbedUncheckedUpdateManyInput>
    /**
     * Filter which AgentEmbeds to update
     */
    where?: AgentEmbedWhereInput
    /**
     * Limit how many AgentEmbeds to update.
     */
    limit?: number
  }

  /**
   * AgentEmbed updateManyAndReturn
   */
  export type AgentEmbedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * The data used to update AgentEmbeds.
     */
    data: XOR<AgentEmbedUpdateManyMutationInput, AgentEmbedUncheckedUpdateManyInput>
    /**
     * Filter which AgentEmbeds to update
     */
    where?: AgentEmbedWhereInput
    /**
     * Limit how many AgentEmbeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentEmbed upsert
   */
  export type AgentEmbedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentEmbed to update in case it exists.
     */
    where: AgentEmbedWhereUniqueInput
    /**
     * In case the AgentEmbed found by the `where` argument doesn't exist, create a new AgentEmbed with this data.
     */
    create: XOR<AgentEmbedCreateInput, AgentEmbedUncheckedCreateInput>
    /**
     * In case the AgentEmbed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentEmbedUpdateInput, AgentEmbedUncheckedUpdateInput>
  }

  /**
   * AgentEmbed delete
   */
  export type AgentEmbedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
    /**
     * Filter which AgentEmbed to delete.
     */
    where: AgentEmbedWhereUniqueInput
  }

  /**
   * AgentEmbed deleteMany
   */
  export type AgentEmbedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentEmbeds to delete
     */
    where?: AgentEmbedWhereInput
    /**
     * Limit how many AgentEmbeds to delete.
     */
    limit?: number
  }

  /**
   * AgentEmbed without action
   */
  export type AgentEmbedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmbed
     */
    select?: AgentEmbedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmbed
     */
    omit?: AgentEmbedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmbedInclude<ExtArgs> | null
  }


  /**
   * Model AgentEmailAddress
   */

  export type AggregateAgentEmailAddress = {
    _count: AgentEmailAddressCountAggregateOutputType | null
    _min: AgentEmailAddressMinAggregateOutputType | null
    _max: AgentEmailAddressMaxAggregateOutputType | null
  }

  export type AgentEmailAddressMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    localPart: string | null
    domain: string | null
    autoReply: boolean | null
    createdAt: Date | null
  }

  export type AgentEmailAddressMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    localPart: string | null
    domain: string | null
    autoReply: boolean | null
    createdAt: Date | null
  }

  export type AgentEmailAddressCountAggregateOutputType = {
    id: number
    agentId: number
    localPart: number
    domain: number
    autoReply: number
    createdAt: number
    _all: number
  }


  export type AgentEmailAddressMinAggregateInputType = {
    id?: true
    agentId?: true
    localPart?: true
    domain?: true
    autoReply?: true
    createdAt?: true
  }

  export type AgentEmailAddressMaxAggregateInputType = {
    id?: true
    agentId?: true
    localPart?: true
    domain?: true
    autoReply?: true
    createdAt?: true
  }

  export type AgentEmailAddressCountAggregateInputType = {
    id?: true
    agentId?: true
    localPart?: true
    domain?: true
    autoReply?: true
    createdAt?: true
    _all?: true
  }

  export type AgentEmailAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentEmailAddress to aggregate.
     */
    where?: AgentEmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmailAddresses to fetch.
     */
    orderBy?: AgentEmailAddressOrderByWithRelationInput | AgentEmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentEmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentEmailAddresses
    **/
    _count?: true | AgentEmailAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentEmailAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentEmailAddressMaxAggregateInputType
  }

  export type GetAgentEmailAddressAggregateType<T extends AgentEmailAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentEmailAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentEmailAddress[P]>
      : GetScalarType<T[P], AggregateAgentEmailAddress[P]>
  }




  export type AgentEmailAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentEmailAddressWhereInput
    orderBy?: AgentEmailAddressOrderByWithAggregationInput | AgentEmailAddressOrderByWithAggregationInput[]
    by: AgentEmailAddressScalarFieldEnum[] | AgentEmailAddressScalarFieldEnum
    having?: AgentEmailAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentEmailAddressCountAggregateInputType | true
    _min?: AgentEmailAddressMinAggregateInputType
    _max?: AgentEmailAddressMaxAggregateInputType
  }

  export type AgentEmailAddressGroupByOutputType = {
    id: string
    agentId: string
    localPart: string
    domain: string
    autoReply: boolean
    createdAt: Date
    _count: AgentEmailAddressCountAggregateOutputType | null
    _min: AgentEmailAddressMinAggregateOutputType | null
    _max: AgentEmailAddressMaxAggregateOutputType | null
  }

  type GetAgentEmailAddressGroupByPayload<T extends AgentEmailAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentEmailAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentEmailAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentEmailAddressGroupByOutputType[P]>
            : GetScalarType<T[P], AgentEmailAddressGroupByOutputType[P]>
        }
      >
    >


  export type AgentEmailAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    localPart?: boolean
    domain?: boolean
    autoReply?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentEmailAddress"]>

  export type AgentEmailAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    localPart?: boolean
    domain?: boolean
    autoReply?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentEmailAddress"]>

  export type AgentEmailAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    localPart?: boolean
    domain?: boolean
    autoReply?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentEmailAddress"]>

  export type AgentEmailAddressSelectScalar = {
    id?: boolean
    agentId?: boolean
    localPart?: boolean
    domain?: boolean
    autoReply?: boolean
    createdAt?: boolean
  }

  export type AgentEmailAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "localPart" | "domain" | "autoReply" | "createdAt", ExtArgs["result"]["agentEmailAddress"]>
  export type AgentEmailAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentEmailAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentEmailAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentEmailAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentEmailAddress"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      localPart: string
      domain: string
      autoReply: boolean
      createdAt: Date
    }, ExtArgs["result"]["agentEmailAddress"]>
    composites: {}
  }

  type AgentEmailAddressGetPayload<S extends boolean | null | undefined | AgentEmailAddressDefaultArgs> = $Result.GetResult<Prisma.$AgentEmailAddressPayload, S>

  type AgentEmailAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentEmailAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentEmailAddressCountAggregateInputType | true
    }

  export interface AgentEmailAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentEmailAddress'], meta: { name: 'AgentEmailAddress' } }
    /**
     * Find zero or one AgentEmailAddress that matches the filter.
     * @param {AgentEmailAddressFindUniqueArgs} args - Arguments to find a AgentEmailAddress
     * @example
     * // Get one AgentEmailAddress
     * const agentEmailAddress = await prisma.agentEmailAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentEmailAddressFindUniqueArgs>(args: SelectSubset<T, AgentEmailAddressFindUniqueArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentEmailAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentEmailAddressFindUniqueOrThrowArgs} args - Arguments to find a AgentEmailAddress
     * @example
     * // Get one AgentEmailAddress
     * const agentEmailAddress = await prisma.agentEmailAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentEmailAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentEmailAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentEmailAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressFindFirstArgs} args - Arguments to find a AgentEmailAddress
     * @example
     * // Get one AgentEmailAddress
     * const agentEmailAddress = await prisma.agentEmailAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentEmailAddressFindFirstArgs>(args?: SelectSubset<T, AgentEmailAddressFindFirstArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentEmailAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressFindFirstOrThrowArgs} args - Arguments to find a AgentEmailAddress
     * @example
     * // Get one AgentEmailAddress
     * const agentEmailAddress = await prisma.agentEmailAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentEmailAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentEmailAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentEmailAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentEmailAddresses
     * const agentEmailAddresses = await prisma.agentEmailAddress.findMany()
     * 
     * // Get first 10 AgentEmailAddresses
     * const agentEmailAddresses = await prisma.agentEmailAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentEmailAddressWithIdOnly = await prisma.agentEmailAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentEmailAddressFindManyArgs>(args?: SelectSubset<T, AgentEmailAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentEmailAddress.
     * @param {AgentEmailAddressCreateArgs} args - Arguments to create a AgentEmailAddress.
     * @example
     * // Create one AgentEmailAddress
     * const AgentEmailAddress = await prisma.agentEmailAddress.create({
     *   data: {
     *     // ... data to create a AgentEmailAddress
     *   }
     * })
     * 
     */
    create<T extends AgentEmailAddressCreateArgs>(args: SelectSubset<T, AgentEmailAddressCreateArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentEmailAddresses.
     * @param {AgentEmailAddressCreateManyArgs} args - Arguments to create many AgentEmailAddresses.
     * @example
     * // Create many AgentEmailAddresses
     * const agentEmailAddress = await prisma.agentEmailAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentEmailAddressCreateManyArgs>(args?: SelectSubset<T, AgentEmailAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentEmailAddresses and returns the data saved in the database.
     * @param {AgentEmailAddressCreateManyAndReturnArgs} args - Arguments to create many AgentEmailAddresses.
     * @example
     * // Create many AgentEmailAddresses
     * const agentEmailAddress = await prisma.agentEmailAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentEmailAddresses and only return the `id`
     * const agentEmailAddressWithIdOnly = await prisma.agentEmailAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentEmailAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentEmailAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentEmailAddress.
     * @param {AgentEmailAddressDeleteArgs} args - Arguments to delete one AgentEmailAddress.
     * @example
     * // Delete one AgentEmailAddress
     * const AgentEmailAddress = await prisma.agentEmailAddress.delete({
     *   where: {
     *     // ... filter to delete one AgentEmailAddress
     *   }
     * })
     * 
     */
    delete<T extends AgentEmailAddressDeleteArgs>(args: SelectSubset<T, AgentEmailAddressDeleteArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentEmailAddress.
     * @param {AgentEmailAddressUpdateArgs} args - Arguments to update one AgentEmailAddress.
     * @example
     * // Update one AgentEmailAddress
     * const agentEmailAddress = await prisma.agentEmailAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentEmailAddressUpdateArgs>(args: SelectSubset<T, AgentEmailAddressUpdateArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentEmailAddresses.
     * @param {AgentEmailAddressDeleteManyArgs} args - Arguments to filter AgentEmailAddresses to delete.
     * @example
     * // Delete a few AgentEmailAddresses
     * const { count } = await prisma.agentEmailAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentEmailAddressDeleteManyArgs>(args?: SelectSubset<T, AgentEmailAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentEmailAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentEmailAddresses
     * const agentEmailAddress = await prisma.agentEmailAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentEmailAddressUpdateManyArgs>(args: SelectSubset<T, AgentEmailAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentEmailAddresses and returns the data updated in the database.
     * @param {AgentEmailAddressUpdateManyAndReturnArgs} args - Arguments to update many AgentEmailAddresses.
     * @example
     * // Update many AgentEmailAddresses
     * const agentEmailAddress = await prisma.agentEmailAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentEmailAddresses and only return the `id`
     * const agentEmailAddressWithIdOnly = await prisma.agentEmailAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentEmailAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentEmailAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentEmailAddress.
     * @param {AgentEmailAddressUpsertArgs} args - Arguments to update or create a AgentEmailAddress.
     * @example
     * // Update or create a AgentEmailAddress
     * const agentEmailAddress = await prisma.agentEmailAddress.upsert({
     *   create: {
     *     // ... data to create a AgentEmailAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentEmailAddress we want to update
     *   }
     * })
     */
    upsert<T extends AgentEmailAddressUpsertArgs>(args: SelectSubset<T, AgentEmailAddressUpsertArgs<ExtArgs>>): Prisma__AgentEmailAddressClient<$Result.GetResult<Prisma.$AgentEmailAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentEmailAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressCountArgs} args - Arguments to filter AgentEmailAddresses to count.
     * @example
     * // Count the number of AgentEmailAddresses
     * const count = await prisma.agentEmailAddress.count({
     *   where: {
     *     // ... the filter for the AgentEmailAddresses we want to count
     *   }
     * })
    **/
    count<T extends AgentEmailAddressCountArgs>(
      args?: Subset<T, AgentEmailAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentEmailAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentEmailAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentEmailAddressAggregateArgs>(args: Subset<T, AgentEmailAddressAggregateArgs>): Prisma.PrismaPromise<GetAgentEmailAddressAggregateType<T>>

    /**
     * Group by AgentEmailAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentEmailAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentEmailAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentEmailAddressGroupByArgs['orderBy'] }
        : { orderBy?: AgentEmailAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentEmailAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentEmailAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentEmailAddress model
   */
  readonly fields: AgentEmailAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentEmailAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentEmailAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentEmailAddress model
   */
  interface AgentEmailAddressFieldRefs {
    readonly id: FieldRef<"AgentEmailAddress", 'String'>
    readonly agentId: FieldRef<"AgentEmailAddress", 'String'>
    readonly localPart: FieldRef<"AgentEmailAddress", 'String'>
    readonly domain: FieldRef<"AgentEmailAddress", 'String'>
    readonly autoReply: FieldRef<"AgentEmailAddress", 'Boolean'>
    readonly createdAt: FieldRef<"AgentEmailAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentEmailAddress findUnique
   */
  export type AgentEmailAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmailAddress to fetch.
     */
    where: AgentEmailAddressWhereUniqueInput
  }

  /**
   * AgentEmailAddress findUniqueOrThrow
   */
  export type AgentEmailAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmailAddress to fetch.
     */
    where: AgentEmailAddressWhereUniqueInput
  }

  /**
   * AgentEmailAddress findFirst
   */
  export type AgentEmailAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmailAddress to fetch.
     */
    where?: AgentEmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmailAddresses to fetch.
     */
    orderBy?: AgentEmailAddressOrderByWithRelationInput | AgentEmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentEmailAddresses.
     */
    cursor?: AgentEmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentEmailAddresses.
     */
    distinct?: AgentEmailAddressScalarFieldEnum | AgentEmailAddressScalarFieldEnum[]
  }

  /**
   * AgentEmailAddress findFirstOrThrow
   */
  export type AgentEmailAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmailAddress to fetch.
     */
    where?: AgentEmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmailAddresses to fetch.
     */
    orderBy?: AgentEmailAddressOrderByWithRelationInput | AgentEmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentEmailAddresses.
     */
    cursor?: AgentEmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentEmailAddresses.
     */
    distinct?: AgentEmailAddressScalarFieldEnum | AgentEmailAddressScalarFieldEnum[]
  }

  /**
   * AgentEmailAddress findMany
   */
  export type AgentEmailAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which AgentEmailAddresses to fetch.
     */
    where?: AgentEmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentEmailAddresses to fetch.
     */
    orderBy?: AgentEmailAddressOrderByWithRelationInput | AgentEmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentEmailAddresses.
     */
    cursor?: AgentEmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentEmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentEmailAddresses.
     */
    skip?: number
    distinct?: AgentEmailAddressScalarFieldEnum | AgentEmailAddressScalarFieldEnum[]
  }

  /**
   * AgentEmailAddress create
   */
  export type AgentEmailAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentEmailAddress.
     */
    data: XOR<AgentEmailAddressCreateInput, AgentEmailAddressUncheckedCreateInput>
  }

  /**
   * AgentEmailAddress createMany
   */
  export type AgentEmailAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentEmailAddresses.
     */
    data: AgentEmailAddressCreateManyInput | AgentEmailAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentEmailAddress createManyAndReturn
   */
  export type AgentEmailAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * The data used to create many AgentEmailAddresses.
     */
    data: AgentEmailAddressCreateManyInput | AgentEmailAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentEmailAddress update
   */
  export type AgentEmailAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentEmailAddress.
     */
    data: XOR<AgentEmailAddressUpdateInput, AgentEmailAddressUncheckedUpdateInput>
    /**
     * Choose, which AgentEmailAddress to update.
     */
    where: AgentEmailAddressWhereUniqueInput
  }

  /**
   * AgentEmailAddress updateMany
   */
  export type AgentEmailAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentEmailAddresses.
     */
    data: XOR<AgentEmailAddressUpdateManyMutationInput, AgentEmailAddressUncheckedUpdateManyInput>
    /**
     * Filter which AgentEmailAddresses to update
     */
    where?: AgentEmailAddressWhereInput
    /**
     * Limit how many AgentEmailAddresses to update.
     */
    limit?: number
  }

  /**
   * AgentEmailAddress updateManyAndReturn
   */
  export type AgentEmailAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * The data used to update AgentEmailAddresses.
     */
    data: XOR<AgentEmailAddressUpdateManyMutationInput, AgentEmailAddressUncheckedUpdateManyInput>
    /**
     * Filter which AgentEmailAddresses to update
     */
    where?: AgentEmailAddressWhereInput
    /**
     * Limit how many AgentEmailAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentEmailAddress upsert
   */
  export type AgentEmailAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentEmailAddress to update in case it exists.
     */
    where: AgentEmailAddressWhereUniqueInput
    /**
     * In case the AgentEmailAddress found by the `where` argument doesn't exist, create a new AgentEmailAddress with this data.
     */
    create: XOR<AgentEmailAddressCreateInput, AgentEmailAddressUncheckedCreateInput>
    /**
     * In case the AgentEmailAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentEmailAddressUpdateInput, AgentEmailAddressUncheckedUpdateInput>
  }

  /**
   * AgentEmailAddress delete
   */
  export type AgentEmailAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
    /**
     * Filter which AgentEmailAddress to delete.
     */
    where: AgentEmailAddressWhereUniqueInput
  }

  /**
   * AgentEmailAddress deleteMany
   */
  export type AgentEmailAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentEmailAddresses to delete
     */
    where?: AgentEmailAddressWhereInput
    /**
     * Limit how many AgentEmailAddresses to delete.
     */
    limit?: number
  }

  /**
   * AgentEmailAddress without action
   */
  export type AgentEmailAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentEmailAddress
     */
    select?: AgentEmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentEmailAddress
     */
    omit?: AgentEmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentEmailAddressInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.IntegrationType | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    accountEmail: string | null
    accountName: string | null
    teamId: string | null
    teamName: string | null
    botUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.IntegrationType | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    accountEmail: string | null
    accountName: string | null
    teamId: string | null
    teamName: string | null
    botUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    accountEmail: number
    accountName: number
    scopes: number
    teamId: number
    teamName: number
    botUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    accountEmail?: true
    accountName?: true
    teamId?: true
    teamName?: true
    botUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    accountEmail?: true
    accountName?: true
    teamId?: true
    teamName?: true
    botUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    accountEmail?: true
    accountName?: true
    scopes?: true
    teamId?: true
    teamName?: true
    botUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken: string | null
    expiresAt: Date | null
    accountEmail: string | null
    accountName: string | null
    scopes: string[]
    teamId: string | null
    teamName: string | null
    botUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    accountEmail?: boolean
    accountName?: boolean
    scopes?: boolean
    teamId?: boolean
    teamName?: boolean
    botUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    accountEmail?: boolean
    accountName?: boolean
    scopes?: boolean
    teamId?: boolean
    teamName?: boolean
    botUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    accountEmail?: boolean
    accountName?: boolean
    scopes?: boolean
    teamId?: boolean
    teamName?: boolean
    botUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    accountEmail?: boolean
    accountName?: boolean
    scopes?: boolean
    teamId?: boolean
    teamName?: boolean
    botUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "accessToken" | "refreshToken" | "expiresAt" | "accountEmail" | "accountName" | "scopes" | "teamId" | "teamName" | "botUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.IntegrationType
      accessToken: string
      refreshToken: string | null
      expiresAt: Date | null
      accountEmail: string | null
      accountName: string | null
      scopes: string[]
      teamId: string | null
      teamName: string | null
      botUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {IntegrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly userId: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'IntegrationType'>
    readonly accessToken: FieldRef<"Integration", 'String'>
    readonly refreshToken: FieldRef<"Integration", 'String'>
    readonly expiresAt: FieldRef<"Integration", 'DateTime'>
    readonly accountEmail: FieldRef<"Integration", 'String'>
    readonly accountName: FieldRef<"Integration", 'String'>
    readonly scopes: FieldRef<"Integration", 'String[]'>
    readonly teamId: FieldRef<"Integration", 'String'>
    readonly teamName: FieldRef<"Integration", 'String'>
    readonly botUserId: FieldRef<"Integration", 'String'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration updateManyAndReturn
   */
  export type IntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model AgentSwarm
   */

  export type AggregateAgentSwarm = {
    _count: AgentSwarmCountAggregateOutputType | null
    _avg: AgentSwarmAvgAggregateOutputType | null
    _sum: AgentSwarmSumAggregateOutputType | null
    _min: AgentSwarmMinAggregateOutputType | null
    _max: AgentSwarmMaxAggregateOutputType | null
  }

  export type AgentSwarmAvgAggregateOutputType = {
    totalTasks: number | null
    completedTasks: number | null
    failedTasks: number | null
  }

  export type AgentSwarmSumAggregateOutputType = {
    totalTasks: number | null
    completedTasks: number | null
    failedTasks: number | null
  }

  export type AgentSwarmMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    name: string | null
    taskTemplate: string | null
    status: $Enums.SwarmStatus | null
    totalTasks: number | null
    completedTasks: number | null
    failedTasks: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentSwarmMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    name: string | null
    taskTemplate: string | null
    status: $Enums.SwarmStatus | null
    totalTasks: number | null
    completedTasks: number | null
    failedTasks: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentSwarmCountAggregateOutputType = {
    id: number
    agentId: number
    name: number
    taskTemplate: number
    status: number
    totalTasks: number
    completedTasks: number
    failedTasks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentSwarmAvgAggregateInputType = {
    totalTasks?: true
    completedTasks?: true
    failedTasks?: true
  }

  export type AgentSwarmSumAggregateInputType = {
    totalTasks?: true
    completedTasks?: true
    failedTasks?: true
  }

  export type AgentSwarmMinAggregateInputType = {
    id?: true
    agentId?: true
    name?: true
    taskTemplate?: true
    status?: true
    totalTasks?: true
    completedTasks?: true
    failedTasks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentSwarmMaxAggregateInputType = {
    id?: true
    agentId?: true
    name?: true
    taskTemplate?: true
    status?: true
    totalTasks?: true
    completedTasks?: true
    failedTasks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentSwarmCountAggregateInputType = {
    id?: true
    agentId?: true
    name?: true
    taskTemplate?: true
    status?: true
    totalTasks?: true
    completedTasks?: true
    failedTasks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentSwarmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentSwarm to aggregate.
     */
    where?: AgentSwarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSwarms to fetch.
     */
    orderBy?: AgentSwarmOrderByWithRelationInput | AgentSwarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentSwarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSwarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSwarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentSwarms
    **/
    _count?: true | AgentSwarmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentSwarmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSwarmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentSwarmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentSwarmMaxAggregateInputType
  }

  export type GetAgentSwarmAggregateType<T extends AgentSwarmAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentSwarm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentSwarm[P]>
      : GetScalarType<T[P], AggregateAgentSwarm[P]>
  }




  export type AgentSwarmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentSwarmWhereInput
    orderBy?: AgentSwarmOrderByWithAggregationInput | AgentSwarmOrderByWithAggregationInput[]
    by: AgentSwarmScalarFieldEnum[] | AgentSwarmScalarFieldEnum
    having?: AgentSwarmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentSwarmCountAggregateInputType | true
    _avg?: AgentSwarmAvgAggregateInputType
    _sum?: AgentSwarmSumAggregateInputType
    _min?: AgentSwarmMinAggregateInputType
    _max?: AgentSwarmMaxAggregateInputType
  }

  export type AgentSwarmGroupByOutputType = {
    id: string
    agentId: string
    name: string
    taskTemplate: string
    status: $Enums.SwarmStatus
    totalTasks: number
    completedTasks: number
    failedTasks: number
    createdAt: Date
    updatedAt: Date
    _count: AgentSwarmCountAggregateOutputType | null
    _avg: AgentSwarmAvgAggregateOutputType | null
    _sum: AgentSwarmSumAggregateOutputType | null
    _min: AgentSwarmMinAggregateOutputType | null
    _max: AgentSwarmMaxAggregateOutputType | null
  }

  type GetAgentSwarmGroupByPayload<T extends AgentSwarmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentSwarmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentSwarmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentSwarmGroupByOutputType[P]>
            : GetScalarType<T[P], AgentSwarmGroupByOutputType[P]>
        }
      >
    >


  export type AgentSwarmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    name?: boolean
    taskTemplate?: boolean
    status?: boolean
    totalTasks?: boolean
    completedTasks?: boolean
    failedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    tasks?: boolean | AgentSwarm$tasksArgs<ExtArgs>
    _count?: boolean | AgentSwarmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSwarm"]>

  export type AgentSwarmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    name?: boolean
    taskTemplate?: boolean
    status?: boolean
    totalTasks?: boolean
    completedTasks?: boolean
    failedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSwarm"]>

  export type AgentSwarmSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    name?: boolean
    taskTemplate?: boolean
    status?: boolean
    totalTasks?: boolean
    completedTasks?: boolean
    failedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSwarm"]>

  export type AgentSwarmSelectScalar = {
    id?: boolean
    agentId?: boolean
    name?: boolean
    taskTemplate?: boolean
    status?: boolean
    totalTasks?: boolean
    completedTasks?: boolean
    failedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentSwarmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "name" | "taskTemplate" | "status" | "totalTasks" | "completedTasks" | "failedTasks" | "createdAt" | "updatedAt", ExtArgs["result"]["agentSwarm"]>
  export type AgentSwarmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    tasks?: boolean | AgentSwarm$tasksArgs<ExtArgs>
    _count?: boolean | AgentSwarmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentSwarmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentSwarmIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentSwarmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentSwarm"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      tasks: Prisma.$SwarmTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      name: string
      taskTemplate: string
      status: $Enums.SwarmStatus
      totalTasks: number
      completedTasks: number
      failedTasks: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentSwarm"]>
    composites: {}
  }

  type AgentSwarmGetPayload<S extends boolean | null | undefined | AgentSwarmDefaultArgs> = $Result.GetResult<Prisma.$AgentSwarmPayload, S>

  type AgentSwarmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentSwarmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentSwarmCountAggregateInputType | true
    }

  export interface AgentSwarmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentSwarm'], meta: { name: 'AgentSwarm' } }
    /**
     * Find zero or one AgentSwarm that matches the filter.
     * @param {AgentSwarmFindUniqueArgs} args - Arguments to find a AgentSwarm
     * @example
     * // Get one AgentSwarm
     * const agentSwarm = await prisma.agentSwarm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentSwarmFindUniqueArgs>(args: SelectSubset<T, AgentSwarmFindUniqueArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentSwarm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentSwarmFindUniqueOrThrowArgs} args - Arguments to find a AgentSwarm
     * @example
     * // Get one AgentSwarm
     * const agentSwarm = await prisma.agentSwarm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentSwarmFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentSwarmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentSwarm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmFindFirstArgs} args - Arguments to find a AgentSwarm
     * @example
     * // Get one AgentSwarm
     * const agentSwarm = await prisma.agentSwarm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentSwarmFindFirstArgs>(args?: SelectSubset<T, AgentSwarmFindFirstArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentSwarm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmFindFirstOrThrowArgs} args - Arguments to find a AgentSwarm
     * @example
     * // Get one AgentSwarm
     * const agentSwarm = await prisma.agentSwarm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentSwarmFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentSwarmFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentSwarms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentSwarms
     * const agentSwarms = await prisma.agentSwarm.findMany()
     * 
     * // Get first 10 AgentSwarms
     * const agentSwarms = await prisma.agentSwarm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentSwarmWithIdOnly = await prisma.agentSwarm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentSwarmFindManyArgs>(args?: SelectSubset<T, AgentSwarmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentSwarm.
     * @param {AgentSwarmCreateArgs} args - Arguments to create a AgentSwarm.
     * @example
     * // Create one AgentSwarm
     * const AgentSwarm = await prisma.agentSwarm.create({
     *   data: {
     *     // ... data to create a AgentSwarm
     *   }
     * })
     * 
     */
    create<T extends AgentSwarmCreateArgs>(args: SelectSubset<T, AgentSwarmCreateArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentSwarms.
     * @param {AgentSwarmCreateManyArgs} args - Arguments to create many AgentSwarms.
     * @example
     * // Create many AgentSwarms
     * const agentSwarm = await prisma.agentSwarm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentSwarmCreateManyArgs>(args?: SelectSubset<T, AgentSwarmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentSwarms and returns the data saved in the database.
     * @param {AgentSwarmCreateManyAndReturnArgs} args - Arguments to create many AgentSwarms.
     * @example
     * // Create many AgentSwarms
     * const agentSwarm = await prisma.agentSwarm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentSwarms and only return the `id`
     * const agentSwarmWithIdOnly = await prisma.agentSwarm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentSwarmCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentSwarmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentSwarm.
     * @param {AgentSwarmDeleteArgs} args - Arguments to delete one AgentSwarm.
     * @example
     * // Delete one AgentSwarm
     * const AgentSwarm = await prisma.agentSwarm.delete({
     *   where: {
     *     // ... filter to delete one AgentSwarm
     *   }
     * })
     * 
     */
    delete<T extends AgentSwarmDeleteArgs>(args: SelectSubset<T, AgentSwarmDeleteArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentSwarm.
     * @param {AgentSwarmUpdateArgs} args - Arguments to update one AgentSwarm.
     * @example
     * // Update one AgentSwarm
     * const agentSwarm = await prisma.agentSwarm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentSwarmUpdateArgs>(args: SelectSubset<T, AgentSwarmUpdateArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentSwarms.
     * @param {AgentSwarmDeleteManyArgs} args - Arguments to filter AgentSwarms to delete.
     * @example
     * // Delete a few AgentSwarms
     * const { count } = await prisma.agentSwarm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentSwarmDeleteManyArgs>(args?: SelectSubset<T, AgentSwarmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentSwarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentSwarms
     * const agentSwarm = await prisma.agentSwarm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentSwarmUpdateManyArgs>(args: SelectSubset<T, AgentSwarmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentSwarms and returns the data updated in the database.
     * @param {AgentSwarmUpdateManyAndReturnArgs} args - Arguments to update many AgentSwarms.
     * @example
     * // Update many AgentSwarms
     * const agentSwarm = await prisma.agentSwarm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentSwarms and only return the `id`
     * const agentSwarmWithIdOnly = await prisma.agentSwarm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentSwarmUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentSwarmUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentSwarm.
     * @param {AgentSwarmUpsertArgs} args - Arguments to update or create a AgentSwarm.
     * @example
     * // Update or create a AgentSwarm
     * const agentSwarm = await prisma.agentSwarm.upsert({
     *   create: {
     *     // ... data to create a AgentSwarm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentSwarm we want to update
     *   }
     * })
     */
    upsert<T extends AgentSwarmUpsertArgs>(args: SelectSubset<T, AgentSwarmUpsertArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentSwarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmCountArgs} args - Arguments to filter AgentSwarms to count.
     * @example
     * // Count the number of AgentSwarms
     * const count = await prisma.agentSwarm.count({
     *   where: {
     *     // ... the filter for the AgentSwarms we want to count
     *   }
     * })
    **/
    count<T extends AgentSwarmCountArgs>(
      args?: Subset<T, AgentSwarmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentSwarmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentSwarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentSwarmAggregateArgs>(args: Subset<T, AgentSwarmAggregateArgs>): Prisma.PrismaPromise<GetAgentSwarmAggregateType<T>>

    /**
     * Group by AgentSwarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSwarmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentSwarmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentSwarmGroupByArgs['orderBy'] }
        : { orderBy?: AgentSwarmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentSwarmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentSwarmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentSwarm model
   */
  readonly fields: AgentSwarmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentSwarm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentSwarmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends AgentSwarm$tasksArgs<ExtArgs> = {}>(args?: Subset<T, AgentSwarm$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentSwarm model
   */
  interface AgentSwarmFieldRefs {
    readonly id: FieldRef<"AgentSwarm", 'String'>
    readonly agentId: FieldRef<"AgentSwarm", 'String'>
    readonly name: FieldRef<"AgentSwarm", 'String'>
    readonly taskTemplate: FieldRef<"AgentSwarm", 'String'>
    readonly status: FieldRef<"AgentSwarm", 'SwarmStatus'>
    readonly totalTasks: FieldRef<"AgentSwarm", 'Int'>
    readonly completedTasks: FieldRef<"AgentSwarm", 'Int'>
    readonly failedTasks: FieldRef<"AgentSwarm", 'Int'>
    readonly createdAt: FieldRef<"AgentSwarm", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentSwarm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentSwarm findUnique
   */
  export type AgentSwarmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * Filter, which AgentSwarm to fetch.
     */
    where: AgentSwarmWhereUniqueInput
  }

  /**
   * AgentSwarm findUniqueOrThrow
   */
  export type AgentSwarmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * Filter, which AgentSwarm to fetch.
     */
    where: AgentSwarmWhereUniqueInput
  }

  /**
   * AgentSwarm findFirst
   */
  export type AgentSwarmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * Filter, which AgentSwarm to fetch.
     */
    where?: AgentSwarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSwarms to fetch.
     */
    orderBy?: AgentSwarmOrderByWithRelationInput | AgentSwarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentSwarms.
     */
    cursor?: AgentSwarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSwarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSwarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentSwarms.
     */
    distinct?: AgentSwarmScalarFieldEnum | AgentSwarmScalarFieldEnum[]
  }

  /**
   * AgentSwarm findFirstOrThrow
   */
  export type AgentSwarmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * Filter, which AgentSwarm to fetch.
     */
    where?: AgentSwarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSwarms to fetch.
     */
    orderBy?: AgentSwarmOrderByWithRelationInput | AgentSwarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentSwarms.
     */
    cursor?: AgentSwarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSwarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSwarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentSwarms.
     */
    distinct?: AgentSwarmScalarFieldEnum | AgentSwarmScalarFieldEnum[]
  }

  /**
   * AgentSwarm findMany
   */
  export type AgentSwarmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * Filter, which AgentSwarms to fetch.
     */
    where?: AgentSwarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSwarms to fetch.
     */
    orderBy?: AgentSwarmOrderByWithRelationInput | AgentSwarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentSwarms.
     */
    cursor?: AgentSwarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSwarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSwarms.
     */
    skip?: number
    distinct?: AgentSwarmScalarFieldEnum | AgentSwarmScalarFieldEnum[]
  }

  /**
   * AgentSwarm create
   */
  export type AgentSwarmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentSwarm.
     */
    data: XOR<AgentSwarmCreateInput, AgentSwarmUncheckedCreateInput>
  }

  /**
   * AgentSwarm createMany
   */
  export type AgentSwarmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentSwarms.
     */
    data: AgentSwarmCreateManyInput | AgentSwarmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentSwarm createManyAndReturn
   */
  export type AgentSwarmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * The data used to create many AgentSwarms.
     */
    data: AgentSwarmCreateManyInput | AgentSwarmCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentSwarm update
   */
  export type AgentSwarmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentSwarm.
     */
    data: XOR<AgentSwarmUpdateInput, AgentSwarmUncheckedUpdateInput>
    /**
     * Choose, which AgentSwarm to update.
     */
    where: AgentSwarmWhereUniqueInput
  }

  /**
   * AgentSwarm updateMany
   */
  export type AgentSwarmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentSwarms.
     */
    data: XOR<AgentSwarmUpdateManyMutationInput, AgentSwarmUncheckedUpdateManyInput>
    /**
     * Filter which AgentSwarms to update
     */
    where?: AgentSwarmWhereInput
    /**
     * Limit how many AgentSwarms to update.
     */
    limit?: number
  }

  /**
   * AgentSwarm updateManyAndReturn
   */
  export type AgentSwarmUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * The data used to update AgentSwarms.
     */
    data: XOR<AgentSwarmUpdateManyMutationInput, AgentSwarmUncheckedUpdateManyInput>
    /**
     * Filter which AgentSwarms to update
     */
    where?: AgentSwarmWhereInput
    /**
     * Limit how many AgentSwarms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentSwarm upsert
   */
  export type AgentSwarmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentSwarm to update in case it exists.
     */
    where: AgentSwarmWhereUniqueInput
    /**
     * In case the AgentSwarm found by the `where` argument doesn't exist, create a new AgentSwarm with this data.
     */
    create: XOR<AgentSwarmCreateInput, AgentSwarmUncheckedCreateInput>
    /**
     * In case the AgentSwarm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentSwarmUpdateInput, AgentSwarmUncheckedUpdateInput>
  }

  /**
   * AgentSwarm delete
   */
  export type AgentSwarmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
    /**
     * Filter which AgentSwarm to delete.
     */
    where: AgentSwarmWhereUniqueInput
  }

  /**
   * AgentSwarm deleteMany
   */
  export type AgentSwarmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentSwarms to delete
     */
    where?: AgentSwarmWhereInput
    /**
     * Limit how many AgentSwarms to delete.
     */
    limit?: number
  }

  /**
   * AgentSwarm.tasks
   */
  export type AgentSwarm$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    where?: SwarmTaskWhereInput
    orderBy?: SwarmTaskOrderByWithRelationInput | SwarmTaskOrderByWithRelationInput[]
    cursor?: SwarmTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SwarmTaskScalarFieldEnum | SwarmTaskScalarFieldEnum[]
  }

  /**
   * AgentSwarm without action
   */
  export type AgentSwarmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSwarm
     */
    select?: AgentSwarmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSwarm
     */
    omit?: AgentSwarmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSwarmInclude<ExtArgs> | null
  }


  /**
   * Model SwarmTask
   */

  export type AggregateSwarmTask = {
    _count: SwarmTaskCountAggregateOutputType | null
    _min: SwarmTaskMinAggregateOutputType | null
    _max: SwarmTaskMaxAggregateOutputType | null
  }

  export type SwarmTaskMinAggregateOutputType = {
    id: string | null
    swarmId: string | null
    status: $Enums.SwarmTaskStatus | null
    output: string | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type SwarmTaskMaxAggregateOutputType = {
    id: string | null
    swarmId: string | null
    status: $Enums.SwarmTaskStatus | null
    output: string | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type SwarmTaskCountAggregateOutputType = {
    id: number
    swarmId: number
    input: number
    status: number
    output: number
    error: number
    startedAt: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type SwarmTaskMinAggregateInputType = {
    id?: true
    swarmId?: true
    status?: true
    output?: true
    error?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type SwarmTaskMaxAggregateInputType = {
    id?: true
    swarmId?: true
    status?: true
    output?: true
    error?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type SwarmTaskCountAggregateInputType = {
    id?: true
    swarmId?: true
    input?: true
    status?: true
    output?: true
    error?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SwarmTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SwarmTask to aggregate.
     */
    where?: SwarmTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwarmTasks to fetch.
     */
    orderBy?: SwarmTaskOrderByWithRelationInput | SwarmTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SwarmTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwarmTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwarmTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SwarmTasks
    **/
    _count?: true | SwarmTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SwarmTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SwarmTaskMaxAggregateInputType
  }

  export type GetSwarmTaskAggregateType<T extends SwarmTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateSwarmTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSwarmTask[P]>
      : GetScalarType<T[P], AggregateSwarmTask[P]>
  }




  export type SwarmTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwarmTaskWhereInput
    orderBy?: SwarmTaskOrderByWithAggregationInput | SwarmTaskOrderByWithAggregationInput[]
    by: SwarmTaskScalarFieldEnum[] | SwarmTaskScalarFieldEnum
    having?: SwarmTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SwarmTaskCountAggregateInputType | true
    _min?: SwarmTaskMinAggregateInputType
    _max?: SwarmTaskMaxAggregateInputType
  }

  export type SwarmTaskGroupByOutputType = {
    id: string
    swarmId: string
    input: JsonValue
    status: $Enums.SwarmTaskStatus
    output: string | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    _count: SwarmTaskCountAggregateOutputType | null
    _min: SwarmTaskMinAggregateOutputType | null
    _max: SwarmTaskMaxAggregateOutputType | null
  }

  type GetSwarmTaskGroupByPayload<T extends SwarmTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SwarmTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SwarmTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SwarmTaskGroupByOutputType[P]>
            : GetScalarType<T[P], SwarmTaskGroupByOutputType[P]>
        }
      >
    >


  export type SwarmTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    swarmId?: boolean
    input?: boolean
    status?: boolean
    output?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    swarm?: boolean | AgentSwarmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["swarmTask"]>

  export type SwarmTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    swarmId?: boolean
    input?: boolean
    status?: boolean
    output?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    swarm?: boolean | AgentSwarmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["swarmTask"]>

  export type SwarmTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    swarmId?: boolean
    input?: boolean
    status?: boolean
    output?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    swarm?: boolean | AgentSwarmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["swarmTask"]>

  export type SwarmTaskSelectScalar = {
    id?: boolean
    swarmId?: boolean
    input?: boolean
    status?: boolean
    output?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type SwarmTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "swarmId" | "input" | "status" | "output" | "error" | "startedAt" | "completedAt" | "createdAt", ExtArgs["result"]["swarmTask"]>
  export type SwarmTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    swarm?: boolean | AgentSwarmDefaultArgs<ExtArgs>
  }
  export type SwarmTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    swarm?: boolean | AgentSwarmDefaultArgs<ExtArgs>
  }
  export type SwarmTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    swarm?: boolean | AgentSwarmDefaultArgs<ExtArgs>
  }

  export type $SwarmTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SwarmTask"
    objects: {
      swarm: Prisma.$AgentSwarmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      swarmId: string
      input: Prisma.JsonValue
      status: $Enums.SwarmTaskStatus
      output: string | null
      error: string | null
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["swarmTask"]>
    composites: {}
  }

  type SwarmTaskGetPayload<S extends boolean | null | undefined | SwarmTaskDefaultArgs> = $Result.GetResult<Prisma.$SwarmTaskPayload, S>

  type SwarmTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SwarmTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SwarmTaskCountAggregateInputType | true
    }

  export interface SwarmTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SwarmTask'], meta: { name: 'SwarmTask' } }
    /**
     * Find zero or one SwarmTask that matches the filter.
     * @param {SwarmTaskFindUniqueArgs} args - Arguments to find a SwarmTask
     * @example
     * // Get one SwarmTask
     * const swarmTask = await prisma.swarmTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SwarmTaskFindUniqueArgs>(args: SelectSubset<T, SwarmTaskFindUniqueArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SwarmTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SwarmTaskFindUniqueOrThrowArgs} args - Arguments to find a SwarmTask
     * @example
     * // Get one SwarmTask
     * const swarmTask = await prisma.swarmTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SwarmTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, SwarmTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SwarmTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskFindFirstArgs} args - Arguments to find a SwarmTask
     * @example
     * // Get one SwarmTask
     * const swarmTask = await prisma.swarmTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SwarmTaskFindFirstArgs>(args?: SelectSubset<T, SwarmTaskFindFirstArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SwarmTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskFindFirstOrThrowArgs} args - Arguments to find a SwarmTask
     * @example
     * // Get one SwarmTask
     * const swarmTask = await prisma.swarmTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SwarmTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, SwarmTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SwarmTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SwarmTasks
     * const swarmTasks = await prisma.swarmTask.findMany()
     * 
     * // Get first 10 SwarmTasks
     * const swarmTasks = await prisma.swarmTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const swarmTaskWithIdOnly = await prisma.swarmTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SwarmTaskFindManyArgs>(args?: SelectSubset<T, SwarmTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SwarmTask.
     * @param {SwarmTaskCreateArgs} args - Arguments to create a SwarmTask.
     * @example
     * // Create one SwarmTask
     * const SwarmTask = await prisma.swarmTask.create({
     *   data: {
     *     // ... data to create a SwarmTask
     *   }
     * })
     * 
     */
    create<T extends SwarmTaskCreateArgs>(args: SelectSubset<T, SwarmTaskCreateArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SwarmTasks.
     * @param {SwarmTaskCreateManyArgs} args - Arguments to create many SwarmTasks.
     * @example
     * // Create many SwarmTasks
     * const swarmTask = await prisma.swarmTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SwarmTaskCreateManyArgs>(args?: SelectSubset<T, SwarmTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SwarmTasks and returns the data saved in the database.
     * @param {SwarmTaskCreateManyAndReturnArgs} args - Arguments to create many SwarmTasks.
     * @example
     * // Create many SwarmTasks
     * const swarmTask = await prisma.swarmTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SwarmTasks and only return the `id`
     * const swarmTaskWithIdOnly = await prisma.swarmTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SwarmTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, SwarmTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SwarmTask.
     * @param {SwarmTaskDeleteArgs} args - Arguments to delete one SwarmTask.
     * @example
     * // Delete one SwarmTask
     * const SwarmTask = await prisma.swarmTask.delete({
     *   where: {
     *     // ... filter to delete one SwarmTask
     *   }
     * })
     * 
     */
    delete<T extends SwarmTaskDeleteArgs>(args: SelectSubset<T, SwarmTaskDeleteArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SwarmTask.
     * @param {SwarmTaskUpdateArgs} args - Arguments to update one SwarmTask.
     * @example
     * // Update one SwarmTask
     * const swarmTask = await prisma.swarmTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SwarmTaskUpdateArgs>(args: SelectSubset<T, SwarmTaskUpdateArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SwarmTasks.
     * @param {SwarmTaskDeleteManyArgs} args - Arguments to filter SwarmTasks to delete.
     * @example
     * // Delete a few SwarmTasks
     * const { count } = await prisma.swarmTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SwarmTaskDeleteManyArgs>(args?: SelectSubset<T, SwarmTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SwarmTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SwarmTasks
     * const swarmTask = await prisma.swarmTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SwarmTaskUpdateManyArgs>(args: SelectSubset<T, SwarmTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SwarmTasks and returns the data updated in the database.
     * @param {SwarmTaskUpdateManyAndReturnArgs} args - Arguments to update many SwarmTasks.
     * @example
     * // Update many SwarmTasks
     * const swarmTask = await prisma.swarmTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SwarmTasks and only return the `id`
     * const swarmTaskWithIdOnly = await prisma.swarmTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SwarmTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, SwarmTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SwarmTask.
     * @param {SwarmTaskUpsertArgs} args - Arguments to update or create a SwarmTask.
     * @example
     * // Update or create a SwarmTask
     * const swarmTask = await prisma.swarmTask.upsert({
     *   create: {
     *     // ... data to create a SwarmTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SwarmTask we want to update
     *   }
     * })
     */
    upsert<T extends SwarmTaskUpsertArgs>(args: SelectSubset<T, SwarmTaskUpsertArgs<ExtArgs>>): Prisma__SwarmTaskClient<$Result.GetResult<Prisma.$SwarmTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SwarmTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskCountArgs} args - Arguments to filter SwarmTasks to count.
     * @example
     * // Count the number of SwarmTasks
     * const count = await prisma.swarmTask.count({
     *   where: {
     *     // ... the filter for the SwarmTasks we want to count
     *   }
     * })
    **/
    count<T extends SwarmTaskCountArgs>(
      args?: Subset<T, SwarmTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SwarmTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SwarmTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SwarmTaskAggregateArgs>(args: Subset<T, SwarmTaskAggregateArgs>): Prisma.PrismaPromise<GetSwarmTaskAggregateType<T>>

    /**
     * Group by SwarmTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwarmTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SwarmTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SwarmTaskGroupByArgs['orderBy'] }
        : { orderBy?: SwarmTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SwarmTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSwarmTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SwarmTask model
   */
  readonly fields: SwarmTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SwarmTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SwarmTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    swarm<T extends AgentSwarmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentSwarmDefaultArgs<ExtArgs>>): Prisma__AgentSwarmClient<$Result.GetResult<Prisma.$AgentSwarmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SwarmTask model
   */
  interface SwarmTaskFieldRefs {
    readonly id: FieldRef<"SwarmTask", 'String'>
    readonly swarmId: FieldRef<"SwarmTask", 'String'>
    readonly input: FieldRef<"SwarmTask", 'Json'>
    readonly status: FieldRef<"SwarmTask", 'SwarmTaskStatus'>
    readonly output: FieldRef<"SwarmTask", 'String'>
    readonly error: FieldRef<"SwarmTask", 'String'>
    readonly startedAt: FieldRef<"SwarmTask", 'DateTime'>
    readonly completedAt: FieldRef<"SwarmTask", 'DateTime'>
    readonly createdAt: FieldRef<"SwarmTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SwarmTask findUnique
   */
  export type SwarmTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * Filter, which SwarmTask to fetch.
     */
    where: SwarmTaskWhereUniqueInput
  }

  /**
   * SwarmTask findUniqueOrThrow
   */
  export type SwarmTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * Filter, which SwarmTask to fetch.
     */
    where: SwarmTaskWhereUniqueInput
  }

  /**
   * SwarmTask findFirst
   */
  export type SwarmTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * Filter, which SwarmTask to fetch.
     */
    where?: SwarmTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwarmTasks to fetch.
     */
    orderBy?: SwarmTaskOrderByWithRelationInput | SwarmTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SwarmTasks.
     */
    cursor?: SwarmTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwarmTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwarmTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SwarmTasks.
     */
    distinct?: SwarmTaskScalarFieldEnum | SwarmTaskScalarFieldEnum[]
  }

  /**
   * SwarmTask findFirstOrThrow
   */
  export type SwarmTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * Filter, which SwarmTask to fetch.
     */
    where?: SwarmTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwarmTasks to fetch.
     */
    orderBy?: SwarmTaskOrderByWithRelationInput | SwarmTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SwarmTasks.
     */
    cursor?: SwarmTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwarmTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwarmTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SwarmTasks.
     */
    distinct?: SwarmTaskScalarFieldEnum | SwarmTaskScalarFieldEnum[]
  }

  /**
   * SwarmTask findMany
   */
  export type SwarmTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * Filter, which SwarmTasks to fetch.
     */
    where?: SwarmTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwarmTasks to fetch.
     */
    orderBy?: SwarmTaskOrderByWithRelationInput | SwarmTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SwarmTasks.
     */
    cursor?: SwarmTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwarmTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwarmTasks.
     */
    skip?: number
    distinct?: SwarmTaskScalarFieldEnum | SwarmTaskScalarFieldEnum[]
  }

  /**
   * SwarmTask create
   */
  export type SwarmTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a SwarmTask.
     */
    data: XOR<SwarmTaskCreateInput, SwarmTaskUncheckedCreateInput>
  }

  /**
   * SwarmTask createMany
   */
  export type SwarmTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SwarmTasks.
     */
    data: SwarmTaskCreateManyInput | SwarmTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SwarmTask createManyAndReturn
   */
  export type SwarmTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * The data used to create many SwarmTasks.
     */
    data: SwarmTaskCreateManyInput | SwarmTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SwarmTask update
   */
  export type SwarmTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a SwarmTask.
     */
    data: XOR<SwarmTaskUpdateInput, SwarmTaskUncheckedUpdateInput>
    /**
     * Choose, which SwarmTask to update.
     */
    where: SwarmTaskWhereUniqueInput
  }

  /**
   * SwarmTask updateMany
   */
  export type SwarmTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SwarmTasks.
     */
    data: XOR<SwarmTaskUpdateManyMutationInput, SwarmTaskUncheckedUpdateManyInput>
    /**
     * Filter which SwarmTasks to update
     */
    where?: SwarmTaskWhereInput
    /**
     * Limit how many SwarmTasks to update.
     */
    limit?: number
  }

  /**
   * SwarmTask updateManyAndReturn
   */
  export type SwarmTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * The data used to update SwarmTasks.
     */
    data: XOR<SwarmTaskUpdateManyMutationInput, SwarmTaskUncheckedUpdateManyInput>
    /**
     * Filter which SwarmTasks to update
     */
    where?: SwarmTaskWhereInput
    /**
     * Limit how many SwarmTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SwarmTask upsert
   */
  export type SwarmTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the SwarmTask to update in case it exists.
     */
    where: SwarmTaskWhereUniqueInput
    /**
     * In case the SwarmTask found by the `where` argument doesn't exist, create a new SwarmTask with this data.
     */
    create: XOR<SwarmTaskCreateInput, SwarmTaskUncheckedCreateInput>
    /**
     * In case the SwarmTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SwarmTaskUpdateInput, SwarmTaskUncheckedUpdateInput>
  }

  /**
   * SwarmTask delete
   */
  export type SwarmTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
    /**
     * Filter which SwarmTask to delete.
     */
    where: SwarmTaskWhereUniqueInput
  }

  /**
   * SwarmTask deleteMany
   */
  export type SwarmTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SwarmTasks to delete
     */
    where?: SwarmTaskWhereInput
    /**
     * Limit how many SwarmTasks to delete.
     */
    limit?: number
  }

  /**
   * SwarmTask without action
   */
  export type SwarmTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwarmTask
     */
    select?: SwarmTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwarmTask
     */
    omit?: SwarmTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwarmTaskInclude<ExtArgs> | null
  }


  /**
   * Model MeetingRecording
   */

  export type AggregateMeetingRecording = {
    _count: MeetingRecordingCountAggregateOutputType | null
    _avg: MeetingRecordingAvgAggregateOutputType | null
    _sum: MeetingRecordingSumAggregateOutputType | null
    _min: MeetingRecordingMinAggregateOutputType | null
    _max: MeetingRecordingMaxAggregateOutputType | null
  }

  export type MeetingRecordingAvgAggregateOutputType = {
    duration: number | null
  }

  export type MeetingRecordingSumAggregateOutputType = {
    duration: number | null
  }

  export type MeetingRecordingMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    meetingUrl: string | null
    meetingPlatform: $Enums.MeetingPlatform | null
    calendarEventId: string | null
    status: $Enums.RecordingStatus | null
    recordingUrl: string | null
    transcript: string | null
    summary: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingRecordingMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    meetingUrl: string | null
    meetingPlatform: $Enums.MeetingPlatform | null
    calendarEventId: string | null
    status: $Enums.RecordingStatus | null
    recordingUrl: string | null
    transcript: string | null
    summary: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingRecordingCountAggregateOutputType = {
    id: number
    agentId: number
    title: number
    meetingUrl: number
    meetingPlatform: number
    calendarEventId: number
    status: number
    recordingUrl: number
    transcript: number
    summary: number
    actionItems: number
    participants: number
    scheduledAt: number
    startedAt: number
    endedAt: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingRecordingAvgAggregateInputType = {
    duration?: true
  }

  export type MeetingRecordingSumAggregateInputType = {
    duration?: true
  }

  export type MeetingRecordingMinAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    meetingUrl?: true
    meetingPlatform?: true
    calendarEventId?: true
    status?: true
    recordingUrl?: true
    transcript?: true
    summary?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingRecordingMaxAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    meetingUrl?: true
    meetingPlatform?: true
    calendarEventId?: true
    status?: true
    recordingUrl?: true
    transcript?: true
    summary?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingRecordingCountAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    meetingUrl?: true
    meetingPlatform?: true
    calendarEventId?: true
    status?: true
    recordingUrl?: true
    transcript?: true
    summary?: true
    actionItems?: true
    participants?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingRecordingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingRecording to aggregate.
     */
    where?: MeetingRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRecordings to fetch.
     */
    orderBy?: MeetingRecordingOrderByWithRelationInput | MeetingRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingRecordings
    **/
    _count?: true | MeetingRecordingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingRecordingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingRecordingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingRecordingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingRecordingMaxAggregateInputType
  }

  export type GetMeetingRecordingAggregateType<T extends MeetingRecordingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingRecording]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingRecording[P]>
      : GetScalarType<T[P], AggregateMeetingRecording[P]>
  }




  export type MeetingRecordingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingRecordingWhereInput
    orderBy?: MeetingRecordingOrderByWithAggregationInput | MeetingRecordingOrderByWithAggregationInput[]
    by: MeetingRecordingScalarFieldEnum[] | MeetingRecordingScalarFieldEnum
    having?: MeetingRecordingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingRecordingCountAggregateInputType | true
    _avg?: MeetingRecordingAvgAggregateInputType
    _sum?: MeetingRecordingSumAggregateInputType
    _min?: MeetingRecordingMinAggregateInputType
    _max?: MeetingRecordingMaxAggregateInputType
  }

  export type MeetingRecordingGroupByOutputType = {
    id: string
    agentId: string
    title: string
    meetingUrl: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId: string | null
    status: $Enums.RecordingStatus
    recordingUrl: string | null
    transcript: string | null
    summary: string | null
    actionItems: JsonValue
    participants: JsonValue
    scheduledAt: Date
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    createdAt: Date
    updatedAt: Date
    _count: MeetingRecordingCountAggregateOutputType | null
    _avg: MeetingRecordingAvgAggregateOutputType | null
    _sum: MeetingRecordingSumAggregateOutputType | null
    _min: MeetingRecordingMinAggregateOutputType | null
    _max: MeetingRecordingMaxAggregateOutputType | null
  }

  type GetMeetingRecordingGroupByPayload<T extends MeetingRecordingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingRecordingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingRecordingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingRecordingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingRecordingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingRecordingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    meetingUrl?: boolean
    meetingPlatform?: boolean
    calendarEventId?: boolean
    status?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    summary?: boolean
    actionItems?: boolean
    participants?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRecording"]>

  export type MeetingRecordingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    meetingUrl?: boolean
    meetingPlatform?: boolean
    calendarEventId?: boolean
    status?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    summary?: boolean
    actionItems?: boolean
    participants?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRecording"]>

  export type MeetingRecordingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    meetingUrl?: boolean
    meetingPlatform?: boolean
    calendarEventId?: boolean
    status?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    summary?: boolean
    actionItems?: boolean
    participants?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRecording"]>

  export type MeetingRecordingSelectScalar = {
    id?: boolean
    agentId?: boolean
    title?: boolean
    meetingUrl?: boolean
    meetingPlatform?: boolean
    calendarEventId?: boolean
    status?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    summary?: boolean
    actionItems?: boolean
    participants?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingRecordingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "title" | "meetingUrl" | "meetingPlatform" | "calendarEventId" | "status" | "recordingUrl" | "transcript" | "summary" | "actionItems" | "participants" | "scheduledAt" | "startedAt" | "endedAt" | "duration" | "createdAt" | "updatedAt", ExtArgs["result"]["meetingRecording"]>
  export type MeetingRecordingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type MeetingRecordingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type MeetingRecordingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $MeetingRecordingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingRecording"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      title: string
      meetingUrl: string | null
      meetingPlatform: $Enums.MeetingPlatform
      calendarEventId: string | null
      status: $Enums.RecordingStatus
      recordingUrl: string | null
      transcript: string | null
      summary: string | null
      actionItems: Prisma.JsonValue
      participants: Prisma.JsonValue
      scheduledAt: Date
      startedAt: Date | null
      endedAt: Date | null
      duration: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meetingRecording"]>
    composites: {}
  }

  type MeetingRecordingGetPayload<S extends boolean | null | undefined | MeetingRecordingDefaultArgs> = $Result.GetResult<Prisma.$MeetingRecordingPayload, S>

  type MeetingRecordingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingRecordingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingRecordingCountAggregateInputType | true
    }

  export interface MeetingRecordingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingRecording'], meta: { name: 'MeetingRecording' } }
    /**
     * Find zero or one MeetingRecording that matches the filter.
     * @param {MeetingRecordingFindUniqueArgs} args - Arguments to find a MeetingRecording
     * @example
     * // Get one MeetingRecording
     * const meetingRecording = await prisma.meetingRecording.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingRecordingFindUniqueArgs>(args: SelectSubset<T, MeetingRecordingFindUniqueArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeetingRecording that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingRecordingFindUniqueOrThrowArgs} args - Arguments to find a MeetingRecording
     * @example
     * // Get one MeetingRecording
     * const meetingRecording = await prisma.meetingRecording.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingRecordingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingRecordingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingRecording that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingFindFirstArgs} args - Arguments to find a MeetingRecording
     * @example
     * // Get one MeetingRecording
     * const meetingRecording = await prisma.meetingRecording.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingRecordingFindFirstArgs>(args?: SelectSubset<T, MeetingRecordingFindFirstArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingRecording that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingFindFirstOrThrowArgs} args - Arguments to find a MeetingRecording
     * @example
     * // Get one MeetingRecording
     * const meetingRecording = await prisma.meetingRecording.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingRecordingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingRecordingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeetingRecordings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingRecordings
     * const meetingRecordings = await prisma.meetingRecording.findMany()
     * 
     * // Get first 10 MeetingRecordings
     * const meetingRecordings = await prisma.meetingRecording.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingRecordingWithIdOnly = await prisma.meetingRecording.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingRecordingFindManyArgs>(args?: SelectSubset<T, MeetingRecordingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeetingRecording.
     * @param {MeetingRecordingCreateArgs} args - Arguments to create a MeetingRecording.
     * @example
     * // Create one MeetingRecording
     * const MeetingRecording = await prisma.meetingRecording.create({
     *   data: {
     *     // ... data to create a MeetingRecording
     *   }
     * })
     * 
     */
    create<T extends MeetingRecordingCreateArgs>(args: SelectSubset<T, MeetingRecordingCreateArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeetingRecordings.
     * @param {MeetingRecordingCreateManyArgs} args - Arguments to create many MeetingRecordings.
     * @example
     * // Create many MeetingRecordings
     * const meetingRecording = await prisma.meetingRecording.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingRecordingCreateManyArgs>(args?: SelectSubset<T, MeetingRecordingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingRecordings and returns the data saved in the database.
     * @param {MeetingRecordingCreateManyAndReturnArgs} args - Arguments to create many MeetingRecordings.
     * @example
     * // Create many MeetingRecordings
     * const meetingRecording = await prisma.meetingRecording.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingRecordings and only return the `id`
     * const meetingRecordingWithIdOnly = await prisma.meetingRecording.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingRecordingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingRecordingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MeetingRecording.
     * @param {MeetingRecordingDeleteArgs} args - Arguments to delete one MeetingRecording.
     * @example
     * // Delete one MeetingRecording
     * const MeetingRecording = await prisma.meetingRecording.delete({
     *   where: {
     *     // ... filter to delete one MeetingRecording
     *   }
     * })
     * 
     */
    delete<T extends MeetingRecordingDeleteArgs>(args: SelectSubset<T, MeetingRecordingDeleteArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeetingRecording.
     * @param {MeetingRecordingUpdateArgs} args - Arguments to update one MeetingRecording.
     * @example
     * // Update one MeetingRecording
     * const meetingRecording = await prisma.meetingRecording.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingRecordingUpdateArgs>(args: SelectSubset<T, MeetingRecordingUpdateArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeetingRecordings.
     * @param {MeetingRecordingDeleteManyArgs} args - Arguments to filter MeetingRecordings to delete.
     * @example
     * // Delete a few MeetingRecordings
     * const { count } = await prisma.meetingRecording.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingRecordingDeleteManyArgs>(args?: SelectSubset<T, MeetingRecordingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingRecordings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingRecordings
     * const meetingRecording = await prisma.meetingRecording.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingRecordingUpdateManyArgs>(args: SelectSubset<T, MeetingRecordingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingRecordings and returns the data updated in the database.
     * @param {MeetingRecordingUpdateManyAndReturnArgs} args - Arguments to update many MeetingRecordings.
     * @example
     * // Update many MeetingRecordings
     * const meetingRecording = await prisma.meetingRecording.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MeetingRecordings and only return the `id`
     * const meetingRecordingWithIdOnly = await prisma.meetingRecording.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingRecordingUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingRecordingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MeetingRecording.
     * @param {MeetingRecordingUpsertArgs} args - Arguments to update or create a MeetingRecording.
     * @example
     * // Update or create a MeetingRecording
     * const meetingRecording = await prisma.meetingRecording.upsert({
     *   create: {
     *     // ... data to create a MeetingRecording
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingRecording we want to update
     *   }
     * })
     */
    upsert<T extends MeetingRecordingUpsertArgs>(args: SelectSubset<T, MeetingRecordingUpsertArgs<ExtArgs>>): Prisma__MeetingRecordingClient<$Result.GetResult<Prisma.$MeetingRecordingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeetingRecordings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingCountArgs} args - Arguments to filter MeetingRecordings to count.
     * @example
     * // Count the number of MeetingRecordings
     * const count = await prisma.meetingRecording.count({
     *   where: {
     *     // ... the filter for the MeetingRecordings we want to count
     *   }
     * })
    **/
    count<T extends MeetingRecordingCountArgs>(
      args?: Subset<T, MeetingRecordingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingRecordingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingRecording.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingRecordingAggregateArgs>(args: Subset<T, MeetingRecordingAggregateArgs>): Prisma.PrismaPromise<GetMeetingRecordingAggregateType<T>>

    /**
     * Group by MeetingRecording.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRecordingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingRecordingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingRecordingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingRecordingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingRecordingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingRecordingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingRecording model
   */
  readonly fields: MeetingRecordingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingRecording.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingRecordingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingRecording model
   */
  interface MeetingRecordingFieldRefs {
    readonly id: FieldRef<"MeetingRecording", 'String'>
    readonly agentId: FieldRef<"MeetingRecording", 'String'>
    readonly title: FieldRef<"MeetingRecording", 'String'>
    readonly meetingUrl: FieldRef<"MeetingRecording", 'String'>
    readonly meetingPlatform: FieldRef<"MeetingRecording", 'MeetingPlatform'>
    readonly calendarEventId: FieldRef<"MeetingRecording", 'String'>
    readonly status: FieldRef<"MeetingRecording", 'RecordingStatus'>
    readonly recordingUrl: FieldRef<"MeetingRecording", 'String'>
    readonly transcript: FieldRef<"MeetingRecording", 'String'>
    readonly summary: FieldRef<"MeetingRecording", 'String'>
    readonly actionItems: FieldRef<"MeetingRecording", 'Json'>
    readonly participants: FieldRef<"MeetingRecording", 'Json'>
    readonly scheduledAt: FieldRef<"MeetingRecording", 'DateTime'>
    readonly startedAt: FieldRef<"MeetingRecording", 'DateTime'>
    readonly endedAt: FieldRef<"MeetingRecording", 'DateTime'>
    readonly duration: FieldRef<"MeetingRecording", 'Int'>
    readonly createdAt: FieldRef<"MeetingRecording", 'DateTime'>
    readonly updatedAt: FieldRef<"MeetingRecording", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeetingRecording findUnique
   */
  export type MeetingRecordingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRecording to fetch.
     */
    where: MeetingRecordingWhereUniqueInput
  }

  /**
   * MeetingRecording findUniqueOrThrow
   */
  export type MeetingRecordingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRecording to fetch.
     */
    where: MeetingRecordingWhereUniqueInput
  }

  /**
   * MeetingRecording findFirst
   */
  export type MeetingRecordingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRecording to fetch.
     */
    where?: MeetingRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRecordings to fetch.
     */
    orderBy?: MeetingRecordingOrderByWithRelationInput | MeetingRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingRecordings.
     */
    cursor?: MeetingRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingRecordings.
     */
    distinct?: MeetingRecordingScalarFieldEnum | MeetingRecordingScalarFieldEnum[]
  }

  /**
   * MeetingRecording findFirstOrThrow
   */
  export type MeetingRecordingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRecording to fetch.
     */
    where?: MeetingRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRecordings to fetch.
     */
    orderBy?: MeetingRecordingOrderByWithRelationInput | MeetingRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingRecordings.
     */
    cursor?: MeetingRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingRecordings.
     */
    distinct?: MeetingRecordingScalarFieldEnum | MeetingRecordingScalarFieldEnum[]
  }

  /**
   * MeetingRecording findMany
   */
  export type MeetingRecordingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRecordings to fetch.
     */
    where?: MeetingRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRecordings to fetch.
     */
    orderBy?: MeetingRecordingOrderByWithRelationInput | MeetingRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingRecordings.
     */
    cursor?: MeetingRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRecordings.
     */
    skip?: number
    distinct?: MeetingRecordingScalarFieldEnum | MeetingRecordingScalarFieldEnum[]
  }

  /**
   * MeetingRecording create
   */
  export type MeetingRecordingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingRecording.
     */
    data: XOR<MeetingRecordingCreateInput, MeetingRecordingUncheckedCreateInput>
  }

  /**
   * MeetingRecording createMany
   */
  export type MeetingRecordingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingRecordings.
     */
    data: MeetingRecordingCreateManyInput | MeetingRecordingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingRecording createManyAndReturn
   */
  export type MeetingRecordingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * The data used to create many MeetingRecordings.
     */
    data: MeetingRecordingCreateManyInput | MeetingRecordingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingRecording update
   */
  export type MeetingRecordingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingRecording.
     */
    data: XOR<MeetingRecordingUpdateInput, MeetingRecordingUncheckedUpdateInput>
    /**
     * Choose, which MeetingRecording to update.
     */
    where: MeetingRecordingWhereUniqueInput
  }

  /**
   * MeetingRecording updateMany
   */
  export type MeetingRecordingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingRecordings.
     */
    data: XOR<MeetingRecordingUpdateManyMutationInput, MeetingRecordingUncheckedUpdateManyInput>
    /**
     * Filter which MeetingRecordings to update
     */
    where?: MeetingRecordingWhereInput
    /**
     * Limit how many MeetingRecordings to update.
     */
    limit?: number
  }

  /**
   * MeetingRecording updateManyAndReturn
   */
  export type MeetingRecordingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * The data used to update MeetingRecordings.
     */
    data: XOR<MeetingRecordingUpdateManyMutationInput, MeetingRecordingUncheckedUpdateManyInput>
    /**
     * Filter which MeetingRecordings to update
     */
    where?: MeetingRecordingWhereInput
    /**
     * Limit how many MeetingRecordings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingRecording upsert
   */
  export type MeetingRecordingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingRecording to update in case it exists.
     */
    where: MeetingRecordingWhereUniqueInput
    /**
     * In case the MeetingRecording found by the `where` argument doesn't exist, create a new MeetingRecording with this data.
     */
    create: XOR<MeetingRecordingCreateInput, MeetingRecordingUncheckedCreateInput>
    /**
     * In case the MeetingRecording was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingRecordingUpdateInput, MeetingRecordingUncheckedUpdateInput>
  }

  /**
   * MeetingRecording delete
   */
  export type MeetingRecordingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
    /**
     * Filter which MeetingRecording to delete.
     */
    where: MeetingRecordingWhereUniqueInput
  }

  /**
   * MeetingRecording deleteMany
   */
  export type MeetingRecordingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingRecordings to delete
     */
    where?: MeetingRecordingWhereInput
    /**
     * Limit how many MeetingRecordings to delete.
     */
    limit?: number
  }

  /**
   * MeetingRecording without action
   */
  export type MeetingRecordingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRecording
     */
    select?: MeetingRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRecording
     */
    omit?: MeetingRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRecordingInclude<ExtArgs> | null
  }


  /**
   * Model AgentPhoneNumber
   */

  export type AggregateAgentPhoneNumber = {
    _count: AgentPhoneNumberCountAggregateOutputType | null
    _min: AgentPhoneNumberMinAggregateOutputType | null
    _max: AgentPhoneNumberMaxAggregateOutputType | null
  }

  export type AgentPhoneNumberMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    phoneNumber: string | null
    twilioSid: string | null
    voiceEnabled: boolean | null
    voiceGreeting: string | null
    createdAt: Date | null
  }

  export type AgentPhoneNumberMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    phoneNumber: string | null
    twilioSid: string | null
    voiceEnabled: boolean | null
    voiceGreeting: string | null
    createdAt: Date | null
  }

  export type AgentPhoneNumberCountAggregateOutputType = {
    id: number
    agentId: number
    phoneNumber: number
    twilioSid: number
    voiceEnabled: number
    voiceGreeting: number
    createdAt: number
    _all: number
  }


  export type AgentPhoneNumberMinAggregateInputType = {
    id?: true
    agentId?: true
    phoneNumber?: true
    twilioSid?: true
    voiceEnabled?: true
    voiceGreeting?: true
    createdAt?: true
  }

  export type AgentPhoneNumberMaxAggregateInputType = {
    id?: true
    agentId?: true
    phoneNumber?: true
    twilioSid?: true
    voiceEnabled?: true
    voiceGreeting?: true
    createdAt?: true
  }

  export type AgentPhoneNumberCountAggregateInputType = {
    id?: true
    agentId?: true
    phoneNumber?: true
    twilioSid?: true
    voiceEnabled?: true
    voiceGreeting?: true
    createdAt?: true
    _all?: true
  }

  export type AgentPhoneNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentPhoneNumber to aggregate.
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPhoneNumbers to fetch.
     */
    orderBy?: AgentPhoneNumberOrderByWithRelationInput | AgentPhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentPhoneNumbers
    **/
    _count?: true | AgentPhoneNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentPhoneNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentPhoneNumberMaxAggregateInputType
  }

  export type GetAgentPhoneNumberAggregateType<T extends AgentPhoneNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentPhoneNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentPhoneNumber[P]>
      : GetScalarType<T[P], AggregateAgentPhoneNumber[P]>
  }




  export type AgentPhoneNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentPhoneNumberWhereInput
    orderBy?: AgentPhoneNumberOrderByWithAggregationInput | AgentPhoneNumberOrderByWithAggregationInput[]
    by: AgentPhoneNumberScalarFieldEnum[] | AgentPhoneNumberScalarFieldEnum
    having?: AgentPhoneNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentPhoneNumberCountAggregateInputType | true
    _min?: AgentPhoneNumberMinAggregateInputType
    _max?: AgentPhoneNumberMaxAggregateInputType
  }

  export type AgentPhoneNumberGroupByOutputType = {
    id: string
    agentId: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled: boolean
    voiceGreeting: string | null
    createdAt: Date
    _count: AgentPhoneNumberCountAggregateOutputType | null
    _min: AgentPhoneNumberMinAggregateOutputType | null
    _max: AgentPhoneNumberMaxAggregateOutputType | null
  }

  type GetAgentPhoneNumberGroupByPayload<T extends AgentPhoneNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentPhoneNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentPhoneNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentPhoneNumberGroupByOutputType[P]>
            : GetScalarType<T[P], AgentPhoneNumberGroupByOutputType[P]>
        }
      >
    >


  export type AgentPhoneNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    phoneNumber?: boolean
    twilioSid?: boolean
    voiceEnabled?: boolean
    voiceGreeting?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    calls?: boolean | AgentPhoneNumber$callsArgs<ExtArgs>
    _count?: boolean | AgentPhoneNumberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentPhoneNumber"]>

  export type AgentPhoneNumberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    phoneNumber?: boolean
    twilioSid?: boolean
    voiceEnabled?: boolean
    voiceGreeting?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentPhoneNumber"]>

  export type AgentPhoneNumberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    phoneNumber?: boolean
    twilioSid?: boolean
    voiceEnabled?: boolean
    voiceGreeting?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentPhoneNumber"]>

  export type AgentPhoneNumberSelectScalar = {
    id?: boolean
    agentId?: boolean
    phoneNumber?: boolean
    twilioSid?: boolean
    voiceEnabled?: boolean
    voiceGreeting?: boolean
    createdAt?: boolean
  }

  export type AgentPhoneNumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "phoneNumber" | "twilioSid" | "voiceEnabled" | "voiceGreeting" | "createdAt", ExtArgs["result"]["agentPhoneNumber"]>
  export type AgentPhoneNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    calls?: boolean | AgentPhoneNumber$callsArgs<ExtArgs>
    _count?: boolean | AgentPhoneNumberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentPhoneNumberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentPhoneNumberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentPhoneNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentPhoneNumber"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      calls: Prisma.$PhoneCallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      phoneNumber: string
      twilioSid: string
      voiceEnabled: boolean
      voiceGreeting: string | null
      createdAt: Date
    }, ExtArgs["result"]["agentPhoneNumber"]>
    composites: {}
  }

  type AgentPhoneNumberGetPayload<S extends boolean | null | undefined | AgentPhoneNumberDefaultArgs> = $Result.GetResult<Prisma.$AgentPhoneNumberPayload, S>

  type AgentPhoneNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentPhoneNumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentPhoneNumberCountAggregateInputType | true
    }

  export interface AgentPhoneNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentPhoneNumber'], meta: { name: 'AgentPhoneNumber' } }
    /**
     * Find zero or one AgentPhoneNumber that matches the filter.
     * @param {AgentPhoneNumberFindUniqueArgs} args - Arguments to find a AgentPhoneNumber
     * @example
     * // Get one AgentPhoneNumber
     * const agentPhoneNumber = await prisma.agentPhoneNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentPhoneNumberFindUniqueArgs>(args: SelectSubset<T, AgentPhoneNumberFindUniqueArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentPhoneNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentPhoneNumberFindUniqueOrThrowArgs} args - Arguments to find a AgentPhoneNumber
     * @example
     * // Get one AgentPhoneNumber
     * const agentPhoneNumber = await prisma.agentPhoneNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentPhoneNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentPhoneNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentPhoneNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberFindFirstArgs} args - Arguments to find a AgentPhoneNumber
     * @example
     * // Get one AgentPhoneNumber
     * const agentPhoneNumber = await prisma.agentPhoneNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentPhoneNumberFindFirstArgs>(args?: SelectSubset<T, AgentPhoneNumberFindFirstArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentPhoneNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberFindFirstOrThrowArgs} args - Arguments to find a AgentPhoneNumber
     * @example
     * // Get one AgentPhoneNumber
     * const agentPhoneNumber = await prisma.agentPhoneNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentPhoneNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentPhoneNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentPhoneNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentPhoneNumbers
     * const agentPhoneNumbers = await prisma.agentPhoneNumber.findMany()
     * 
     * // Get first 10 AgentPhoneNumbers
     * const agentPhoneNumbers = await prisma.agentPhoneNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentPhoneNumberWithIdOnly = await prisma.agentPhoneNumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentPhoneNumberFindManyArgs>(args?: SelectSubset<T, AgentPhoneNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentPhoneNumber.
     * @param {AgentPhoneNumberCreateArgs} args - Arguments to create a AgentPhoneNumber.
     * @example
     * // Create one AgentPhoneNumber
     * const AgentPhoneNumber = await prisma.agentPhoneNumber.create({
     *   data: {
     *     // ... data to create a AgentPhoneNumber
     *   }
     * })
     * 
     */
    create<T extends AgentPhoneNumberCreateArgs>(args: SelectSubset<T, AgentPhoneNumberCreateArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentPhoneNumbers.
     * @param {AgentPhoneNumberCreateManyArgs} args - Arguments to create many AgentPhoneNumbers.
     * @example
     * // Create many AgentPhoneNumbers
     * const agentPhoneNumber = await prisma.agentPhoneNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentPhoneNumberCreateManyArgs>(args?: SelectSubset<T, AgentPhoneNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentPhoneNumbers and returns the data saved in the database.
     * @param {AgentPhoneNumberCreateManyAndReturnArgs} args - Arguments to create many AgentPhoneNumbers.
     * @example
     * // Create many AgentPhoneNumbers
     * const agentPhoneNumber = await prisma.agentPhoneNumber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentPhoneNumbers and only return the `id`
     * const agentPhoneNumberWithIdOnly = await prisma.agentPhoneNumber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentPhoneNumberCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentPhoneNumberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentPhoneNumber.
     * @param {AgentPhoneNumberDeleteArgs} args - Arguments to delete one AgentPhoneNumber.
     * @example
     * // Delete one AgentPhoneNumber
     * const AgentPhoneNumber = await prisma.agentPhoneNumber.delete({
     *   where: {
     *     // ... filter to delete one AgentPhoneNumber
     *   }
     * })
     * 
     */
    delete<T extends AgentPhoneNumberDeleteArgs>(args: SelectSubset<T, AgentPhoneNumberDeleteArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentPhoneNumber.
     * @param {AgentPhoneNumberUpdateArgs} args - Arguments to update one AgentPhoneNumber.
     * @example
     * // Update one AgentPhoneNumber
     * const agentPhoneNumber = await prisma.agentPhoneNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentPhoneNumberUpdateArgs>(args: SelectSubset<T, AgentPhoneNumberUpdateArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentPhoneNumbers.
     * @param {AgentPhoneNumberDeleteManyArgs} args - Arguments to filter AgentPhoneNumbers to delete.
     * @example
     * // Delete a few AgentPhoneNumbers
     * const { count } = await prisma.agentPhoneNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentPhoneNumberDeleteManyArgs>(args?: SelectSubset<T, AgentPhoneNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentPhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentPhoneNumbers
     * const agentPhoneNumber = await prisma.agentPhoneNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentPhoneNumberUpdateManyArgs>(args: SelectSubset<T, AgentPhoneNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentPhoneNumbers and returns the data updated in the database.
     * @param {AgentPhoneNumberUpdateManyAndReturnArgs} args - Arguments to update many AgentPhoneNumbers.
     * @example
     * // Update many AgentPhoneNumbers
     * const agentPhoneNumber = await prisma.agentPhoneNumber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentPhoneNumbers and only return the `id`
     * const agentPhoneNumberWithIdOnly = await prisma.agentPhoneNumber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentPhoneNumberUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentPhoneNumberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentPhoneNumber.
     * @param {AgentPhoneNumberUpsertArgs} args - Arguments to update or create a AgentPhoneNumber.
     * @example
     * // Update or create a AgentPhoneNumber
     * const agentPhoneNumber = await prisma.agentPhoneNumber.upsert({
     *   create: {
     *     // ... data to create a AgentPhoneNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentPhoneNumber we want to update
     *   }
     * })
     */
    upsert<T extends AgentPhoneNumberUpsertArgs>(args: SelectSubset<T, AgentPhoneNumberUpsertArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentPhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberCountArgs} args - Arguments to filter AgentPhoneNumbers to count.
     * @example
     * // Count the number of AgentPhoneNumbers
     * const count = await prisma.agentPhoneNumber.count({
     *   where: {
     *     // ... the filter for the AgentPhoneNumbers we want to count
     *   }
     * })
    **/
    count<T extends AgentPhoneNumberCountArgs>(
      args?: Subset<T, AgentPhoneNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentPhoneNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentPhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentPhoneNumberAggregateArgs>(args: Subset<T, AgentPhoneNumberAggregateArgs>): Prisma.PrismaPromise<GetAgentPhoneNumberAggregateType<T>>

    /**
     * Group by AgentPhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPhoneNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentPhoneNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentPhoneNumberGroupByArgs['orderBy'] }
        : { orderBy?: AgentPhoneNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentPhoneNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentPhoneNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentPhoneNumber model
   */
  readonly fields: AgentPhoneNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentPhoneNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentPhoneNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calls<T extends AgentPhoneNumber$callsArgs<ExtArgs> = {}>(args?: Subset<T, AgentPhoneNumber$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentPhoneNumber model
   */
  interface AgentPhoneNumberFieldRefs {
    readonly id: FieldRef<"AgentPhoneNumber", 'String'>
    readonly agentId: FieldRef<"AgentPhoneNumber", 'String'>
    readonly phoneNumber: FieldRef<"AgentPhoneNumber", 'String'>
    readonly twilioSid: FieldRef<"AgentPhoneNumber", 'String'>
    readonly voiceEnabled: FieldRef<"AgentPhoneNumber", 'Boolean'>
    readonly voiceGreeting: FieldRef<"AgentPhoneNumber", 'String'>
    readonly createdAt: FieldRef<"AgentPhoneNumber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentPhoneNumber findUnique
   */
  export type AgentPhoneNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which AgentPhoneNumber to fetch.
     */
    where: AgentPhoneNumberWhereUniqueInput
  }

  /**
   * AgentPhoneNumber findUniqueOrThrow
   */
  export type AgentPhoneNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which AgentPhoneNumber to fetch.
     */
    where: AgentPhoneNumberWhereUniqueInput
  }

  /**
   * AgentPhoneNumber findFirst
   */
  export type AgentPhoneNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which AgentPhoneNumber to fetch.
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPhoneNumbers to fetch.
     */
    orderBy?: AgentPhoneNumberOrderByWithRelationInput | AgentPhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentPhoneNumbers.
     */
    cursor?: AgentPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentPhoneNumbers.
     */
    distinct?: AgentPhoneNumberScalarFieldEnum | AgentPhoneNumberScalarFieldEnum[]
  }

  /**
   * AgentPhoneNumber findFirstOrThrow
   */
  export type AgentPhoneNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which AgentPhoneNumber to fetch.
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPhoneNumbers to fetch.
     */
    orderBy?: AgentPhoneNumberOrderByWithRelationInput | AgentPhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentPhoneNumbers.
     */
    cursor?: AgentPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentPhoneNumbers.
     */
    distinct?: AgentPhoneNumberScalarFieldEnum | AgentPhoneNumberScalarFieldEnum[]
  }

  /**
   * AgentPhoneNumber findMany
   */
  export type AgentPhoneNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which AgentPhoneNumbers to fetch.
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPhoneNumbers to fetch.
     */
    orderBy?: AgentPhoneNumberOrderByWithRelationInput | AgentPhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentPhoneNumbers.
     */
    cursor?: AgentPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPhoneNumbers.
     */
    skip?: number
    distinct?: AgentPhoneNumberScalarFieldEnum | AgentPhoneNumberScalarFieldEnum[]
  }

  /**
   * AgentPhoneNumber create
   */
  export type AgentPhoneNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentPhoneNumber.
     */
    data: XOR<AgentPhoneNumberCreateInput, AgentPhoneNumberUncheckedCreateInput>
  }

  /**
   * AgentPhoneNumber createMany
   */
  export type AgentPhoneNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentPhoneNumbers.
     */
    data: AgentPhoneNumberCreateManyInput | AgentPhoneNumberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentPhoneNumber createManyAndReturn
   */
  export type AgentPhoneNumberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * The data used to create many AgentPhoneNumbers.
     */
    data: AgentPhoneNumberCreateManyInput | AgentPhoneNumberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentPhoneNumber update
   */
  export type AgentPhoneNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentPhoneNumber.
     */
    data: XOR<AgentPhoneNumberUpdateInput, AgentPhoneNumberUncheckedUpdateInput>
    /**
     * Choose, which AgentPhoneNumber to update.
     */
    where: AgentPhoneNumberWhereUniqueInput
  }

  /**
   * AgentPhoneNumber updateMany
   */
  export type AgentPhoneNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentPhoneNumbers.
     */
    data: XOR<AgentPhoneNumberUpdateManyMutationInput, AgentPhoneNumberUncheckedUpdateManyInput>
    /**
     * Filter which AgentPhoneNumbers to update
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * Limit how many AgentPhoneNumbers to update.
     */
    limit?: number
  }

  /**
   * AgentPhoneNumber updateManyAndReturn
   */
  export type AgentPhoneNumberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * The data used to update AgentPhoneNumbers.
     */
    data: XOR<AgentPhoneNumberUpdateManyMutationInput, AgentPhoneNumberUncheckedUpdateManyInput>
    /**
     * Filter which AgentPhoneNumbers to update
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * Limit how many AgentPhoneNumbers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentPhoneNumber upsert
   */
  export type AgentPhoneNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentPhoneNumber to update in case it exists.
     */
    where: AgentPhoneNumberWhereUniqueInput
    /**
     * In case the AgentPhoneNumber found by the `where` argument doesn't exist, create a new AgentPhoneNumber with this data.
     */
    create: XOR<AgentPhoneNumberCreateInput, AgentPhoneNumberUncheckedCreateInput>
    /**
     * In case the AgentPhoneNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentPhoneNumberUpdateInput, AgentPhoneNumberUncheckedUpdateInput>
  }

  /**
   * AgentPhoneNumber delete
   */
  export type AgentPhoneNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
    /**
     * Filter which AgentPhoneNumber to delete.
     */
    where: AgentPhoneNumberWhereUniqueInput
  }

  /**
   * AgentPhoneNumber deleteMany
   */
  export type AgentPhoneNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentPhoneNumbers to delete
     */
    where?: AgentPhoneNumberWhereInput
    /**
     * Limit how many AgentPhoneNumbers to delete.
     */
    limit?: number
  }

  /**
   * AgentPhoneNumber.calls
   */
  export type AgentPhoneNumber$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    where?: PhoneCallWhereInput
    orderBy?: PhoneCallOrderByWithRelationInput | PhoneCallOrderByWithRelationInput[]
    cursor?: PhoneCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhoneCallScalarFieldEnum | PhoneCallScalarFieldEnum[]
  }

  /**
   * AgentPhoneNumber without action
   */
  export type AgentPhoneNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPhoneNumber
     */
    select?: AgentPhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPhoneNumber
     */
    omit?: AgentPhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentPhoneNumberInclude<ExtArgs> | null
  }


  /**
   * Model PhoneCall
   */

  export type AggregatePhoneCall = {
    _count: PhoneCallCountAggregateOutputType | null
    _avg: PhoneCallAvgAggregateOutputType | null
    _sum: PhoneCallSumAggregateOutputType | null
    _min: PhoneCallMinAggregateOutputType | null
    _max: PhoneCallMaxAggregateOutputType | null
  }

  export type PhoneCallAvgAggregateOutputType = {
    duration: number | null
  }

  export type PhoneCallSumAggregateOutputType = {
    duration: number | null
  }

  export type PhoneCallMinAggregateOutputType = {
    id: string | null
    phoneNumberId: string | null
    direction: $Enums.CallDirection | null
    fromNumber: string | null
    toNumber: string | null
    status: $Enums.CallStatus | null
    twilioCallSid: string | null
    recordingUrl: string | null
    transcript: string | null
    conversationId: string | null
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type PhoneCallMaxAggregateOutputType = {
    id: string | null
    phoneNumberId: string | null
    direction: $Enums.CallDirection | null
    fromNumber: string | null
    toNumber: string | null
    status: $Enums.CallStatus | null
    twilioCallSid: string | null
    recordingUrl: string | null
    transcript: string | null
    conversationId: string | null
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type PhoneCallCountAggregateOutputType = {
    id: number
    phoneNumberId: number
    direction: number
    fromNumber: number
    toNumber: number
    status: number
    twilioCallSid: number
    recordingUrl: number
    transcript: number
    conversationId: number
    duration: number
    startedAt: number
    endedAt: number
    _all: number
  }


  export type PhoneCallAvgAggregateInputType = {
    duration?: true
  }

  export type PhoneCallSumAggregateInputType = {
    duration?: true
  }

  export type PhoneCallMinAggregateInputType = {
    id?: true
    phoneNumberId?: true
    direction?: true
    fromNumber?: true
    toNumber?: true
    status?: true
    twilioCallSid?: true
    recordingUrl?: true
    transcript?: true
    conversationId?: true
    duration?: true
    startedAt?: true
    endedAt?: true
  }

  export type PhoneCallMaxAggregateInputType = {
    id?: true
    phoneNumberId?: true
    direction?: true
    fromNumber?: true
    toNumber?: true
    status?: true
    twilioCallSid?: true
    recordingUrl?: true
    transcript?: true
    conversationId?: true
    duration?: true
    startedAt?: true
    endedAt?: true
  }

  export type PhoneCallCountAggregateInputType = {
    id?: true
    phoneNumberId?: true
    direction?: true
    fromNumber?: true
    toNumber?: true
    status?: true
    twilioCallSid?: true
    recordingUrl?: true
    transcript?: true
    conversationId?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    _all?: true
  }

  export type PhoneCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneCall to aggregate.
     */
    where?: PhoneCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneCalls to fetch.
     */
    orderBy?: PhoneCallOrderByWithRelationInput | PhoneCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhoneCalls
    **/
    _count?: true | PhoneCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhoneCallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhoneCallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneCallMaxAggregateInputType
  }

  export type GetPhoneCallAggregateType<T extends PhoneCallAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoneCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneCall[P]>
      : GetScalarType<T[P], AggregatePhoneCall[P]>
  }




  export type PhoneCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneCallWhereInput
    orderBy?: PhoneCallOrderByWithAggregationInput | PhoneCallOrderByWithAggregationInput[]
    by: PhoneCallScalarFieldEnum[] | PhoneCallScalarFieldEnum
    having?: PhoneCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneCallCountAggregateInputType | true
    _avg?: PhoneCallAvgAggregateInputType
    _sum?: PhoneCallSumAggregateInputType
    _min?: PhoneCallMinAggregateInputType
    _max?: PhoneCallMaxAggregateInputType
  }

  export type PhoneCallGroupByOutputType = {
    id: string
    phoneNumberId: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status: $Enums.CallStatus
    twilioCallSid: string | null
    recordingUrl: string | null
    transcript: string | null
    conversationId: string | null
    duration: number | null
    startedAt: Date
    endedAt: Date | null
    _count: PhoneCallCountAggregateOutputType | null
    _avg: PhoneCallAvgAggregateOutputType | null
    _sum: PhoneCallSumAggregateOutputType | null
    _min: PhoneCallMinAggregateOutputType | null
    _max: PhoneCallMaxAggregateOutputType | null
  }

  type GetPhoneCallGroupByPayload<T extends PhoneCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneCallGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneCallGroupByOutputType[P]>
        }
      >
    >


  export type PhoneCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumberId?: boolean
    direction?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    status?: boolean
    twilioCallSid?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    conversationId?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    phoneNumber?: boolean | AgentPhoneNumberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneCall"]>

  export type PhoneCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumberId?: boolean
    direction?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    status?: boolean
    twilioCallSid?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    conversationId?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    phoneNumber?: boolean | AgentPhoneNumberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneCall"]>

  export type PhoneCallSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumberId?: boolean
    direction?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    status?: boolean
    twilioCallSid?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    conversationId?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    phoneNumber?: boolean | AgentPhoneNumberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneCall"]>

  export type PhoneCallSelectScalar = {
    id?: boolean
    phoneNumberId?: boolean
    direction?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    status?: boolean
    twilioCallSid?: boolean
    recordingUrl?: boolean
    transcript?: boolean
    conversationId?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }

  export type PhoneCallOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phoneNumberId" | "direction" | "fromNumber" | "toNumber" | "status" | "twilioCallSid" | "recordingUrl" | "transcript" | "conversationId" | "duration" | "startedAt" | "endedAt", ExtArgs["result"]["phoneCall"]>
  export type PhoneCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phoneNumber?: boolean | AgentPhoneNumberDefaultArgs<ExtArgs>
  }
  export type PhoneCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phoneNumber?: boolean | AgentPhoneNumberDefaultArgs<ExtArgs>
  }
  export type PhoneCallIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phoneNumber?: boolean | AgentPhoneNumberDefaultArgs<ExtArgs>
  }

  export type $PhoneCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhoneCall"
    objects: {
      phoneNumber: Prisma.$AgentPhoneNumberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumberId: string
      direction: $Enums.CallDirection
      fromNumber: string
      toNumber: string
      status: $Enums.CallStatus
      twilioCallSid: string | null
      recordingUrl: string | null
      transcript: string | null
      conversationId: string | null
      duration: number | null
      startedAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["phoneCall"]>
    composites: {}
  }

  type PhoneCallGetPayload<S extends boolean | null | undefined | PhoneCallDefaultArgs> = $Result.GetResult<Prisma.$PhoneCallPayload, S>

  type PhoneCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhoneCallFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhoneCallCountAggregateInputType | true
    }

  export interface PhoneCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhoneCall'], meta: { name: 'PhoneCall' } }
    /**
     * Find zero or one PhoneCall that matches the filter.
     * @param {PhoneCallFindUniqueArgs} args - Arguments to find a PhoneCall
     * @example
     * // Get one PhoneCall
     * const phoneCall = await prisma.phoneCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneCallFindUniqueArgs>(args: SelectSubset<T, PhoneCallFindUniqueArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhoneCall that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhoneCallFindUniqueOrThrowArgs} args - Arguments to find a PhoneCall
     * @example
     * // Get one PhoneCall
     * const phoneCall = await prisma.phoneCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneCallFindUniqueOrThrowArgs>(args: SelectSubset<T, PhoneCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallFindFirstArgs} args - Arguments to find a PhoneCall
     * @example
     * // Get one PhoneCall
     * const phoneCall = await prisma.phoneCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneCallFindFirstArgs>(args?: SelectSubset<T, PhoneCallFindFirstArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallFindFirstOrThrowArgs} args - Arguments to find a PhoneCall
     * @example
     * // Get one PhoneCall
     * const phoneCall = await prisma.phoneCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneCallFindFirstOrThrowArgs>(args?: SelectSubset<T, PhoneCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhoneCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneCalls
     * const phoneCalls = await prisma.phoneCall.findMany()
     * 
     * // Get first 10 PhoneCalls
     * const phoneCalls = await prisma.phoneCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneCallWithIdOnly = await prisma.phoneCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhoneCallFindManyArgs>(args?: SelectSubset<T, PhoneCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhoneCall.
     * @param {PhoneCallCreateArgs} args - Arguments to create a PhoneCall.
     * @example
     * // Create one PhoneCall
     * const PhoneCall = await prisma.phoneCall.create({
     *   data: {
     *     // ... data to create a PhoneCall
     *   }
     * })
     * 
     */
    create<T extends PhoneCallCreateArgs>(args: SelectSubset<T, PhoneCallCreateArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhoneCalls.
     * @param {PhoneCallCreateManyArgs} args - Arguments to create many PhoneCalls.
     * @example
     * // Create many PhoneCalls
     * const phoneCall = await prisma.phoneCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhoneCallCreateManyArgs>(args?: SelectSubset<T, PhoneCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhoneCalls and returns the data saved in the database.
     * @param {PhoneCallCreateManyAndReturnArgs} args - Arguments to create many PhoneCalls.
     * @example
     * // Create many PhoneCalls
     * const phoneCall = await prisma.phoneCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhoneCalls and only return the `id`
     * const phoneCallWithIdOnly = await prisma.phoneCall.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhoneCallCreateManyAndReturnArgs>(args?: SelectSubset<T, PhoneCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhoneCall.
     * @param {PhoneCallDeleteArgs} args - Arguments to delete one PhoneCall.
     * @example
     * // Delete one PhoneCall
     * const PhoneCall = await prisma.phoneCall.delete({
     *   where: {
     *     // ... filter to delete one PhoneCall
     *   }
     * })
     * 
     */
    delete<T extends PhoneCallDeleteArgs>(args: SelectSubset<T, PhoneCallDeleteArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhoneCall.
     * @param {PhoneCallUpdateArgs} args - Arguments to update one PhoneCall.
     * @example
     * // Update one PhoneCall
     * const phoneCall = await prisma.phoneCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhoneCallUpdateArgs>(args: SelectSubset<T, PhoneCallUpdateArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhoneCalls.
     * @param {PhoneCallDeleteManyArgs} args - Arguments to filter PhoneCalls to delete.
     * @example
     * // Delete a few PhoneCalls
     * const { count } = await prisma.phoneCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhoneCallDeleteManyArgs>(args?: SelectSubset<T, PhoneCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneCalls
     * const phoneCall = await prisma.phoneCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhoneCallUpdateManyArgs>(args: SelectSubset<T, PhoneCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneCalls and returns the data updated in the database.
     * @param {PhoneCallUpdateManyAndReturnArgs} args - Arguments to update many PhoneCalls.
     * @example
     * // Update many PhoneCalls
     * const phoneCall = await prisma.phoneCall.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhoneCalls and only return the `id`
     * const phoneCallWithIdOnly = await prisma.phoneCall.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhoneCallUpdateManyAndReturnArgs>(args: SelectSubset<T, PhoneCallUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhoneCall.
     * @param {PhoneCallUpsertArgs} args - Arguments to update or create a PhoneCall.
     * @example
     * // Update or create a PhoneCall
     * const phoneCall = await prisma.phoneCall.upsert({
     *   create: {
     *     // ... data to create a PhoneCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneCall we want to update
     *   }
     * })
     */
    upsert<T extends PhoneCallUpsertArgs>(args: SelectSubset<T, PhoneCallUpsertArgs<ExtArgs>>): Prisma__PhoneCallClient<$Result.GetResult<Prisma.$PhoneCallPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhoneCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallCountArgs} args - Arguments to filter PhoneCalls to count.
     * @example
     * // Count the number of PhoneCalls
     * const count = await prisma.phoneCall.count({
     *   where: {
     *     // ... the filter for the PhoneCalls we want to count
     *   }
     * })
    **/
    count<T extends PhoneCallCountArgs>(
      args?: Subset<T, PhoneCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhoneCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneCallAggregateArgs>(args: Subset<T, PhoneCallAggregateArgs>): Prisma.PrismaPromise<GetPhoneCallAggregateType<T>>

    /**
     * Group by PhoneCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneCallGroupByArgs['orderBy'] }
        : { orderBy?: PhoneCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhoneCall model
   */
  readonly fields: PhoneCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phoneNumber<T extends AgentPhoneNumberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentPhoneNumberDefaultArgs<ExtArgs>>): Prisma__AgentPhoneNumberClient<$Result.GetResult<Prisma.$AgentPhoneNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhoneCall model
   */
  interface PhoneCallFieldRefs {
    readonly id: FieldRef<"PhoneCall", 'String'>
    readonly phoneNumberId: FieldRef<"PhoneCall", 'String'>
    readonly direction: FieldRef<"PhoneCall", 'CallDirection'>
    readonly fromNumber: FieldRef<"PhoneCall", 'String'>
    readonly toNumber: FieldRef<"PhoneCall", 'String'>
    readonly status: FieldRef<"PhoneCall", 'CallStatus'>
    readonly twilioCallSid: FieldRef<"PhoneCall", 'String'>
    readonly recordingUrl: FieldRef<"PhoneCall", 'String'>
    readonly transcript: FieldRef<"PhoneCall", 'String'>
    readonly conversationId: FieldRef<"PhoneCall", 'String'>
    readonly duration: FieldRef<"PhoneCall", 'Int'>
    readonly startedAt: FieldRef<"PhoneCall", 'DateTime'>
    readonly endedAt: FieldRef<"PhoneCall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhoneCall findUnique
   */
  export type PhoneCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * Filter, which PhoneCall to fetch.
     */
    where: PhoneCallWhereUniqueInput
  }

  /**
   * PhoneCall findUniqueOrThrow
   */
  export type PhoneCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * Filter, which PhoneCall to fetch.
     */
    where: PhoneCallWhereUniqueInput
  }

  /**
   * PhoneCall findFirst
   */
  export type PhoneCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * Filter, which PhoneCall to fetch.
     */
    where?: PhoneCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneCalls to fetch.
     */
    orderBy?: PhoneCallOrderByWithRelationInput | PhoneCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneCalls.
     */
    cursor?: PhoneCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneCalls.
     */
    distinct?: PhoneCallScalarFieldEnum | PhoneCallScalarFieldEnum[]
  }

  /**
   * PhoneCall findFirstOrThrow
   */
  export type PhoneCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * Filter, which PhoneCall to fetch.
     */
    where?: PhoneCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneCalls to fetch.
     */
    orderBy?: PhoneCallOrderByWithRelationInput | PhoneCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneCalls.
     */
    cursor?: PhoneCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneCalls.
     */
    distinct?: PhoneCallScalarFieldEnum | PhoneCallScalarFieldEnum[]
  }

  /**
   * PhoneCall findMany
   */
  export type PhoneCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * Filter, which PhoneCalls to fetch.
     */
    where?: PhoneCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneCalls to fetch.
     */
    orderBy?: PhoneCallOrderByWithRelationInput | PhoneCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhoneCalls.
     */
    cursor?: PhoneCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneCalls.
     */
    skip?: number
    distinct?: PhoneCallScalarFieldEnum | PhoneCallScalarFieldEnum[]
  }

  /**
   * PhoneCall create
   */
  export type PhoneCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * The data needed to create a PhoneCall.
     */
    data: XOR<PhoneCallCreateInput, PhoneCallUncheckedCreateInput>
  }

  /**
   * PhoneCall createMany
   */
  export type PhoneCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhoneCalls.
     */
    data: PhoneCallCreateManyInput | PhoneCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhoneCall createManyAndReturn
   */
  export type PhoneCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * The data used to create many PhoneCalls.
     */
    data: PhoneCallCreateManyInput | PhoneCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhoneCall update
   */
  export type PhoneCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * The data needed to update a PhoneCall.
     */
    data: XOR<PhoneCallUpdateInput, PhoneCallUncheckedUpdateInput>
    /**
     * Choose, which PhoneCall to update.
     */
    where: PhoneCallWhereUniqueInput
  }

  /**
   * PhoneCall updateMany
   */
  export type PhoneCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhoneCalls.
     */
    data: XOR<PhoneCallUpdateManyMutationInput, PhoneCallUncheckedUpdateManyInput>
    /**
     * Filter which PhoneCalls to update
     */
    where?: PhoneCallWhereInput
    /**
     * Limit how many PhoneCalls to update.
     */
    limit?: number
  }

  /**
   * PhoneCall updateManyAndReturn
   */
  export type PhoneCallUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * The data used to update PhoneCalls.
     */
    data: XOR<PhoneCallUpdateManyMutationInput, PhoneCallUncheckedUpdateManyInput>
    /**
     * Filter which PhoneCalls to update
     */
    where?: PhoneCallWhereInput
    /**
     * Limit how many PhoneCalls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhoneCall upsert
   */
  export type PhoneCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * The filter to search for the PhoneCall to update in case it exists.
     */
    where: PhoneCallWhereUniqueInput
    /**
     * In case the PhoneCall found by the `where` argument doesn't exist, create a new PhoneCall with this data.
     */
    create: XOR<PhoneCallCreateInput, PhoneCallUncheckedCreateInput>
    /**
     * In case the PhoneCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneCallUpdateInput, PhoneCallUncheckedUpdateInput>
  }

  /**
   * PhoneCall delete
   */
  export type PhoneCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
    /**
     * Filter which PhoneCall to delete.
     */
    where: PhoneCallWhereUniqueInput
  }

  /**
   * PhoneCall deleteMany
   */
  export type PhoneCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneCalls to delete
     */
    where?: PhoneCallWhereInput
    /**
     * Limit how many PhoneCalls to delete.
     */
    limit?: number
  }

  /**
   * PhoneCall without action
   */
  export type PhoneCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneCall
     */
    select?: PhoneCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneCall
     */
    omit?: PhoneCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneCallInclude<ExtArgs> | null
  }


  /**
   * Model AgentMetric
   */

  export type AggregateAgentMetric = {
    _count: AgentMetricCountAggregateOutputType | null
    _avg: AgentMetricAvgAggregateOutputType | null
    _sum: AgentMetricSumAggregateOutputType | null
    _min: AgentMetricMinAggregateOutputType | null
    _max: AgentMetricMaxAggregateOutputType | null
  }

  export type AgentMetricAvgAggregateOutputType = {
    totalConversations: number | null
    totalMessages: number | null
    avgMessagesPerConvo: number | null
    avgResponseTimeMs: number | null
    totalTokensUsed: number | null
    toolCallsCount: number | null
    toolSuccessRate: number | null
    feedbackPositive: number | null
    feedbackNegative: number | null
  }

  export type AgentMetricSumAggregateOutputType = {
    totalConversations: number | null
    totalMessages: number | null
    avgMessagesPerConvo: number | null
    avgResponseTimeMs: number | null
    totalTokensUsed: number | null
    toolCallsCount: number | null
    toolSuccessRate: number | null
    feedbackPositive: number | null
    feedbackNegative: number | null
  }

  export type AgentMetricMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    date: Date | null
    totalConversations: number | null
    totalMessages: number | null
    avgMessagesPerConvo: number | null
    avgResponseTimeMs: number | null
    totalTokensUsed: number | null
    toolCallsCount: number | null
    toolSuccessRate: number | null
    feedbackPositive: number | null
    feedbackNegative: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMetricMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    date: Date | null
    totalConversations: number | null
    totalMessages: number | null
    avgMessagesPerConvo: number | null
    avgResponseTimeMs: number | null
    totalTokensUsed: number | null
    toolCallsCount: number | null
    toolSuccessRate: number | null
    feedbackPositive: number | null
    feedbackNegative: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMetricCountAggregateOutputType = {
    id: number
    agentId: number
    date: number
    totalConversations: number
    totalMessages: number
    avgMessagesPerConvo: number
    avgResponseTimeMs: number
    totalTokensUsed: number
    toolCallsCount: number
    toolSuccessRate: number
    feedbackPositive: number
    feedbackNegative: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentMetricAvgAggregateInputType = {
    totalConversations?: true
    totalMessages?: true
    avgMessagesPerConvo?: true
    avgResponseTimeMs?: true
    totalTokensUsed?: true
    toolCallsCount?: true
    toolSuccessRate?: true
    feedbackPositive?: true
    feedbackNegative?: true
  }

  export type AgentMetricSumAggregateInputType = {
    totalConversations?: true
    totalMessages?: true
    avgMessagesPerConvo?: true
    avgResponseTimeMs?: true
    totalTokensUsed?: true
    toolCallsCount?: true
    toolSuccessRate?: true
    feedbackPositive?: true
    feedbackNegative?: true
  }

  export type AgentMetricMinAggregateInputType = {
    id?: true
    agentId?: true
    date?: true
    totalConversations?: true
    totalMessages?: true
    avgMessagesPerConvo?: true
    avgResponseTimeMs?: true
    totalTokensUsed?: true
    toolCallsCount?: true
    toolSuccessRate?: true
    feedbackPositive?: true
    feedbackNegative?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMetricMaxAggregateInputType = {
    id?: true
    agentId?: true
    date?: true
    totalConversations?: true
    totalMessages?: true
    avgMessagesPerConvo?: true
    avgResponseTimeMs?: true
    totalTokensUsed?: true
    toolCallsCount?: true
    toolSuccessRate?: true
    feedbackPositive?: true
    feedbackNegative?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMetricCountAggregateInputType = {
    id?: true
    agentId?: true
    date?: true
    totalConversations?: true
    totalMessages?: true
    avgMessagesPerConvo?: true
    avgResponseTimeMs?: true
    totalTokensUsed?: true
    toolCallsCount?: true
    toolSuccessRate?: true
    feedbackPositive?: true
    feedbackNegative?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentMetric to aggregate.
     */
    where?: AgentMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMetrics to fetch.
     */
    orderBy?: AgentMetricOrderByWithRelationInput | AgentMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentMetrics
    **/
    _count?: true | AgentMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMetricMaxAggregateInputType
  }

  export type GetAgentMetricAggregateType<T extends AgentMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentMetric[P]>
      : GetScalarType<T[P], AggregateAgentMetric[P]>
  }




  export type AgentMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentMetricWhereInput
    orderBy?: AgentMetricOrderByWithAggregationInput | AgentMetricOrderByWithAggregationInput[]
    by: AgentMetricScalarFieldEnum[] | AgentMetricScalarFieldEnum
    having?: AgentMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentMetricCountAggregateInputType | true
    _avg?: AgentMetricAvgAggregateInputType
    _sum?: AgentMetricSumAggregateInputType
    _min?: AgentMetricMinAggregateInputType
    _max?: AgentMetricMaxAggregateInputType
  }

  export type AgentMetricGroupByOutputType = {
    id: string
    agentId: string
    date: Date
    totalConversations: number
    totalMessages: number
    avgMessagesPerConvo: number
    avgResponseTimeMs: number
    totalTokensUsed: number
    toolCallsCount: number
    toolSuccessRate: number
    feedbackPositive: number
    feedbackNegative: number
    createdAt: Date
    updatedAt: Date
    _count: AgentMetricCountAggregateOutputType | null
    _avg: AgentMetricAvgAggregateOutputType | null
    _sum: AgentMetricSumAggregateOutputType | null
    _min: AgentMetricMinAggregateOutputType | null
    _max: AgentMetricMaxAggregateOutputType | null
  }

  type GetAgentMetricGroupByPayload<T extends AgentMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentMetricGroupByOutputType[P]>
            : GetScalarType<T[P], AgentMetricGroupByOutputType[P]>
        }
      >
    >


  export type AgentMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    date?: boolean
    totalConversations?: boolean
    totalMessages?: boolean
    avgMessagesPerConvo?: boolean
    avgResponseTimeMs?: boolean
    totalTokensUsed?: boolean
    toolCallsCount?: boolean
    toolSuccessRate?: boolean
    feedbackPositive?: boolean
    feedbackNegative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentMetric"]>

  export type AgentMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    date?: boolean
    totalConversations?: boolean
    totalMessages?: boolean
    avgMessagesPerConvo?: boolean
    avgResponseTimeMs?: boolean
    totalTokensUsed?: boolean
    toolCallsCount?: boolean
    toolSuccessRate?: boolean
    feedbackPositive?: boolean
    feedbackNegative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentMetric"]>

  export type AgentMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    date?: boolean
    totalConversations?: boolean
    totalMessages?: boolean
    avgMessagesPerConvo?: boolean
    avgResponseTimeMs?: boolean
    totalTokensUsed?: boolean
    toolCallsCount?: boolean
    toolSuccessRate?: boolean
    feedbackPositive?: boolean
    feedbackNegative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentMetric"]>

  export type AgentMetricSelectScalar = {
    id?: boolean
    agentId?: boolean
    date?: boolean
    totalConversations?: boolean
    totalMessages?: boolean
    avgMessagesPerConvo?: boolean
    avgResponseTimeMs?: boolean
    totalTokensUsed?: boolean
    toolCallsCount?: boolean
    toolSuccessRate?: boolean
    feedbackPositive?: boolean
    feedbackNegative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "date" | "totalConversations" | "totalMessages" | "avgMessagesPerConvo" | "avgResponseTimeMs" | "totalTokensUsed" | "toolCallsCount" | "toolSuccessRate" | "feedbackPositive" | "feedbackNegative" | "createdAt" | "updatedAt", ExtArgs["result"]["agentMetric"]>
  export type AgentMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentMetric"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      date: Date
      totalConversations: number
      totalMessages: number
      avgMessagesPerConvo: number
      avgResponseTimeMs: number
      totalTokensUsed: number
      toolCallsCount: number
      toolSuccessRate: number
      feedbackPositive: number
      feedbackNegative: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentMetric"]>
    composites: {}
  }

  type AgentMetricGetPayload<S extends boolean | null | undefined | AgentMetricDefaultArgs> = $Result.GetResult<Prisma.$AgentMetricPayload, S>

  type AgentMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentMetricCountAggregateInputType | true
    }

  export interface AgentMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentMetric'], meta: { name: 'AgentMetric' } }
    /**
     * Find zero or one AgentMetric that matches the filter.
     * @param {AgentMetricFindUniqueArgs} args - Arguments to find a AgentMetric
     * @example
     * // Get one AgentMetric
     * const agentMetric = await prisma.agentMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentMetricFindUniqueArgs>(args: SelectSubset<T, AgentMetricFindUniqueArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentMetricFindUniqueOrThrowArgs} args - Arguments to find a AgentMetric
     * @example
     * // Get one AgentMetric
     * const agentMetric = await prisma.agentMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricFindFirstArgs} args - Arguments to find a AgentMetric
     * @example
     * // Get one AgentMetric
     * const agentMetric = await prisma.agentMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentMetricFindFirstArgs>(args?: SelectSubset<T, AgentMetricFindFirstArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricFindFirstOrThrowArgs} args - Arguments to find a AgentMetric
     * @example
     * // Get one AgentMetric
     * const agentMetric = await prisma.agentMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentMetrics
     * const agentMetrics = await prisma.agentMetric.findMany()
     * 
     * // Get first 10 AgentMetrics
     * const agentMetrics = await prisma.agentMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentMetricWithIdOnly = await prisma.agentMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentMetricFindManyArgs>(args?: SelectSubset<T, AgentMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentMetric.
     * @param {AgentMetricCreateArgs} args - Arguments to create a AgentMetric.
     * @example
     * // Create one AgentMetric
     * const AgentMetric = await prisma.agentMetric.create({
     *   data: {
     *     // ... data to create a AgentMetric
     *   }
     * })
     * 
     */
    create<T extends AgentMetricCreateArgs>(args: SelectSubset<T, AgentMetricCreateArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentMetrics.
     * @param {AgentMetricCreateManyArgs} args - Arguments to create many AgentMetrics.
     * @example
     * // Create many AgentMetrics
     * const agentMetric = await prisma.agentMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentMetricCreateManyArgs>(args?: SelectSubset<T, AgentMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentMetrics and returns the data saved in the database.
     * @param {AgentMetricCreateManyAndReturnArgs} args - Arguments to create many AgentMetrics.
     * @example
     * // Create many AgentMetrics
     * const agentMetric = await prisma.agentMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentMetrics and only return the `id`
     * const agentMetricWithIdOnly = await prisma.agentMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentMetric.
     * @param {AgentMetricDeleteArgs} args - Arguments to delete one AgentMetric.
     * @example
     * // Delete one AgentMetric
     * const AgentMetric = await prisma.agentMetric.delete({
     *   where: {
     *     // ... filter to delete one AgentMetric
     *   }
     * })
     * 
     */
    delete<T extends AgentMetricDeleteArgs>(args: SelectSubset<T, AgentMetricDeleteArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentMetric.
     * @param {AgentMetricUpdateArgs} args - Arguments to update one AgentMetric.
     * @example
     * // Update one AgentMetric
     * const agentMetric = await prisma.agentMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentMetricUpdateArgs>(args: SelectSubset<T, AgentMetricUpdateArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentMetrics.
     * @param {AgentMetricDeleteManyArgs} args - Arguments to filter AgentMetrics to delete.
     * @example
     * // Delete a few AgentMetrics
     * const { count } = await prisma.agentMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentMetricDeleteManyArgs>(args?: SelectSubset<T, AgentMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentMetrics
     * const agentMetric = await prisma.agentMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentMetricUpdateManyArgs>(args: SelectSubset<T, AgentMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentMetrics and returns the data updated in the database.
     * @param {AgentMetricUpdateManyAndReturnArgs} args - Arguments to update many AgentMetrics.
     * @example
     * // Update many AgentMetrics
     * const agentMetric = await prisma.agentMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentMetrics and only return the `id`
     * const agentMetricWithIdOnly = await prisma.agentMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentMetric.
     * @param {AgentMetricUpsertArgs} args - Arguments to update or create a AgentMetric.
     * @example
     * // Update or create a AgentMetric
     * const agentMetric = await prisma.agentMetric.upsert({
     *   create: {
     *     // ... data to create a AgentMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentMetric we want to update
     *   }
     * })
     */
    upsert<T extends AgentMetricUpsertArgs>(args: SelectSubset<T, AgentMetricUpsertArgs<ExtArgs>>): Prisma__AgentMetricClient<$Result.GetResult<Prisma.$AgentMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricCountArgs} args - Arguments to filter AgentMetrics to count.
     * @example
     * // Count the number of AgentMetrics
     * const count = await prisma.agentMetric.count({
     *   where: {
     *     // ... the filter for the AgentMetrics we want to count
     *   }
     * })
    **/
    count<T extends AgentMetricCountArgs>(
      args?: Subset<T, AgentMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentMetricAggregateArgs>(args: Subset<T, AgentMetricAggregateArgs>): Prisma.PrismaPromise<GetAgentMetricAggregateType<T>>

    /**
     * Group by AgentMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentMetricGroupByArgs['orderBy'] }
        : { orderBy?: AgentMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentMetric model
   */
  readonly fields: AgentMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentMetric model
   */
  interface AgentMetricFieldRefs {
    readonly id: FieldRef<"AgentMetric", 'String'>
    readonly agentId: FieldRef<"AgentMetric", 'String'>
    readonly date: FieldRef<"AgentMetric", 'DateTime'>
    readonly totalConversations: FieldRef<"AgentMetric", 'Int'>
    readonly totalMessages: FieldRef<"AgentMetric", 'Int'>
    readonly avgMessagesPerConvo: FieldRef<"AgentMetric", 'Float'>
    readonly avgResponseTimeMs: FieldRef<"AgentMetric", 'Int'>
    readonly totalTokensUsed: FieldRef<"AgentMetric", 'Int'>
    readonly toolCallsCount: FieldRef<"AgentMetric", 'Int'>
    readonly toolSuccessRate: FieldRef<"AgentMetric", 'Float'>
    readonly feedbackPositive: FieldRef<"AgentMetric", 'Int'>
    readonly feedbackNegative: FieldRef<"AgentMetric", 'Int'>
    readonly createdAt: FieldRef<"AgentMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentMetric findUnique
   */
  export type AgentMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * Filter, which AgentMetric to fetch.
     */
    where: AgentMetricWhereUniqueInput
  }

  /**
   * AgentMetric findUniqueOrThrow
   */
  export type AgentMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * Filter, which AgentMetric to fetch.
     */
    where: AgentMetricWhereUniqueInput
  }

  /**
   * AgentMetric findFirst
   */
  export type AgentMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * Filter, which AgentMetric to fetch.
     */
    where?: AgentMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMetrics to fetch.
     */
    orderBy?: AgentMetricOrderByWithRelationInput | AgentMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentMetrics.
     */
    cursor?: AgentMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentMetrics.
     */
    distinct?: AgentMetricScalarFieldEnum | AgentMetricScalarFieldEnum[]
  }

  /**
   * AgentMetric findFirstOrThrow
   */
  export type AgentMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * Filter, which AgentMetric to fetch.
     */
    where?: AgentMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMetrics to fetch.
     */
    orderBy?: AgentMetricOrderByWithRelationInput | AgentMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentMetrics.
     */
    cursor?: AgentMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentMetrics.
     */
    distinct?: AgentMetricScalarFieldEnum | AgentMetricScalarFieldEnum[]
  }

  /**
   * AgentMetric findMany
   */
  export type AgentMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * Filter, which AgentMetrics to fetch.
     */
    where?: AgentMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentMetrics to fetch.
     */
    orderBy?: AgentMetricOrderByWithRelationInput | AgentMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentMetrics.
     */
    cursor?: AgentMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentMetrics.
     */
    skip?: number
    distinct?: AgentMetricScalarFieldEnum | AgentMetricScalarFieldEnum[]
  }

  /**
   * AgentMetric create
   */
  export type AgentMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentMetric.
     */
    data: XOR<AgentMetricCreateInput, AgentMetricUncheckedCreateInput>
  }

  /**
   * AgentMetric createMany
   */
  export type AgentMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentMetrics.
     */
    data: AgentMetricCreateManyInput | AgentMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentMetric createManyAndReturn
   */
  export type AgentMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * The data used to create many AgentMetrics.
     */
    data: AgentMetricCreateManyInput | AgentMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentMetric update
   */
  export type AgentMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentMetric.
     */
    data: XOR<AgentMetricUpdateInput, AgentMetricUncheckedUpdateInput>
    /**
     * Choose, which AgentMetric to update.
     */
    where: AgentMetricWhereUniqueInput
  }

  /**
   * AgentMetric updateMany
   */
  export type AgentMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentMetrics.
     */
    data: XOR<AgentMetricUpdateManyMutationInput, AgentMetricUncheckedUpdateManyInput>
    /**
     * Filter which AgentMetrics to update
     */
    where?: AgentMetricWhereInput
    /**
     * Limit how many AgentMetrics to update.
     */
    limit?: number
  }

  /**
   * AgentMetric updateManyAndReturn
   */
  export type AgentMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * The data used to update AgentMetrics.
     */
    data: XOR<AgentMetricUpdateManyMutationInput, AgentMetricUncheckedUpdateManyInput>
    /**
     * Filter which AgentMetrics to update
     */
    where?: AgentMetricWhereInput
    /**
     * Limit how many AgentMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentMetric upsert
   */
  export type AgentMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentMetric to update in case it exists.
     */
    where: AgentMetricWhereUniqueInput
    /**
     * In case the AgentMetric found by the `where` argument doesn't exist, create a new AgentMetric with this data.
     */
    create: XOR<AgentMetricCreateInput, AgentMetricUncheckedCreateInput>
    /**
     * In case the AgentMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentMetricUpdateInput, AgentMetricUncheckedUpdateInput>
  }

  /**
   * AgentMetric delete
   */
  export type AgentMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
    /**
     * Filter which AgentMetric to delete.
     */
    where: AgentMetricWhereUniqueInput
  }

  /**
   * AgentMetric deleteMany
   */
  export type AgentMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentMetrics to delete
     */
    where?: AgentMetricWhereInput
    /**
     * Limit how many AgentMetrics to delete.
     */
    limit?: number
  }

  /**
   * AgentMetric without action
   */
  export type AgentMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentMetric
     */
    select?: AgentMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentMetric
     */
    omit?: AgentMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentMetricInclude<ExtArgs> | null
  }


  /**
   * Model ScanResult
   */

  export type AggregateScanResult = {
    _count: ScanResultCountAggregateOutputType | null
    _avg: ScanResultAvgAggregateOutputType | null
    _sum: ScanResultSumAggregateOutputType | null
    _min: ScanResultMinAggregateOutputType | null
    _max: ScanResultMaxAggregateOutputType | null
  }

  export type ScanResultAvgAggregateOutputType = {
    totalSignals: number | null
    criticalCount: number | null
    highCount: number | null
    mediumCount: number | null
    lowCount: number | null
  }

  export type ScanResultSumAggregateOutputType = {
    totalSignals: number | null
    criticalCount: number | null
    highCount: number | null
    mediumCount: number | null
    lowCount: number | null
  }

  export type ScanResultMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    category: $Enums.ScanCategory | null
    totalSignals: number | null
    criticalCount: number | null
    highCount: number | null
    mediumCount: number | null
    lowCount: number | null
    scannedAt: Date | null
  }

  export type ScanResultMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    category: $Enums.ScanCategory | null
    totalSignals: number | null
    criticalCount: number | null
    highCount: number | null
    mediumCount: number | null
    lowCount: number | null
    scannedAt: Date | null
  }

  export type ScanResultCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    category: number
    signals: number
    totalSignals: number
    criticalCount: number
    highCount: number
    mediumCount: number
    lowCount: number
    scannedAt: number
    _all: number
  }


  export type ScanResultAvgAggregateInputType = {
    totalSignals?: true
    criticalCount?: true
    highCount?: true
    mediumCount?: true
    lowCount?: true
  }

  export type ScanResultSumAggregateInputType = {
    totalSignals?: true
    criticalCount?: true
    highCount?: true
    mediumCount?: true
    lowCount?: true
  }

  export type ScanResultMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    category?: true
    totalSignals?: true
    criticalCount?: true
    highCount?: true
    mediumCount?: true
    lowCount?: true
    scannedAt?: true
  }

  export type ScanResultMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    category?: true
    totalSignals?: true
    criticalCount?: true
    highCount?: true
    mediumCount?: true
    lowCount?: true
    scannedAt?: true
  }

  export type ScanResultCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    category?: true
    signals?: true
    totalSignals?: true
    criticalCount?: true
    highCount?: true
    mediumCount?: true
    lowCount?: true
    scannedAt?: true
    _all?: true
  }

  export type ScanResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScanResult to aggregate.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScanResults
    **/
    _count?: true | ScanResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScanResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScanResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScanResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScanResultMaxAggregateInputType
  }

  export type GetScanResultAggregateType<T extends ScanResultAggregateArgs> = {
        [P in keyof T & keyof AggregateScanResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScanResult[P]>
      : GetScalarType<T[P], AggregateScanResult[P]>
  }




  export type ScanResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScanResultWhereInput
    orderBy?: ScanResultOrderByWithAggregationInput | ScanResultOrderByWithAggregationInput[]
    by: ScanResultScalarFieldEnum[] | ScanResultScalarFieldEnum
    having?: ScanResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScanResultCountAggregateInputType | true
    _avg?: ScanResultAvgAggregateInputType
    _sum?: ScanResultSumAggregateInputType
    _min?: ScanResultMinAggregateInputType
    _max?: ScanResultMaxAggregateInputType
  }

  export type ScanResultGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    category: $Enums.ScanCategory
    signals: JsonValue
    totalSignals: number
    criticalCount: number
    highCount: number
    mediumCount: number
    lowCount: number
    scannedAt: Date
    _count: ScanResultCountAggregateOutputType | null
    _avg: ScanResultAvgAggregateOutputType | null
    _sum: ScanResultSumAggregateOutputType | null
    _min: ScanResultMinAggregateOutputType | null
    _max: ScanResultMaxAggregateOutputType | null
  }

  type GetScanResultGroupByPayload<T extends ScanResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScanResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScanResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScanResultGroupByOutputType[P]>
            : GetScalarType<T[P], ScanResultGroupByOutputType[P]>
        }
      >
    >


  export type ScanResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    category?: boolean
    signals?: boolean
    totalSignals?: boolean
    criticalCount?: boolean
    highCount?: boolean
    mediumCount?: boolean
    lowCount?: boolean
    scannedAt?: boolean
  }, ExtArgs["result"]["scanResult"]>

  export type ScanResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    category?: boolean
    signals?: boolean
    totalSignals?: boolean
    criticalCount?: boolean
    highCount?: boolean
    mediumCount?: boolean
    lowCount?: boolean
    scannedAt?: boolean
  }, ExtArgs["result"]["scanResult"]>

  export type ScanResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    category?: boolean
    signals?: boolean
    totalSignals?: boolean
    criticalCount?: boolean
    highCount?: boolean
    mediumCount?: boolean
    lowCount?: boolean
    scannedAt?: boolean
  }, ExtArgs["result"]["scanResult"]>

  export type ScanResultSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    category?: boolean
    signals?: boolean
    totalSignals?: boolean
    criticalCount?: boolean
    highCount?: boolean
    mediumCount?: boolean
    lowCount?: boolean
    scannedAt?: boolean
  }

  export type ScanResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "workspaceId" | "category" | "signals" | "totalSignals" | "criticalCount" | "highCount" | "mediumCount" | "lowCount" | "scannedAt", ExtArgs["result"]["scanResult"]>

  export type $ScanResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScanResult"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      category: $Enums.ScanCategory
      signals: Prisma.JsonValue
      totalSignals: number
      criticalCount: number
      highCount: number
      mediumCount: number
      lowCount: number
      scannedAt: Date
    }, ExtArgs["result"]["scanResult"]>
    composites: {}
  }

  type ScanResultGetPayload<S extends boolean | null | undefined | ScanResultDefaultArgs> = $Result.GetResult<Prisma.$ScanResultPayload, S>

  type ScanResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScanResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScanResultCountAggregateInputType | true
    }

  export interface ScanResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScanResult'], meta: { name: 'ScanResult' } }
    /**
     * Find zero or one ScanResult that matches the filter.
     * @param {ScanResultFindUniqueArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScanResultFindUniqueArgs>(args: SelectSubset<T, ScanResultFindUniqueArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScanResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScanResultFindUniqueOrThrowArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScanResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ScanResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScanResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultFindFirstArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScanResultFindFirstArgs>(args?: SelectSubset<T, ScanResultFindFirstArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScanResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultFindFirstOrThrowArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScanResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ScanResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScanResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScanResults
     * const scanResults = await prisma.scanResult.findMany()
     * 
     * // Get first 10 ScanResults
     * const scanResults = await prisma.scanResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scanResultWithIdOnly = await prisma.scanResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScanResultFindManyArgs>(args?: SelectSubset<T, ScanResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScanResult.
     * @param {ScanResultCreateArgs} args - Arguments to create a ScanResult.
     * @example
     * // Create one ScanResult
     * const ScanResult = await prisma.scanResult.create({
     *   data: {
     *     // ... data to create a ScanResult
     *   }
     * })
     * 
     */
    create<T extends ScanResultCreateArgs>(args: SelectSubset<T, ScanResultCreateArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScanResults.
     * @param {ScanResultCreateManyArgs} args - Arguments to create many ScanResults.
     * @example
     * // Create many ScanResults
     * const scanResult = await prisma.scanResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScanResultCreateManyArgs>(args?: SelectSubset<T, ScanResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScanResults and returns the data saved in the database.
     * @param {ScanResultCreateManyAndReturnArgs} args - Arguments to create many ScanResults.
     * @example
     * // Create many ScanResults
     * const scanResult = await prisma.scanResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScanResults and only return the `id`
     * const scanResultWithIdOnly = await prisma.scanResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScanResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ScanResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScanResult.
     * @param {ScanResultDeleteArgs} args - Arguments to delete one ScanResult.
     * @example
     * // Delete one ScanResult
     * const ScanResult = await prisma.scanResult.delete({
     *   where: {
     *     // ... filter to delete one ScanResult
     *   }
     * })
     * 
     */
    delete<T extends ScanResultDeleteArgs>(args: SelectSubset<T, ScanResultDeleteArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScanResult.
     * @param {ScanResultUpdateArgs} args - Arguments to update one ScanResult.
     * @example
     * // Update one ScanResult
     * const scanResult = await prisma.scanResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScanResultUpdateArgs>(args: SelectSubset<T, ScanResultUpdateArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScanResults.
     * @param {ScanResultDeleteManyArgs} args - Arguments to filter ScanResults to delete.
     * @example
     * // Delete a few ScanResults
     * const { count } = await prisma.scanResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScanResultDeleteManyArgs>(args?: SelectSubset<T, ScanResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScanResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScanResults
     * const scanResult = await prisma.scanResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScanResultUpdateManyArgs>(args: SelectSubset<T, ScanResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScanResults and returns the data updated in the database.
     * @param {ScanResultUpdateManyAndReturnArgs} args - Arguments to update many ScanResults.
     * @example
     * // Update many ScanResults
     * const scanResult = await prisma.scanResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScanResults and only return the `id`
     * const scanResultWithIdOnly = await prisma.scanResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScanResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ScanResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScanResult.
     * @param {ScanResultUpsertArgs} args - Arguments to update or create a ScanResult.
     * @example
     * // Update or create a ScanResult
     * const scanResult = await prisma.scanResult.upsert({
     *   create: {
     *     // ... data to create a ScanResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScanResult we want to update
     *   }
     * })
     */
    upsert<T extends ScanResultUpsertArgs>(args: SelectSubset<T, ScanResultUpsertArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScanResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultCountArgs} args - Arguments to filter ScanResults to count.
     * @example
     * // Count the number of ScanResults
     * const count = await prisma.scanResult.count({
     *   where: {
     *     // ... the filter for the ScanResults we want to count
     *   }
     * })
    **/
    count<T extends ScanResultCountArgs>(
      args?: Subset<T, ScanResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScanResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScanResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScanResultAggregateArgs>(args: Subset<T, ScanResultAggregateArgs>): Prisma.PrismaPromise<GetScanResultAggregateType<T>>

    /**
     * Group by ScanResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScanResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScanResultGroupByArgs['orderBy'] }
        : { orderBy?: ScanResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScanResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScanResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScanResult model
   */
  readonly fields: ScanResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScanResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScanResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScanResult model
   */
  interface ScanResultFieldRefs {
    readonly id: FieldRef<"ScanResult", 'String'>
    readonly userId: FieldRef<"ScanResult", 'String'>
    readonly workspaceId: FieldRef<"ScanResult", 'String'>
    readonly category: FieldRef<"ScanResult", 'ScanCategory'>
    readonly signals: FieldRef<"ScanResult", 'Json'>
    readonly totalSignals: FieldRef<"ScanResult", 'Int'>
    readonly criticalCount: FieldRef<"ScanResult", 'Int'>
    readonly highCount: FieldRef<"ScanResult", 'Int'>
    readonly mediumCount: FieldRef<"ScanResult", 'Int'>
    readonly lowCount: FieldRef<"ScanResult", 'Int'>
    readonly scannedAt: FieldRef<"ScanResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScanResult findUnique
   */
  export type ScanResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult findUniqueOrThrow
   */
  export type ScanResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult findFirst
   */
  export type ScanResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScanResults.
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScanResults.
     */
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * ScanResult findFirstOrThrow
   */
  export type ScanResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScanResults.
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScanResults.
     */
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * ScanResult findMany
   */
  export type ScanResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * Filter, which ScanResults to fetch.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScanResults.
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * ScanResult create
   */
  export type ScanResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * The data needed to create a ScanResult.
     */
    data: XOR<ScanResultCreateInput, ScanResultUncheckedCreateInput>
  }

  /**
   * ScanResult createMany
   */
  export type ScanResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScanResults.
     */
    data: ScanResultCreateManyInput | ScanResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScanResult createManyAndReturn
   */
  export type ScanResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * The data used to create many ScanResults.
     */
    data: ScanResultCreateManyInput | ScanResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScanResult update
   */
  export type ScanResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * The data needed to update a ScanResult.
     */
    data: XOR<ScanResultUpdateInput, ScanResultUncheckedUpdateInput>
    /**
     * Choose, which ScanResult to update.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult updateMany
   */
  export type ScanResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScanResults.
     */
    data: XOR<ScanResultUpdateManyMutationInput, ScanResultUncheckedUpdateManyInput>
    /**
     * Filter which ScanResults to update
     */
    where?: ScanResultWhereInput
    /**
     * Limit how many ScanResults to update.
     */
    limit?: number
  }

  /**
   * ScanResult updateManyAndReturn
   */
  export type ScanResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * The data used to update ScanResults.
     */
    data: XOR<ScanResultUpdateManyMutationInput, ScanResultUncheckedUpdateManyInput>
    /**
     * Filter which ScanResults to update
     */
    where?: ScanResultWhereInput
    /**
     * Limit how many ScanResults to update.
     */
    limit?: number
  }

  /**
   * ScanResult upsert
   */
  export type ScanResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * The filter to search for the ScanResult to update in case it exists.
     */
    where: ScanResultWhereUniqueInput
    /**
     * In case the ScanResult found by the `where` argument doesn't exist, create a new ScanResult with this data.
     */
    create: XOR<ScanResultCreateInput, ScanResultUncheckedCreateInput>
    /**
     * In case the ScanResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScanResultUpdateInput, ScanResultUncheckedUpdateInput>
  }

  /**
   * ScanResult delete
   */
  export type ScanResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
    /**
     * Filter which ScanResult to delete.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult deleteMany
   */
  export type ScanResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScanResults to delete
     */
    where?: ScanResultWhereInput
    /**
     * Limit how many ScanResults to delete.
     */
    limit?: number
  }

  /**
   * ScanResult without action
   */
  export type ScanResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScanResult
     */
    omit?: ScanResultOmit<ExtArgs> | null
  }


  /**
   * Model Signal
   */

  export type AggregateSignal = {
    _count: SignalCountAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  export type SignalMinAggregateOutputType = {
    id: string | null
    scanResultId: string | null
    type: string | null
    category: $Enums.ScanCategory | null
    severity: $Enums.SignalSeverity | null
    source: string | null
    title: string | null
    description: string | null
    suggestedTemplateId: string | null
    snoozedUntil: Date | null
    dismissedAt: Date | null
    actedOnAt: Date | null
    detectedAt: Date | null
  }

  export type SignalMaxAggregateOutputType = {
    id: string | null
    scanResultId: string | null
    type: string | null
    category: $Enums.ScanCategory | null
    severity: $Enums.SignalSeverity | null
    source: string | null
    title: string | null
    description: string | null
    suggestedTemplateId: string | null
    snoozedUntil: Date | null
    dismissedAt: Date | null
    actedOnAt: Date | null
    detectedAt: Date | null
  }

  export type SignalCountAggregateOutputType = {
    id: number
    scanResultId: number
    type: number
    category: number
    severity: number
    source: number
    title: number
    description: number
    metadata: number
    suggestedTemplateId: number
    snoozedUntil: number
    dismissedAt: number
    actedOnAt: number
    detectedAt: number
    _all: number
  }


  export type SignalMinAggregateInputType = {
    id?: true
    scanResultId?: true
    type?: true
    category?: true
    severity?: true
    source?: true
    title?: true
    description?: true
    suggestedTemplateId?: true
    snoozedUntil?: true
    dismissedAt?: true
    actedOnAt?: true
    detectedAt?: true
  }

  export type SignalMaxAggregateInputType = {
    id?: true
    scanResultId?: true
    type?: true
    category?: true
    severity?: true
    source?: true
    title?: true
    description?: true
    suggestedTemplateId?: true
    snoozedUntil?: true
    dismissedAt?: true
    actedOnAt?: true
    detectedAt?: true
  }

  export type SignalCountAggregateInputType = {
    id?: true
    scanResultId?: true
    type?: true
    category?: true
    severity?: true
    source?: true
    title?: true
    description?: true
    metadata?: true
    suggestedTemplateId?: true
    snoozedUntil?: true
    dismissedAt?: true
    actedOnAt?: true
    detectedAt?: true
    _all?: true
  }

  export type SignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signal to aggregate.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signals
    **/
    _count?: true | SignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalMaxAggregateInputType
  }

  export type GetSignalAggregateType<T extends SignalAggregateArgs> = {
        [P in keyof T & keyof AggregateSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignal[P]>
      : GetScalarType<T[P], AggregateSignal[P]>
  }




  export type SignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithAggregationInput | SignalOrderByWithAggregationInput[]
    by: SignalScalarFieldEnum[] | SignalScalarFieldEnum
    having?: SignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalCountAggregateInputType | true
    _min?: SignalMinAggregateInputType
    _max?: SignalMaxAggregateInputType
  }

  export type SignalGroupByOutputType = {
    id: string
    scanResultId: string
    type: string
    category: $Enums.ScanCategory
    severity: $Enums.SignalSeverity
    source: string
    title: string
    description: string
    metadata: JsonValue
    suggestedTemplateId: string | null
    snoozedUntil: Date | null
    dismissedAt: Date | null
    actedOnAt: Date | null
    detectedAt: Date
    _count: SignalCountAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  type GetSignalGroupByPayload<T extends SignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalGroupByOutputType[P]>
            : GetScalarType<T[P], SignalGroupByOutputType[P]>
        }
      >
    >


  export type SignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scanResultId?: boolean
    type?: boolean
    category?: boolean
    severity?: boolean
    source?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    suggestedTemplateId?: boolean
    snoozedUntil?: boolean
    dismissedAt?: boolean
    actedOnAt?: boolean
    detectedAt?: boolean
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scanResultId?: boolean
    type?: boolean
    category?: boolean
    severity?: boolean
    source?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    suggestedTemplateId?: boolean
    snoozedUntil?: boolean
    dismissedAt?: boolean
    actedOnAt?: boolean
    detectedAt?: boolean
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scanResultId?: boolean
    type?: boolean
    category?: boolean
    severity?: boolean
    source?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    suggestedTemplateId?: boolean
    snoozedUntil?: boolean
    dismissedAt?: boolean
    actedOnAt?: boolean
    detectedAt?: boolean
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectScalar = {
    id?: boolean
    scanResultId?: boolean
    type?: boolean
    category?: boolean
    severity?: boolean
    source?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    suggestedTemplateId?: boolean
    snoozedUntil?: boolean
    dismissedAt?: boolean
    actedOnAt?: boolean
    detectedAt?: boolean
  }

  export type SignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scanResultId" | "type" | "category" | "severity" | "source" | "title" | "description" | "metadata" | "suggestedTemplateId" | "snoozedUntil" | "dismissedAt" | "actedOnAt" | "detectedAt", ExtArgs["result"]["signal"]>

  export type $SignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scanResultId: string
      type: string
      category: $Enums.ScanCategory
      severity: $Enums.SignalSeverity
      source: string
      title: string
      description: string
      metadata: Prisma.JsonValue
      suggestedTemplateId: string | null
      snoozedUntil: Date | null
      dismissedAt: Date | null
      actedOnAt: Date | null
      detectedAt: Date
    }, ExtArgs["result"]["signal"]>
    composites: {}
  }

  type SignalGetPayload<S extends boolean | null | undefined | SignalDefaultArgs> = $Result.GetResult<Prisma.$SignalPayload, S>

  type SignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignalCountAggregateInputType | true
    }

  export interface SignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signal'], meta: { name: 'Signal' } }
    /**
     * Find zero or one Signal that matches the filter.
     * @param {SignalFindUniqueArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalFindUniqueArgs>(args: SelectSubset<T, SignalFindUniqueArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignalFindUniqueOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalFindFirstArgs>(args?: SelectSubset<T, SignalFindFirstArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signals
     * const signals = await prisma.signal.findMany()
     * 
     * // Get first 10 Signals
     * const signals = await prisma.signal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalWithIdOnly = await prisma.signal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignalFindManyArgs>(args?: SelectSubset<T, SignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signal.
     * @param {SignalCreateArgs} args - Arguments to create a Signal.
     * @example
     * // Create one Signal
     * const Signal = await prisma.signal.create({
     *   data: {
     *     // ... data to create a Signal
     *   }
     * })
     * 
     */
    create<T extends SignalCreateArgs>(args: SelectSubset<T, SignalCreateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signals.
     * @param {SignalCreateManyArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalCreateManyArgs>(args?: SelectSubset<T, SignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signals and returns the data saved in the database.
     * @param {SignalCreateManyAndReturnArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signals and only return the `id`
     * const signalWithIdOnly = await prisma.signal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignalCreateManyAndReturnArgs>(args?: SelectSubset<T, SignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signal.
     * @param {SignalDeleteArgs} args - Arguments to delete one Signal.
     * @example
     * // Delete one Signal
     * const Signal = await prisma.signal.delete({
     *   where: {
     *     // ... filter to delete one Signal
     *   }
     * })
     * 
     */
    delete<T extends SignalDeleteArgs>(args: SelectSubset<T, SignalDeleteArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signal.
     * @param {SignalUpdateArgs} args - Arguments to update one Signal.
     * @example
     * // Update one Signal
     * const signal = await prisma.signal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalUpdateArgs>(args: SelectSubset<T, SignalUpdateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signals.
     * @param {SignalDeleteManyArgs} args - Arguments to filter Signals to delete.
     * @example
     * // Delete a few Signals
     * const { count } = await prisma.signal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalDeleteManyArgs>(args?: SelectSubset<T, SignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalUpdateManyArgs>(args: SelectSubset<T, SignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals and returns the data updated in the database.
     * @param {SignalUpdateManyAndReturnArgs} args - Arguments to update many Signals.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signals and only return the `id`
     * const signalWithIdOnly = await prisma.signal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SignalUpdateManyAndReturnArgs>(args: SelectSubset<T, SignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signal.
     * @param {SignalUpsertArgs} args - Arguments to update or create a Signal.
     * @example
     * // Update or create a Signal
     * const signal = await prisma.signal.upsert({
     *   create: {
     *     // ... data to create a Signal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signal we want to update
     *   }
     * })
     */
    upsert<T extends SignalUpsertArgs>(args: SelectSubset<T, SignalUpsertArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalCountArgs} args - Arguments to filter Signals to count.
     * @example
     * // Count the number of Signals
     * const count = await prisma.signal.count({
     *   where: {
     *     // ... the filter for the Signals we want to count
     *   }
     * })
    **/
    count<T extends SignalCountArgs>(
      args?: Subset<T, SignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalAggregateArgs>(args: Subset<T, SignalAggregateArgs>): Prisma.PrismaPromise<GetSignalAggregateType<T>>

    /**
     * Group by Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalGroupByArgs['orderBy'] }
        : { orderBy?: SignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signal model
   */
  readonly fields: SignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signal model
   */
  interface SignalFieldRefs {
    readonly id: FieldRef<"Signal", 'String'>
    readonly scanResultId: FieldRef<"Signal", 'String'>
    readonly type: FieldRef<"Signal", 'String'>
    readonly category: FieldRef<"Signal", 'ScanCategory'>
    readonly severity: FieldRef<"Signal", 'SignalSeverity'>
    readonly source: FieldRef<"Signal", 'String'>
    readonly title: FieldRef<"Signal", 'String'>
    readonly description: FieldRef<"Signal", 'String'>
    readonly metadata: FieldRef<"Signal", 'Json'>
    readonly suggestedTemplateId: FieldRef<"Signal", 'String'>
    readonly snoozedUntil: FieldRef<"Signal", 'DateTime'>
    readonly dismissedAt: FieldRef<"Signal", 'DateTime'>
    readonly actedOnAt: FieldRef<"Signal", 'DateTime'>
    readonly detectedAt: FieldRef<"Signal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Signal findUnique
   */
  export type SignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findUniqueOrThrow
   */
  export type SignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findFirst
   */
  export type SignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findFirstOrThrow
   */
  export type SignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findMany
   */
  export type SignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Filter, which Signals to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal create
   */
  export type SignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data needed to create a Signal.
     */
    data: XOR<SignalCreateInput, SignalUncheckedCreateInput>
  }

  /**
   * Signal createMany
   */
  export type SignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signal createManyAndReturn
   */
  export type SignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signal update
   */
  export type SignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data needed to update a Signal.
     */
    data: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
    /**
     * Choose, which Signal to update.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal updateMany
   */
  export type SignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
  }

  /**
   * Signal updateManyAndReturn
   */
  export type SignalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
  }

  /**
   * Signal upsert
   */
  export type SignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The filter to search for the Signal to update in case it exists.
     */
    where: SignalWhereUniqueInput
    /**
     * In case the Signal found by the `where` argument doesn't exist, create a new Signal with this data.
     */
    create: XOR<SignalCreateInput, SignalUncheckedCreateInput>
    /**
     * In case the Signal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
  }

  /**
   * Signal delete
   */
  export type SignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Filter which Signal to delete.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal deleteMany
   */
  export type SignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signals to delete
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to delete.
     */
    limit?: number
  }

  /**
   * Signal without action
   */
  export type SignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
  }


  /**
   * Model AgentRun
   */

  export type AggregateAgentRun = {
    _count: AgentRunCountAggregateOutputType | null
    _avg: AgentRunAvgAggregateOutputType | null
    _sum: AgentRunSumAggregateOutputType | null
    _min: AgentRunMinAggregateOutputType | null
    _max: AgentRunMaxAggregateOutputType | null
  }

  export type AgentRunAvgAggregateOutputType = {
    llmTokensUsed: number | null
    llmCost: number | null
    l2Score: number | null
  }

  export type AgentRunSumAggregateOutputType = {
    llmTokensUsed: number | null
    llmCost: number | null
    l2Score: number | null
  }

  export type AgentRunMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    workspaceId: string | null
    triggeredAt: Date | null
    triggeredBy: string | null
    outputType: string | null
    outputContent: string | null
    llmModel: string | null
    llmTokensUsed: number | null
    llmCost: number | null
    l1Passed: boolean | null
    l2Score: number | null
    l3Triggered: boolean | null
    l3Blocked: boolean | null
    l3Reason: string | null
    userAction: string | null
    draftDiff: string | null
    finalAction: string | null
    finalAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentRunMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    workspaceId: string | null
    triggeredAt: Date | null
    triggeredBy: string | null
    outputType: string | null
    outputContent: string | null
    llmModel: string | null
    llmTokensUsed: number | null
    llmCost: number | null
    l1Passed: boolean | null
    l2Score: number | null
    l3Triggered: boolean | null
    l3Blocked: boolean | null
    l3Reason: string | null
    userAction: string | null
    draftDiff: string | null
    finalAction: string | null
    finalAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentRunCountAggregateOutputType = {
    id: number
    agentId: number
    userId: number
    workspaceId: number
    triggeredAt: number
    triggeredBy: number
    dataSources: number
    outputType: number
    outputContent: number
    llmModel: number
    llmTokensUsed: number
    llmCost: number
    l1Assertions: number
    l1Passed: number
    l2Score: number
    l2Breakdown: number
    l3Triggered: number
    l3Blocked: number
    l3Reason: number
    userAction: number
    draftDiff: number
    finalAction: number
    finalAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentRunAvgAggregateInputType = {
    llmTokensUsed?: true
    llmCost?: true
    l2Score?: true
  }

  export type AgentRunSumAggregateInputType = {
    llmTokensUsed?: true
    llmCost?: true
    l2Score?: true
  }

  export type AgentRunMinAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    workspaceId?: true
    triggeredAt?: true
    triggeredBy?: true
    outputType?: true
    outputContent?: true
    llmModel?: true
    llmTokensUsed?: true
    llmCost?: true
    l1Passed?: true
    l2Score?: true
    l3Triggered?: true
    l3Blocked?: true
    l3Reason?: true
    userAction?: true
    draftDiff?: true
    finalAction?: true
    finalAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentRunMaxAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    workspaceId?: true
    triggeredAt?: true
    triggeredBy?: true
    outputType?: true
    outputContent?: true
    llmModel?: true
    llmTokensUsed?: true
    llmCost?: true
    l1Passed?: true
    l2Score?: true
    l3Triggered?: true
    l3Blocked?: true
    l3Reason?: true
    userAction?: true
    draftDiff?: true
    finalAction?: true
    finalAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentRunCountAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    workspaceId?: true
    triggeredAt?: true
    triggeredBy?: true
    dataSources?: true
    outputType?: true
    outputContent?: true
    llmModel?: true
    llmTokensUsed?: true
    llmCost?: true
    l1Assertions?: true
    l1Passed?: true
    l2Score?: true
    l2Breakdown?: true
    l3Triggered?: true
    l3Blocked?: true
    l3Reason?: true
    userAction?: true
    draftDiff?: true
    finalAction?: true
    finalAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentRun to aggregate.
     */
    where?: AgentRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRuns to fetch.
     */
    orderBy?: AgentRunOrderByWithRelationInput | AgentRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentRuns
    **/
    _count?: true | AgentRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentRunMaxAggregateInputType
  }

  export type GetAgentRunAggregateType<T extends AgentRunAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentRun[P]>
      : GetScalarType<T[P], AggregateAgentRun[P]>
  }




  export type AgentRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentRunWhereInput
    orderBy?: AgentRunOrderByWithAggregationInput | AgentRunOrderByWithAggregationInput[]
    by: AgentRunScalarFieldEnum[] | AgentRunScalarFieldEnum
    having?: AgentRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentRunCountAggregateInputType | true
    _avg?: AgentRunAvgAggregateInputType
    _sum?: AgentRunSumAggregateInputType
    _min?: AgentRunMinAggregateInputType
    _max?: AgentRunMaxAggregateInputType
  }

  export type AgentRunGroupByOutputType = {
    id: string
    agentId: string
    userId: string
    workspaceId: string
    triggeredAt: Date
    triggeredBy: string
    dataSources: JsonValue
    outputType: string | null
    outputContent: string | null
    llmModel: string
    llmTokensUsed: number
    llmCost: number
    l1Assertions: JsonValue
    l1Passed: boolean
    l2Score: number
    l2Breakdown: JsonValue
    l3Triggered: boolean
    l3Blocked: boolean | null
    l3Reason: string | null
    userAction: string | null
    draftDiff: string | null
    finalAction: string | null
    finalAt: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AgentRunCountAggregateOutputType | null
    _avg: AgentRunAvgAggregateOutputType | null
    _sum: AgentRunSumAggregateOutputType | null
    _min: AgentRunMinAggregateOutputType | null
    _max: AgentRunMaxAggregateOutputType | null
  }

  type GetAgentRunGroupByPayload<T extends AgentRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentRunGroupByOutputType[P]>
            : GetScalarType<T[P], AgentRunGroupByOutputType[P]>
        }
      >
    >


  export type AgentRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    workspaceId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    dataSources?: boolean
    outputType?: boolean
    outputContent?: boolean
    llmModel?: boolean
    llmTokensUsed?: boolean
    llmCost?: boolean
    l1Assertions?: boolean
    l1Passed?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    l3Reason?: boolean
    userAction?: boolean
    draftDiff?: boolean
    finalAction?: boolean
    finalAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentRun"]>

  export type AgentRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    workspaceId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    dataSources?: boolean
    outputType?: boolean
    outputContent?: boolean
    llmModel?: boolean
    llmTokensUsed?: boolean
    llmCost?: boolean
    l1Assertions?: boolean
    l1Passed?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    l3Reason?: boolean
    userAction?: boolean
    draftDiff?: boolean
    finalAction?: boolean
    finalAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentRun"]>

  export type AgentRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    workspaceId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    dataSources?: boolean
    outputType?: boolean
    outputContent?: boolean
    llmModel?: boolean
    llmTokensUsed?: boolean
    llmCost?: boolean
    l1Assertions?: boolean
    l1Passed?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    l3Reason?: boolean
    userAction?: boolean
    draftDiff?: boolean
    finalAction?: boolean
    finalAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentRun"]>

  export type AgentRunSelectScalar = {
    id?: boolean
    agentId?: boolean
    userId?: boolean
    workspaceId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    dataSources?: boolean
    outputType?: boolean
    outputContent?: boolean
    llmModel?: boolean
    llmTokensUsed?: boolean
    llmCost?: boolean
    l1Assertions?: boolean
    l1Passed?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    l3Reason?: boolean
    userAction?: boolean
    draftDiff?: boolean
    finalAction?: boolean
    finalAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "userId" | "workspaceId" | "triggeredAt" | "triggeredBy" | "dataSources" | "outputType" | "outputContent" | "llmModel" | "llmTokensUsed" | "llmCost" | "l1Assertions" | "l1Passed" | "l2Score" | "l2Breakdown" | "l3Triggered" | "l3Blocked" | "l3Reason" | "userAction" | "draftDiff" | "finalAction" | "finalAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["agentRun"]>

  export type $AgentRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentRun"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      userId: string
      workspaceId: string
      triggeredAt: Date
      triggeredBy: string
      dataSources: Prisma.JsonValue
      outputType: string | null
      outputContent: string | null
      llmModel: string
      llmTokensUsed: number
      llmCost: number
      l1Assertions: Prisma.JsonValue
      l1Passed: boolean
      l2Score: number
      l2Breakdown: Prisma.JsonValue
      l3Triggered: boolean
      l3Blocked: boolean | null
      l3Reason: string | null
      userAction: string | null
      draftDiff: string | null
      finalAction: string | null
      finalAt: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentRun"]>
    composites: {}
  }

  type AgentRunGetPayload<S extends boolean | null | undefined | AgentRunDefaultArgs> = $Result.GetResult<Prisma.$AgentRunPayload, S>

  type AgentRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentRunCountAggregateInputType | true
    }

  export interface AgentRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentRun'], meta: { name: 'AgentRun' } }
    /**
     * Find zero or one AgentRun that matches the filter.
     * @param {AgentRunFindUniqueArgs} args - Arguments to find a AgentRun
     * @example
     * // Get one AgentRun
     * const agentRun = await prisma.agentRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentRunFindUniqueArgs>(args: SelectSubset<T, AgentRunFindUniqueArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentRunFindUniqueOrThrowArgs} args - Arguments to find a AgentRun
     * @example
     * // Get one AgentRun
     * const agentRun = await prisma.agentRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentRunFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunFindFirstArgs} args - Arguments to find a AgentRun
     * @example
     * // Get one AgentRun
     * const agentRun = await prisma.agentRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentRunFindFirstArgs>(args?: SelectSubset<T, AgentRunFindFirstArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunFindFirstOrThrowArgs} args - Arguments to find a AgentRun
     * @example
     * // Get one AgentRun
     * const agentRun = await prisma.agentRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentRunFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentRuns
     * const agentRuns = await prisma.agentRun.findMany()
     * 
     * // Get first 10 AgentRuns
     * const agentRuns = await prisma.agentRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentRunWithIdOnly = await prisma.agentRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentRunFindManyArgs>(args?: SelectSubset<T, AgentRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentRun.
     * @param {AgentRunCreateArgs} args - Arguments to create a AgentRun.
     * @example
     * // Create one AgentRun
     * const AgentRun = await prisma.agentRun.create({
     *   data: {
     *     // ... data to create a AgentRun
     *   }
     * })
     * 
     */
    create<T extends AgentRunCreateArgs>(args: SelectSubset<T, AgentRunCreateArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentRuns.
     * @param {AgentRunCreateManyArgs} args - Arguments to create many AgentRuns.
     * @example
     * // Create many AgentRuns
     * const agentRun = await prisma.agentRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentRunCreateManyArgs>(args?: SelectSubset<T, AgentRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentRuns and returns the data saved in the database.
     * @param {AgentRunCreateManyAndReturnArgs} args - Arguments to create many AgentRuns.
     * @example
     * // Create many AgentRuns
     * const agentRun = await prisma.agentRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentRuns and only return the `id`
     * const agentRunWithIdOnly = await prisma.agentRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentRunCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentRun.
     * @param {AgentRunDeleteArgs} args - Arguments to delete one AgentRun.
     * @example
     * // Delete one AgentRun
     * const AgentRun = await prisma.agentRun.delete({
     *   where: {
     *     // ... filter to delete one AgentRun
     *   }
     * })
     * 
     */
    delete<T extends AgentRunDeleteArgs>(args: SelectSubset<T, AgentRunDeleteArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentRun.
     * @param {AgentRunUpdateArgs} args - Arguments to update one AgentRun.
     * @example
     * // Update one AgentRun
     * const agentRun = await prisma.agentRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentRunUpdateArgs>(args: SelectSubset<T, AgentRunUpdateArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentRuns.
     * @param {AgentRunDeleteManyArgs} args - Arguments to filter AgentRuns to delete.
     * @example
     * // Delete a few AgentRuns
     * const { count } = await prisma.agentRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentRunDeleteManyArgs>(args?: SelectSubset<T, AgentRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentRuns
     * const agentRun = await prisma.agentRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentRunUpdateManyArgs>(args: SelectSubset<T, AgentRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentRuns and returns the data updated in the database.
     * @param {AgentRunUpdateManyAndReturnArgs} args - Arguments to update many AgentRuns.
     * @example
     * // Update many AgentRuns
     * const agentRun = await prisma.agentRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentRuns and only return the `id`
     * const agentRunWithIdOnly = await prisma.agentRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentRunUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentRun.
     * @param {AgentRunUpsertArgs} args - Arguments to update or create a AgentRun.
     * @example
     * // Update or create a AgentRun
     * const agentRun = await prisma.agentRun.upsert({
     *   create: {
     *     // ... data to create a AgentRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentRun we want to update
     *   }
     * })
     */
    upsert<T extends AgentRunUpsertArgs>(args: SelectSubset<T, AgentRunUpsertArgs<ExtArgs>>): Prisma__AgentRunClient<$Result.GetResult<Prisma.$AgentRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunCountArgs} args - Arguments to filter AgentRuns to count.
     * @example
     * // Count the number of AgentRuns
     * const count = await prisma.agentRun.count({
     *   where: {
     *     // ... the filter for the AgentRuns we want to count
     *   }
     * })
    **/
    count<T extends AgentRunCountArgs>(
      args?: Subset<T, AgentRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentRunAggregateArgs>(args: Subset<T, AgentRunAggregateArgs>): Prisma.PrismaPromise<GetAgentRunAggregateType<T>>

    /**
     * Group by AgentRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentRunGroupByArgs['orderBy'] }
        : { orderBy?: AgentRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentRun model
   */
  readonly fields: AgentRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentRun model
   */
  interface AgentRunFieldRefs {
    readonly id: FieldRef<"AgentRun", 'String'>
    readonly agentId: FieldRef<"AgentRun", 'String'>
    readonly userId: FieldRef<"AgentRun", 'String'>
    readonly workspaceId: FieldRef<"AgentRun", 'String'>
    readonly triggeredAt: FieldRef<"AgentRun", 'DateTime'>
    readonly triggeredBy: FieldRef<"AgentRun", 'String'>
    readonly dataSources: FieldRef<"AgentRun", 'Json'>
    readonly outputType: FieldRef<"AgentRun", 'String'>
    readonly outputContent: FieldRef<"AgentRun", 'String'>
    readonly llmModel: FieldRef<"AgentRun", 'String'>
    readonly llmTokensUsed: FieldRef<"AgentRun", 'Int'>
    readonly llmCost: FieldRef<"AgentRun", 'Float'>
    readonly l1Assertions: FieldRef<"AgentRun", 'Json'>
    readonly l1Passed: FieldRef<"AgentRun", 'Boolean'>
    readonly l2Score: FieldRef<"AgentRun", 'Int'>
    readonly l2Breakdown: FieldRef<"AgentRun", 'Json'>
    readonly l3Triggered: FieldRef<"AgentRun", 'Boolean'>
    readonly l3Blocked: FieldRef<"AgentRun", 'Boolean'>
    readonly l3Reason: FieldRef<"AgentRun", 'String'>
    readonly userAction: FieldRef<"AgentRun", 'String'>
    readonly draftDiff: FieldRef<"AgentRun", 'String'>
    readonly finalAction: FieldRef<"AgentRun", 'String'>
    readonly finalAt: FieldRef<"AgentRun", 'DateTime'>
    readonly status: FieldRef<"AgentRun", 'String'>
    readonly createdAt: FieldRef<"AgentRun", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentRun findUnique
   */
  export type AgentRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * Filter, which AgentRun to fetch.
     */
    where: AgentRunWhereUniqueInput
  }

  /**
   * AgentRun findUniqueOrThrow
   */
  export type AgentRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * Filter, which AgentRun to fetch.
     */
    where: AgentRunWhereUniqueInput
  }

  /**
   * AgentRun findFirst
   */
  export type AgentRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * Filter, which AgentRun to fetch.
     */
    where?: AgentRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRuns to fetch.
     */
    orderBy?: AgentRunOrderByWithRelationInput | AgentRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentRuns.
     */
    cursor?: AgentRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentRuns.
     */
    distinct?: AgentRunScalarFieldEnum | AgentRunScalarFieldEnum[]
  }

  /**
   * AgentRun findFirstOrThrow
   */
  export type AgentRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * Filter, which AgentRun to fetch.
     */
    where?: AgentRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRuns to fetch.
     */
    orderBy?: AgentRunOrderByWithRelationInput | AgentRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentRuns.
     */
    cursor?: AgentRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentRuns.
     */
    distinct?: AgentRunScalarFieldEnum | AgentRunScalarFieldEnum[]
  }

  /**
   * AgentRun findMany
   */
  export type AgentRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * Filter, which AgentRuns to fetch.
     */
    where?: AgentRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRuns to fetch.
     */
    orderBy?: AgentRunOrderByWithRelationInput | AgentRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentRuns.
     */
    cursor?: AgentRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRuns.
     */
    skip?: number
    distinct?: AgentRunScalarFieldEnum | AgentRunScalarFieldEnum[]
  }

  /**
   * AgentRun create
   */
  export type AgentRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * The data needed to create a AgentRun.
     */
    data: XOR<AgentRunCreateInput, AgentRunUncheckedCreateInput>
  }

  /**
   * AgentRun createMany
   */
  export type AgentRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentRuns.
     */
    data: AgentRunCreateManyInput | AgentRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentRun createManyAndReturn
   */
  export type AgentRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * The data used to create many AgentRuns.
     */
    data: AgentRunCreateManyInput | AgentRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentRun update
   */
  export type AgentRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * The data needed to update a AgentRun.
     */
    data: XOR<AgentRunUpdateInput, AgentRunUncheckedUpdateInput>
    /**
     * Choose, which AgentRun to update.
     */
    where: AgentRunWhereUniqueInput
  }

  /**
   * AgentRun updateMany
   */
  export type AgentRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentRuns.
     */
    data: XOR<AgentRunUpdateManyMutationInput, AgentRunUncheckedUpdateManyInput>
    /**
     * Filter which AgentRuns to update
     */
    where?: AgentRunWhereInput
    /**
     * Limit how many AgentRuns to update.
     */
    limit?: number
  }

  /**
   * AgentRun updateManyAndReturn
   */
  export type AgentRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * The data used to update AgentRuns.
     */
    data: XOR<AgentRunUpdateManyMutationInput, AgentRunUncheckedUpdateManyInput>
    /**
     * Filter which AgentRuns to update
     */
    where?: AgentRunWhereInput
    /**
     * Limit how many AgentRuns to update.
     */
    limit?: number
  }

  /**
   * AgentRun upsert
   */
  export type AgentRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * The filter to search for the AgentRun to update in case it exists.
     */
    where: AgentRunWhereUniqueInput
    /**
     * In case the AgentRun found by the `where` argument doesn't exist, create a new AgentRun with this data.
     */
    create: XOR<AgentRunCreateInput, AgentRunUncheckedCreateInput>
    /**
     * In case the AgentRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentRunUpdateInput, AgentRunUncheckedUpdateInput>
  }

  /**
   * AgentRun delete
   */
  export type AgentRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
    /**
     * Filter which AgentRun to delete.
     */
    where: AgentRunWhereUniqueInput
  }

  /**
   * AgentRun deleteMany
   */
  export type AgentRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentRuns to delete
     */
    where?: AgentRunWhereInput
    /**
     * Limit how many AgentRuns to delete.
     */
    limit?: number
  }

  /**
   * AgentRun without action
   */
  export type AgentRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRun
     */
    select?: AgentRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRun
     */
    omit?: AgentRunOmit<ExtArgs> | null
  }


  /**
   * Model AiEvent
   */

  export type AggregateAiEvent = {
    _count: AiEventCountAggregateOutputType | null
    _avg: AiEventAvgAggregateOutputType | null
    _sum: AiEventSumAggregateOutputType | null
    _min: AiEventMinAggregateOutputType | null
    _max: AiEventMaxAggregateOutputType | null
  }

  export type AiEventAvgAggregateOutputType = {
    tokensIn: number | null
    tokensOut: number | null
    cost: number | null
    latencyMs: number | null
    stepNumber: number | null
    stepsUsed: number | null
  }

  export type AiEventSumAggregateOutputType = {
    tokensIn: number | null
    tokensOut: number | null
    cost: number | null
    latencyMs: number | null
    stepNumber: number | null
    stepsUsed: number | null
  }

  export type AiEventMinAggregateOutputType = {
    id: string | null
    traceId: string | null
    agentId: string | null
    conversationId: string | null
    userId: string | null
    workspaceId: string | null
    model: string | null
    tier: string | null
    tokensIn: number | null
    tokensOut: number | null
    cost: number | null
    latencyMs: number | null
    stepNumber: number | null
    action: string | null
    toolName: string | null
    stepsUsed: number | null
    evalResult: string | null
    timestamp: Date | null
  }

  export type AiEventMaxAggregateOutputType = {
    id: string | null
    traceId: string | null
    agentId: string | null
    conversationId: string | null
    userId: string | null
    workspaceId: string | null
    model: string | null
    tier: string | null
    tokensIn: number | null
    tokensOut: number | null
    cost: number | null
    latencyMs: number | null
    stepNumber: number | null
    action: string | null
    toolName: string | null
    stepsUsed: number | null
    evalResult: string | null
    timestamp: Date | null
  }

  export type AiEventCountAggregateOutputType = {
    id: number
    traceId: number
    agentId: number
    conversationId: number
    userId: number
    workspaceId: number
    model: number
    tier: number
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber: number
    action: number
    toolName: number
    toolInput: number
    toolOutput: number
    stepsUsed: number
    evalResult: number
    timestamp: number
    _all: number
  }


  export type AiEventAvgAggregateInputType = {
    tokensIn?: true
    tokensOut?: true
    cost?: true
    latencyMs?: true
    stepNumber?: true
    stepsUsed?: true
  }

  export type AiEventSumAggregateInputType = {
    tokensIn?: true
    tokensOut?: true
    cost?: true
    latencyMs?: true
    stepNumber?: true
    stepsUsed?: true
  }

  export type AiEventMinAggregateInputType = {
    id?: true
    traceId?: true
    agentId?: true
    conversationId?: true
    userId?: true
    workspaceId?: true
    model?: true
    tier?: true
    tokensIn?: true
    tokensOut?: true
    cost?: true
    latencyMs?: true
    stepNumber?: true
    action?: true
    toolName?: true
    stepsUsed?: true
    evalResult?: true
    timestamp?: true
  }

  export type AiEventMaxAggregateInputType = {
    id?: true
    traceId?: true
    agentId?: true
    conversationId?: true
    userId?: true
    workspaceId?: true
    model?: true
    tier?: true
    tokensIn?: true
    tokensOut?: true
    cost?: true
    latencyMs?: true
    stepNumber?: true
    action?: true
    toolName?: true
    stepsUsed?: true
    evalResult?: true
    timestamp?: true
  }

  export type AiEventCountAggregateInputType = {
    id?: true
    traceId?: true
    agentId?: true
    conversationId?: true
    userId?: true
    workspaceId?: true
    model?: true
    tier?: true
    tokensIn?: true
    tokensOut?: true
    cost?: true
    latencyMs?: true
    stepNumber?: true
    action?: true
    toolName?: true
    toolInput?: true
    toolOutput?: true
    stepsUsed?: true
    evalResult?: true
    timestamp?: true
    _all?: true
  }

  export type AiEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiEvent to aggregate.
     */
    where?: AiEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiEvents to fetch.
     */
    orderBy?: AiEventOrderByWithRelationInput | AiEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiEvents
    **/
    _count?: true | AiEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiEventMaxAggregateInputType
  }

  export type GetAiEventAggregateType<T extends AiEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAiEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiEvent[P]>
      : GetScalarType<T[P], AggregateAiEvent[P]>
  }




  export type AiEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiEventWhereInput
    orderBy?: AiEventOrderByWithAggregationInput | AiEventOrderByWithAggregationInput[]
    by: AiEventScalarFieldEnum[] | AiEventScalarFieldEnum
    having?: AiEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiEventCountAggregateInputType | true
    _avg?: AiEventAvgAggregateInputType
    _sum?: AiEventSumAggregateInputType
    _min?: AiEventMinAggregateInputType
    _max?: AiEventMaxAggregateInputType
  }

  export type AiEventGroupByOutputType = {
    id: string
    traceId: string | null
    agentId: string | null
    conversationId: string | null
    userId: string
    workspaceId: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber: number
    action: string
    toolName: string | null
    toolInput: JsonValue | null
    toolOutput: JsonValue | null
    stepsUsed: number
    evalResult: string
    timestamp: Date
    _count: AiEventCountAggregateOutputType | null
    _avg: AiEventAvgAggregateOutputType | null
    _sum: AiEventSumAggregateOutputType | null
    _min: AiEventMinAggregateOutputType | null
    _max: AiEventMaxAggregateOutputType | null
  }

  type GetAiEventGroupByPayload<T extends AiEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiEventGroupByOutputType[P]>
            : GetScalarType<T[P], AiEventGroupByOutputType[P]>
        }
      >
    >


  export type AiEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    model?: boolean
    tier?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    cost?: boolean
    latencyMs?: boolean
    stepNumber?: boolean
    action?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    stepsUsed?: boolean
    evalResult?: boolean
    timestamp?: boolean
    trace?: boolean | AiEvent$traceArgs<ExtArgs>
  }, ExtArgs["result"]["aiEvent"]>

  export type AiEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    model?: boolean
    tier?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    cost?: boolean
    latencyMs?: boolean
    stepNumber?: boolean
    action?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    stepsUsed?: boolean
    evalResult?: boolean
    timestamp?: boolean
    trace?: boolean | AiEvent$traceArgs<ExtArgs>
  }, ExtArgs["result"]["aiEvent"]>

  export type AiEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    model?: boolean
    tier?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    cost?: boolean
    latencyMs?: boolean
    stepNumber?: boolean
    action?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    stepsUsed?: boolean
    evalResult?: boolean
    timestamp?: boolean
    trace?: boolean | AiEvent$traceArgs<ExtArgs>
  }, ExtArgs["result"]["aiEvent"]>

  export type AiEventSelectScalar = {
    id?: boolean
    traceId?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    model?: boolean
    tier?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    cost?: boolean
    latencyMs?: boolean
    stepNumber?: boolean
    action?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    stepsUsed?: boolean
    evalResult?: boolean
    timestamp?: boolean
  }

  export type AiEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "traceId" | "agentId" | "conversationId" | "userId" | "workspaceId" | "model" | "tier" | "tokensIn" | "tokensOut" | "cost" | "latencyMs" | "stepNumber" | "action" | "toolName" | "toolInput" | "toolOutput" | "stepsUsed" | "evalResult" | "timestamp", ExtArgs["result"]["aiEvent"]>
  export type AiEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trace?: boolean | AiEvent$traceArgs<ExtArgs>
  }
  export type AiEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trace?: boolean | AiEvent$traceArgs<ExtArgs>
  }
  export type AiEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trace?: boolean | AiEvent$traceArgs<ExtArgs>
  }

  export type $AiEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiEvent"
    objects: {
      trace: Prisma.$AgentTracePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      traceId: string | null
      agentId: string | null
      conversationId: string | null
      userId: string
      workspaceId: string | null
      model: string
      tier: string
      tokensIn: number
      tokensOut: number
      cost: number
      latencyMs: number
      stepNumber: number
      action: string
      toolName: string | null
      toolInput: Prisma.JsonValue | null
      toolOutput: Prisma.JsonValue | null
      stepsUsed: number
      evalResult: string
      timestamp: Date
    }, ExtArgs["result"]["aiEvent"]>
    composites: {}
  }

  type AiEventGetPayload<S extends boolean | null | undefined | AiEventDefaultArgs> = $Result.GetResult<Prisma.$AiEventPayload, S>

  type AiEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiEventCountAggregateInputType | true
    }

  export interface AiEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiEvent'], meta: { name: 'AiEvent' } }
    /**
     * Find zero or one AiEvent that matches the filter.
     * @param {AiEventFindUniqueArgs} args - Arguments to find a AiEvent
     * @example
     * // Get one AiEvent
     * const aiEvent = await prisma.aiEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiEventFindUniqueArgs>(args: SelectSubset<T, AiEventFindUniqueArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiEventFindUniqueOrThrowArgs} args - Arguments to find a AiEvent
     * @example
     * // Get one AiEvent
     * const aiEvent = await prisma.aiEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AiEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventFindFirstArgs} args - Arguments to find a AiEvent
     * @example
     * // Get one AiEvent
     * const aiEvent = await prisma.aiEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiEventFindFirstArgs>(args?: SelectSubset<T, AiEventFindFirstArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventFindFirstOrThrowArgs} args - Arguments to find a AiEvent
     * @example
     * // Get one AiEvent
     * const aiEvent = await prisma.aiEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AiEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiEvents
     * const aiEvents = await prisma.aiEvent.findMany()
     * 
     * // Get first 10 AiEvents
     * const aiEvents = await prisma.aiEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiEventWithIdOnly = await prisma.aiEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiEventFindManyArgs>(args?: SelectSubset<T, AiEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiEvent.
     * @param {AiEventCreateArgs} args - Arguments to create a AiEvent.
     * @example
     * // Create one AiEvent
     * const AiEvent = await prisma.aiEvent.create({
     *   data: {
     *     // ... data to create a AiEvent
     *   }
     * })
     * 
     */
    create<T extends AiEventCreateArgs>(args: SelectSubset<T, AiEventCreateArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiEvents.
     * @param {AiEventCreateManyArgs} args - Arguments to create many AiEvents.
     * @example
     * // Create many AiEvents
     * const aiEvent = await prisma.aiEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiEventCreateManyArgs>(args?: SelectSubset<T, AiEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiEvents and returns the data saved in the database.
     * @param {AiEventCreateManyAndReturnArgs} args - Arguments to create many AiEvents.
     * @example
     * // Create many AiEvents
     * const aiEvent = await prisma.aiEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiEvents and only return the `id`
     * const aiEventWithIdOnly = await prisma.aiEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AiEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiEvent.
     * @param {AiEventDeleteArgs} args - Arguments to delete one AiEvent.
     * @example
     * // Delete one AiEvent
     * const AiEvent = await prisma.aiEvent.delete({
     *   where: {
     *     // ... filter to delete one AiEvent
     *   }
     * })
     * 
     */
    delete<T extends AiEventDeleteArgs>(args: SelectSubset<T, AiEventDeleteArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiEvent.
     * @param {AiEventUpdateArgs} args - Arguments to update one AiEvent.
     * @example
     * // Update one AiEvent
     * const aiEvent = await prisma.aiEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiEventUpdateArgs>(args: SelectSubset<T, AiEventUpdateArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiEvents.
     * @param {AiEventDeleteManyArgs} args - Arguments to filter AiEvents to delete.
     * @example
     * // Delete a few AiEvents
     * const { count } = await prisma.aiEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiEventDeleteManyArgs>(args?: SelectSubset<T, AiEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiEvents
     * const aiEvent = await prisma.aiEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiEventUpdateManyArgs>(args: SelectSubset<T, AiEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiEvents and returns the data updated in the database.
     * @param {AiEventUpdateManyAndReturnArgs} args - Arguments to update many AiEvents.
     * @example
     * // Update many AiEvents
     * const aiEvent = await prisma.aiEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiEvents and only return the `id`
     * const aiEventWithIdOnly = await prisma.aiEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AiEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiEvent.
     * @param {AiEventUpsertArgs} args - Arguments to update or create a AiEvent.
     * @example
     * // Update or create a AiEvent
     * const aiEvent = await prisma.aiEvent.upsert({
     *   create: {
     *     // ... data to create a AiEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiEvent we want to update
     *   }
     * })
     */
    upsert<T extends AiEventUpsertArgs>(args: SelectSubset<T, AiEventUpsertArgs<ExtArgs>>): Prisma__AiEventClient<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventCountArgs} args - Arguments to filter AiEvents to count.
     * @example
     * // Count the number of AiEvents
     * const count = await prisma.aiEvent.count({
     *   where: {
     *     // ... the filter for the AiEvents we want to count
     *   }
     * })
    **/
    count<T extends AiEventCountArgs>(
      args?: Subset<T, AiEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiEventAggregateArgs>(args: Subset<T, AiEventAggregateArgs>): Prisma.PrismaPromise<GetAiEventAggregateType<T>>

    /**
     * Group by AiEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiEventGroupByArgs['orderBy'] }
        : { orderBy?: AiEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiEvent model
   */
  readonly fields: AiEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trace<T extends AiEvent$traceArgs<ExtArgs> = {}>(args?: Subset<T, AiEvent$traceArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiEvent model
   */
  interface AiEventFieldRefs {
    readonly id: FieldRef<"AiEvent", 'String'>
    readonly traceId: FieldRef<"AiEvent", 'String'>
    readonly agentId: FieldRef<"AiEvent", 'String'>
    readonly conversationId: FieldRef<"AiEvent", 'String'>
    readonly userId: FieldRef<"AiEvent", 'String'>
    readonly workspaceId: FieldRef<"AiEvent", 'String'>
    readonly model: FieldRef<"AiEvent", 'String'>
    readonly tier: FieldRef<"AiEvent", 'String'>
    readonly tokensIn: FieldRef<"AiEvent", 'Int'>
    readonly tokensOut: FieldRef<"AiEvent", 'Int'>
    readonly cost: FieldRef<"AiEvent", 'Float'>
    readonly latencyMs: FieldRef<"AiEvent", 'Int'>
    readonly stepNumber: FieldRef<"AiEvent", 'Int'>
    readonly action: FieldRef<"AiEvent", 'String'>
    readonly toolName: FieldRef<"AiEvent", 'String'>
    readonly toolInput: FieldRef<"AiEvent", 'Json'>
    readonly toolOutput: FieldRef<"AiEvent", 'Json'>
    readonly stepsUsed: FieldRef<"AiEvent", 'Int'>
    readonly evalResult: FieldRef<"AiEvent", 'String'>
    readonly timestamp: FieldRef<"AiEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiEvent findUnique
   */
  export type AiEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * Filter, which AiEvent to fetch.
     */
    where: AiEventWhereUniqueInput
  }

  /**
   * AiEvent findUniqueOrThrow
   */
  export type AiEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * Filter, which AiEvent to fetch.
     */
    where: AiEventWhereUniqueInput
  }

  /**
   * AiEvent findFirst
   */
  export type AiEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * Filter, which AiEvent to fetch.
     */
    where?: AiEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiEvents to fetch.
     */
    orderBy?: AiEventOrderByWithRelationInput | AiEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiEvents.
     */
    cursor?: AiEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiEvents.
     */
    distinct?: AiEventScalarFieldEnum | AiEventScalarFieldEnum[]
  }

  /**
   * AiEvent findFirstOrThrow
   */
  export type AiEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * Filter, which AiEvent to fetch.
     */
    where?: AiEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiEvents to fetch.
     */
    orderBy?: AiEventOrderByWithRelationInput | AiEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiEvents.
     */
    cursor?: AiEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiEvents.
     */
    distinct?: AiEventScalarFieldEnum | AiEventScalarFieldEnum[]
  }

  /**
   * AiEvent findMany
   */
  export type AiEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * Filter, which AiEvents to fetch.
     */
    where?: AiEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiEvents to fetch.
     */
    orderBy?: AiEventOrderByWithRelationInput | AiEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiEvents.
     */
    cursor?: AiEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiEvents.
     */
    skip?: number
    distinct?: AiEventScalarFieldEnum | AiEventScalarFieldEnum[]
  }

  /**
   * AiEvent create
   */
  export type AiEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AiEvent.
     */
    data: XOR<AiEventCreateInput, AiEventUncheckedCreateInput>
  }

  /**
   * AiEvent createMany
   */
  export type AiEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiEvents.
     */
    data: AiEventCreateManyInput | AiEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiEvent createManyAndReturn
   */
  export type AiEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * The data used to create many AiEvents.
     */
    data: AiEventCreateManyInput | AiEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiEvent update
   */
  export type AiEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AiEvent.
     */
    data: XOR<AiEventUpdateInput, AiEventUncheckedUpdateInput>
    /**
     * Choose, which AiEvent to update.
     */
    where: AiEventWhereUniqueInput
  }

  /**
   * AiEvent updateMany
   */
  export type AiEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiEvents.
     */
    data: XOR<AiEventUpdateManyMutationInput, AiEventUncheckedUpdateManyInput>
    /**
     * Filter which AiEvents to update
     */
    where?: AiEventWhereInput
    /**
     * Limit how many AiEvents to update.
     */
    limit?: number
  }

  /**
   * AiEvent updateManyAndReturn
   */
  export type AiEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * The data used to update AiEvents.
     */
    data: XOR<AiEventUpdateManyMutationInput, AiEventUncheckedUpdateManyInput>
    /**
     * Filter which AiEvents to update
     */
    where?: AiEventWhereInput
    /**
     * Limit how many AiEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiEvent upsert
   */
  export type AiEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AiEvent to update in case it exists.
     */
    where: AiEventWhereUniqueInput
    /**
     * In case the AiEvent found by the `where` argument doesn't exist, create a new AiEvent with this data.
     */
    create: XOR<AiEventCreateInput, AiEventUncheckedCreateInput>
    /**
     * In case the AiEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiEventUpdateInput, AiEventUncheckedUpdateInput>
  }

  /**
   * AiEvent delete
   */
  export type AiEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    /**
     * Filter which AiEvent to delete.
     */
    where: AiEventWhereUniqueInput
  }

  /**
   * AiEvent deleteMany
   */
  export type AiEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiEvents to delete
     */
    where?: AiEventWhereInput
    /**
     * Limit how many AiEvents to delete.
     */
    limit?: number
  }

  /**
   * AiEvent.trace
   */
  export type AiEvent$traceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    where?: AgentTraceWhereInput
  }

  /**
   * AiEvent without action
   */
  export type AiEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
  }


  /**
   * Model AgentTrace
   */

  export type AggregateAgentTrace = {
    _count: AgentTraceCountAggregateOutputType | null
    _avg: AgentTraceAvgAggregateOutputType | null
    _sum: AgentTraceSumAggregateOutputType | null
    _min: AgentTraceMinAggregateOutputType | null
    _max: AgentTraceMaxAggregateOutputType | null
  }

  export type AgentTraceAvgAggregateOutputType = {
    totalSteps: number | null
    maxSteps: number | null
    totalTokensIn: number | null
    totalTokensOut: number | null
    totalCost: number | null
    latencyMs: number | null
    toolSuccesses: number | null
    toolFailures: number | null
    l2Score: number | null
    feedbackScore: number | null
  }

  export type AgentTraceSumAggregateOutputType = {
    totalSteps: number | null
    maxSteps: number | null
    totalTokensIn: number | null
    totalTokensOut: number | null
    totalCost: number | null
    latencyMs: number | null
    toolSuccesses: number | null
    toolFailures: number | null
    l2Score: number | null
    feedbackScore: number | null
  }

  export type AgentTraceMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    conversationId: string | null
    userId: string | null
    workspaceId: string | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.TraceStatus | null
    totalSteps: number | null
    maxSteps: number | null
    totalTokensIn: number | null
    totalTokensOut: number | null
    totalCost: number | null
    latencyMs: number | null
    toolSuccesses: number | null
    toolFailures: number | null
    l1Passed: boolean | null
    l2Score: number | null
    l3Triggered: boolean | null
    l3Blocked: boolean | null
    feedbackScore: number | null
    feedbackComment: string | null
    userEdited: boolean | null
    editDiff: string | null
  }

  export type AgentTraceMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    conversationId: string | null
    userId: string | null
    workspaceId: string | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.TraceStatus | null
    totalSteps: number | null
    maxSteps: number | null
    totalTokensIn: number | null
    totalTokensOut: number | null
    totalCost: number | null
    latencyMs: number | null
    toolSuccesses: number | null
    toolFailures: number | null
    l1Passed: boolean | null
    l2Score: number | null
    l3Triggered: boolean | null
    l3Blocked: boolean | null
    feedbackScore: number | null
    feedbackComment: string | null
    userEdited: boolean | null
    editDiff: string | null
  }

  export type AgentTraceCountAggregateOutputType = {
    id: number
    agentId: number
    conversationId: number
    userId: number
    workspaceId: number
    startedAt: number
    completedAt: number
    status: number
    steps: number
    totalSteps: number
    maxSteps: number
    totalTokensIn: number
    totalTokensOut: number
    totalCost: number
    latencyMs: number
    toolCalls: number
    toolSuccesses: number
    toolFailures: number
    l1Passed: number
    l1Failures: number
    l2Score: number
    l2Breakdown: number
    l3Triggered: number
    l3Blocked: number
    feedbackScore: number
    feedbackComment: number
    userEdited: number
    editDiff: number
    _all: number
  }


  export type AgentTraceAvgAggregateInputType = {
    totalSteps?: true
    maxSteps?: true
    totalTokensIn?: true
    totalTokensOut?: true
    totalCost?: true
    latencyMs?: true
    toolSuccesses?: true
    toolFailures?: true
    l2Score?: true
    feedbackScore?: true
  }

  export type AgentTraceSumAggregateInputType = {
    totalSteps?: true
    maxSteps?: true
    totalTokensIn?: true
    totalTokensOut?: true
    totalCost?: true
    latencyMs?: true
    toolSuccesses?: true
    toolFailures?: true
    l2Score?: true
    feedbackScore?: true
  }

  export type AgentTraceMinAggregateInputType = {
    id?: true
    agentId?: true
    conversationId?: true
    userId?: true
    workspaceId?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalSteps?: true
    maxSteps?: true
    totalTokensIn?: true
    totalTokensOut?: true
    totalCost?: true
    latencyMs?: true
    toolSuccesses?: true
    toolFailures?: true
    l1Passed?: true
    l2Score?: true
    l3Triggered?: true
    l3Blocked?: true
    feedbackScore?: true
    feedbackComment?: true
    userEdited?: true
    editDiff?: true
  }

  export type AgentTraceMaxAggregateInputType = {
    id?: true
    agentId?: true
    conversationId?: true
    userId?: true
    workspaceId?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalSteps?: true
    maxSteps?: true
    totalTokensIn?: true
    totalTokensOut?: true
    totalCost?: true
    latencyMs?: true
    toolSuccesses?: true
    toolFailures?: true
    l1Passed?: true
    l2Score?: true
    l3Triggered?: true
    l3Blocked?: true
    feedbackScore?: true
    feedbackComment?: true
    userEdited?: true
    editDiff?: true
  }

  export type AgentTraceCountAggregateInputType = {
    id?: true
    agentId?: true
    conversationId?: true
    userId?: true
    workspaceId?: true
    startedAt?: true
    completedAt?: true
    status?: true
    steps?: true
    totalSteps?: true
    maxSteps?: true
    totalTokensIn?: true
    totalTokensOut?: true
    totalCost?: true
    latencyMs?: true
    toolCalls?: true
    toolSuccesses?: true
    toolFailures?: true
    l1Passed?: true
    l1Failures?: true
    l2Score?: true
    l2Breakdown?: true
    l3Triggered?: true
    l3Blocked?: true
    feedbackScore?: true
    feedbackComment?: true
    userEdited?: true
    editDiff?: true
    _all?: true
  }

  export type AgentTraceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTrace to aggregate.
     */
    where?: AgentTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTraces to fetch.
     */
    orderBy?: AgentTraceOrderByWithRelationInput | AgentTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentTraces
    **/
    _count?: true | AgentTraceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentTraceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentTraceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentTraceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentTraceMaxAggregateInputType
  }

  export type GetAgentTraceAggregateType<T extends AgentTraceAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentTrace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentTrace[P]>
      : GetScalarType<T[P], AggregateAgentTrace[P]>
  }




  export type AgentTraceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTraceWhereInput
    orderBy?: AgentTraceOrderByWithAggregationInput | AgentTraceOrderByWithAggregationInput[]
    by: AgentTraceScalarFieldEnum[] | AgentTraceScalarFieldEnum
    having?: AgentTraceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentTraceCountAggregateInputType | true
    _avg?: AgentTraceAvgAggregateInputType
    _sum?: AgentTraceSumAggregateInputType
    _min?: AgentTraceMinAggregateInputType
    _max?: AgentTraceMaxAggregateInputType
  }

  export type AgentTraceGroupByOutputType = {
    id: string
    agentId: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt: Date
    completedAt: Date | null
    status: $Enums.TraceStatus
    steps: JsonValue
    totalSteps: number
    maxSteps: number
    totalTokensIn: number
    totalTokensOut: number
    totalCost: number
    latencyMs: number | null
    toolCalls: JsonValue
    toolSuccesses: number
    toolFailures: number
    l1Passed: boolean | null
    l1Failures: JsonValue | null
    l2Score: number | null
    l2Breakdown: JsonValue | null
    l3Triggered: boolean
    l3Blocked: boolean | null
    feedbackScore: number | null
    feedbackComment: string | null
    userEdited: boolean
    editDiff: string | null
    _count: AgentTraceCountAggregateOutputType | null
    _avg: AgentTraceAvgAggregateOutputType | null
    _sum: AgentTraceSumAggregateOutputType | null
    _min: AgentTraceMinAggregateOutputType | null
    _max: AgentTraceMaxAggregateOutputType | null
  }

  type GetAgentTraceGroupByPayload<T extends AgentTraceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentTraceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentTraceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentTraceGroupByOutputType[P]>
            : GetScalarType<T[P], AgentTraceGroupByOutputType[P]>
        }
      >
    >


  export type AgentTraceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    steps?: boolean
    totalSteps?: boolean
    maxSteps?: boolean
    totalTokensIn?: boolean
    totalTokensOut?: boolean
    totalCost?: boolean
    latencyMs?: boolean
    toolCalls?: boolean
    toolSuccesses?: boolean
    toolFailures?: boolean
    l1Passed?: boolean
    l1Failures?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    feedbackScore?: boolean
    feedbackComment?: boolean
    userEdited?: boolean
    editDiff?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    aiEvents?: boolean | AgentTrace$aiEventsArgs<ExtArgs>
    feedbacks?: boolean | AgentTrace$feedbacksArgs<ExtArgs>
    _count?: boolean | AgentTraceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTrace"]>

  export type AgentTraceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    steps?: boolean
    totalSteps?: boolean
    maxSteps?: boolean
    totalTokensIn?: boolean
    totalTokensOut?: boolean
    totalCost?: boolean
    latencyMs?: boolean
    toolCalls?: boolean
    toolSuccesses?: boolean
    toolFailures?: boolean
    l1Passed?: boolean
    l1Failures?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    feedbackScore?: boolean
    feedbackComment?: boolean
    userEdited?: boolean
    editDiff?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTrace"]>

  export type AgentTraceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    steps?: boolean
    totalSteps?: boolean
    maxSteps?: boolean
    totalTokensIn?: boolean
    totalTokensOut?: boolean
    totalCost?: boolean
    latencyMs?: boolean
    toolCalls?: boolean
    toolSuccesses?: boolean
    toolFailures?: boolean
    l1Passed?: boolean
    l1Failures?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    feedbackScore?: boolean
    feedbackComment?: boolean
    userEdited?: boolean
    editDiff?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTrace"]>

  export type AgentTraceSelectScalar = {
    id?: boolean
    agentId?: boolean
    conversationId?: boolean
    userId?: boolean
    workspaceId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    steps?: boolean
    totalSteps?: boolean
    maxSteps?: boolean
    totalTokensIn?: boolean
    totalTokensOut?: boolean
    totalCost?: boolean
    latencyMs?: boolean
    toolCalls?: boolean
    toolSuccesses?: boolean
    toolFailures?: boolean
    l1Passed?: boolean
    l1Failures?: boolean
    l2Score?: boolean
    l2Breakdown?: boolean
    l3Triggered?: boolean
    l3Blocked?: boolean
    feedbackScore?: boolean
    feedbackComment?: boolean
    userEdited?: boolean
    editDiff?: boolean
  }

  export type AgentTraceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "conversationId" | "userId" | "workspaceId" | "startedAt" | "completedAt" | "status" | "steps" | "totalSteps" | "maxSteps" | "totalTokensIn" | "totalTokensOut" | "totalCost" | "latencyMs" | "toolCalls" | "toolSuccesses" | "toolFailures" | "l1Passed" | "l1Failures" | "l2Score" | "l2Breakdown" | "l3Triggered" | "l3Blocked" | "feedbackScore" | "feedbackComment" | "userEdited" | "editDiff", ExtArgs["result"]["agentTrace"]>
  export type AgentTraceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    aiEvents?: boolean | AgentTrace$aiEventsArgs<ExtArgs>
    feedbacks?: boolean | AgentTrace$feedbacksArgs<ExtArgs>
    _count?: boolean | AgentTraceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentTraceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type AgentTraceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $AgentTracePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentTrace"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
      aiEvents: Prisma.$AiEventPayload<ExtArgs>[]
      feedbacks: Prisma.$AgentFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      conversationId: string
      userId: string
      workspaceId: string
      startedAt: Date
      completedAt: Date | null
      status: $Enums.TraceStatus
      steps: Prisma.JsonValue
      totalSteps: number
      maxSteps: number
      totalTokensIn: number
      totalTokensOut: number
      totalCost: number
      latencyMs: number | null
      toolCalls: Prisma.JsonValue
      toolSuccesses: number
      toolFailures: number
      l1Passed: boolean | null
      l1Failures: Prisma.JsonValue | null
      l2Score: number | null
      l2Breakdown: Prisma.JsonValue | null
      l3Triggered: boolean
      l3Blocked: boolean | null
      feedbackScore: number | null
      feedbackComment: string | null
      userEdited: boolean
      editDiff: string | null
    }, ExtArgs["result"]["agentTrace"]>
    composites: {}
  }

  type AgentTraceGetPayload<S extends boolean | null | undefined | AgentTraceDefaultArgs> = $Result.GetResult<Prisma.$AgentTracePayload, S>

  type AgentTraceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentTraceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentTraceCountAggregateInputType | true
    }

  export interface AgentTraceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentTrace'], meta: { name: 'AgentTrace' } }
    /**
     * Find zero or one AgentTrace that matches the filter.
     * @param {AgentTraceFindUniqueArgs} args - Arguments to find a AgentTrace
     * @example
     * // Get one AgentTrace
     * const agentTrace = await prisma.agentTrace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentTraceFindUniqueArgs>(args: SelectSubset<T, AgentTraceFindUniqueArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentTrace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentTraceFindUniqueOrThrowArgs} args - Arguments to find a AgentTrace
     * @example
     * // Get one AgentTrace
     * const agentTrace = await prisma.agentTrace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentTraceFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentTraceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTrace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceFindFirstArgs} args - Arguments to find a AgentTrace
     * @example
     * // Get one AgentTrace
     * const agentTrace = await prisma.agentTrace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentTraceFindFirstArgs>(args?: SelectSubset<T, AgentTraceFindFirstArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTrace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceFindFirstOrThrowArgs} args - Arguments to find a AgentTrace
     * @example
     * // Get one AgentTrace
     * const agentTrace = await prisma.agentTrace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentTraceFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentTraceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentTraces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentTraces
     * const agentTraces = await prisma.agentTrace.findMany()
     * 
     * // Get first 10 AgentTraces
     * const agentTraces = await prisma.agentTrace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentTraceWithIdOnly = await prisma.agentTrace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentTraceFindManyArgs>(args?: SelectSubset<T, AgentTraceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentTrace.
     * @param {AgentTraceCreateArgs} args - Arguments to create a AgentTrace.
     * @example
     * // Create one AgentTrace
     * const AgentTrace = await prisma.agentTrace.create({
     *   data: {
     *     // ... data to create a AgentTrace
     *   }
     * })
     * 
     */
    create<T extends AgentTraceCreateArgs>(args: SelectSubset<T, AgentTraceCreateArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentTraces.
     * @param {AgentTraceCreateManyArgs} args - Arguments to create many AgentTraces.
     * @example
     * // Create many AgentTraces
     * const agentTrace = await prisma.agentTrace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentTraceCreateManyArgs>(args?: SelectSubset<T, AgentTraceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentTraces and returns the data saved in the database.
     * @param {AgentTraceCreateManyAndReturnArgs} args - Arguments to create many AgentTraces.
     * @example
     * // Create many AgentTraces
     * const agentTrace = await prisma.agentTrace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentTraces and only return the `id`
     * const agentTraceWithIdOnly = await prisma.agentTrace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentTraceCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentTraceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentTrace.
     * @param {AgentTraceDeleteArgs} args - Arguments to delete one AgentTrace.
     * @example
     * // Delete one AgentTrace
     * const AgentTrace = await prisma.agentTrace.delete({
     *   where: {
     *     // ... filter to delete one AgentTrace
     *   }
     * })
     * 
     */
    delete<T extends AgentTraceDeleteArgs>(args: SelectSubset<T, AgentTraceDeleteArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentTrace.
     * @param {AgentTraceUpdateArgs} args - Arguments to update one AgentTrace.
     * @example
     * // Update one AgentTrace
     * const agentTrace = await prisma.agentTrace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentTraceUpdateArgs>(args: SelectSubset<T, AgentTraceUpdateArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentTraces.
     * @param {AgentTraceDeleteManyArgs} args - Arguments to filter AgentTraces to delete.
     * @example
     * // Delete a few AgentTraces
     * const { count } = await prisma.agentTrace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentTraceDeleteManyArgs>(args?: SelectSubset<T, AgentTraceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTraces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentTraces
     * const agentTrace = await prisma.agentTrace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentTraceUpdateManyArgs>(args: SelectSubset<T, AgentTraceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTraces and returns the data updated in the database.
     * @param {AgentTraceUpdateManyAndReturnArgs} args - Arguments to update many AgentTraces.
     * @example
     * // Update many AgentTraces
     * const agentTrace = await prisma.agentTrace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentTraces and only return the `id`
     * const agentTraceWithIdOnly = await prisma.agentTrace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentTraceUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentTraceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentTrace.
     * @param {AgentTraceUpsertArgs} args - Arguments to update or create a AgentTrace.
     * @example
     * // Update or create a AgentTrace
     * const agentTrace = await prisma.agentTrace.upsert({
     *   create: {
     *     // ... data to create a AgentTrace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentTrace we want to update
     *   }
     * })
     */
    upsert<T extends AgentTraceUpsertArgs>(args: SelectSubset<T, AgentTraceUpsertArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentTraces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceCountArgs} args - Arguments to filter AgentTraces to count.
     * @example
     * // Count the number of AgentTraces
     * const count = await prisma.agentTrace.count({
     *   where: {
     *     // ... the filter for the AgentTraces we want to count
     *   }
     * })
    **/
    count<T extends AgentTraceCountArgs>(
      args?: Subset<T, AgentTraceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentTraceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentTrace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentTraceAggregateArgs>(args: Subset<T, AgentTraceAggregateArgs>): Prisma.PrismaPromise<GetAgentTraceAggregateType<T>>

    /**
     * Group by AgentTrace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTraceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentTraceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentTraceGroupByArgs['orderBy'] }
        : { orderBy?: AgentTraceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentTraceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentTraceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentTrace model
   */
  readonly fields: AgentTraceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentTrace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentTraceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aiEvents<T extends AgentTrace$aiEventsArgs<ExtArgs> = {}>(args?: Subset<T, AgentTrace$aiEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends AgentTrace$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, AgentTrace$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentTrace model
   */
  interface AgentTraceFieldRefs {
    readonly id: FieldRef<"AgentTrace", 'String'>
    readonly agentId: FieldRef<"AgentTrace", 'String'>
    readonly conversationId: FieldRef<"AgentTrace", 'String'>
    readonly userId: FieldRef<"AgentTrace", 'String'>
    readonly workspaceId: FieldRef<"AgentTrace", 'String'>
    readonly startedAt: FieldRef<"AgentTrace", 'DateTime'>
    readonly completedAt: FieldRef<"AgentTrace", 'DateTime'>
    readonly status: FieldRef<"AgentTrace", 'TraceStatus'>
    readonly steps: FieldRef<"AgentTrace", 'Json'>
    readonly totalSteps: FieldRef<"AgentTrace", 'Int'>
    readonly maxSteps: FieldRef<"AgentTrace", 'Int'>
    readonly totalTokensIn: FieldRef<"AgentTrace", 'Int'>
    readonly totalTokensOut: FieldRef<"AgentTrace", 'Int'>
    readonly totalCost: FieldRef<"AgentTrace", 'Float'>
    readonly latencyMs: FieldRef<"AgentTrace", 'Int'>
    readonly toolCalls: FieldRef<"AgentTrace", 'Json'>
    readonly toolSuccesses: FieldRef<"AgentTrace", 'Int'>
    readonly toolFailures: FieldRef<"AgentTrace", 'Int'>
    readonly l1Passed: FieldRef<"AgentTrace", 'Boolean'>
    readonly l1Failures: FieldRef<"AgentTrace", 'Json'>
    readonly l2Score: FieldRef<"AgentTrace", 'Float'>
    readonly l2Breakdown: FieldRef<"AgentTrace", 'Json'>
    readonly l3Triggered: FieldRef<"AgentTrace", 'Boolean'>
    readonly l3Blocked: FieldRef<"AgentTrace", 'Boolean'>
    readonly feedbackScore: FieldRef<"AgentTrace", 'Int'>
    readonly feedbackComment: FieldRef<"AgentTrace", 'String'>
    readonly userEdited: FieldRef<"AgentTrace", 'Boolean'>
    readonly editDiff: FieldRef<"AgentTrace", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgentTrace findUnique
   */
  export type AgentTraceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrace to fetch.
     */
    where: AgentTraceWhereUniqueInput
  }

  /**
   * AgentTrace findUniqueOrThrow
   */
  export type AgentTraceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrace to fetch.
     */
    where: AgentTraceWhereUniqueInput
  }

  /**
   * AgentTrace findFirst
   */
  export type AgentTraceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrace to fetch.
     */
    where?: AgentTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTraces to fetch.
     */
    orderBy?: AgentTraceOrderByWithRelationInput | AgentTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTraces.
     */
    cursor?: AgentTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTraces.
     */
    distinct?: AgentTraceScalarFieldEnum | AgentTraceScalarFieldEnum[]
  }

  /**
   * AgentTrace findFirstOrThrow
   */
  export type AgentTraceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * Filter, which AgentTrace to fetch.
     */
    where?: AgentTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTraces to fetch.
     */
    orderBy?: AgentTraceOrderByWithRelationInput | AgentTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTraces.
     */
    cursor?: AgentTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTraces.
     */
    distinct?: AgentTraceScalarFieldEnum | AgentTraceScalarFieldEnum[]
  }

  /**
   * AgentTrace findMany
   */
  export type AgentTraceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * Filter, which AgentTraces to fetch.
     */
    where?: AgentTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTraces to fetch.
     */
    orderBy?: AgentTraceOrderByWithRelationInput | AgentTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentTraces.
     */
    cursor?: AgentTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTraces.
     */
    skip?: number
    distinct?: AgentTraceScalarFieldEnum | AgentTraceScalarFieldEnum[]
  }

  /**
   * AgentTrace create
   */
  export type AgentTraceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentTrace.
     */
    data: XOR<AgentTraceCreateInput, AgentTraceUncheckedCreateInput>
  }

  /**
   * AgentTrace createMany
   */
  export type AgentTraceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentTraces.
     */
    data: AgentTraceCreateManyInput | AgentTraceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTrace createManyAndReturn
   */
  export type AgentTraceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * The data used to create many AgentTraces.
     */
    data: AgentTraceCreateManyInput | AgentTraceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTrace update
   */
  export type AgentTraceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentTrace.
     */
    data: XOR<AgentTraceUpdateInput, AgentTraceUncheckedUpdateInput>
    /**
     * Choose, which AgentTrace to update.
     */
    where: AgentTraceWhereUniqueInput
  }

  /**
   * AgentTrace updateMany
   */
  export type AgentTraceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentTraces.
     */
    data: XOR<AgentTraceUpdateManyMutationInput, AgentTraceUncheckedUpdateManyInput>
    /**
     * Filter which AgentTraces to update
     */
    where?: AgentTraceWhereInput
    /**
     * Limit how many AgentTraces to update.
     */
    limit?: number
  }

  /**
   * AgentTrace updateManyAndReturn
   */
  export type AgentTraceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * The data used to update AgentTraces.
     */
    data: XOR<AgentTraceUpdateManyMutationInput, AgentTraceUncheckedUpdateManyInput>
    /**
     * Filter which AgentTraces to update
     */
    where?: AgentTraceWhereInput
    /**
     * Limit how many AgentTraces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTrace upsert
   */
  export type AgentTraceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentTrace to update in case it exists.
     */
    where: AgentTraceWhereUniqueInput
    /**
     * In case the AgentTrace found by the `where` argument doesn't exist, create a new AgentTrace with this data.
     */
    create: XOR<AgentTraceCreateInput, AgentTraceUncheckedCreateInput>
    /**
     * In case the AgentTrace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentTraceUpdateInput, AgentTraceUncheckedUpdateInput>
  }

  /**
   * AgentTrace delete
   */
  export type AgentTraceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
    /**
     * Filter which AgentTrace to delete.
     */
    where: AgentTraceWhereUniqueInput
  }

  /**
   * AgentTrace deleteMany
   */
  export type AgentTraceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTraces to delete
     */
    where?: AgentTraceWhereInput
    /**
     * Limit how many AgentTraces to delete.
     */
    limit?: number
  }

  /**
   * AgentTrace.aiEvents
   */
  export type AgentTrace$aiEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiEvent
     */
    select?: AiEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiEvent
     */
    omit?: AiEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiEventInclude<ExtArgs> | null
    where?: AiEventWhereInput
    orderBy?: AiEventOrderByWithRelationInput | AiEventOrderByWithRelationInput[]
    cursor?: AiEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiEventScalarFieldEnum | AiEventScalarFieldEnum[]
  }

  /**
   * AgentTrace.feedbacks
   */
  export type AgentTrace$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    where?: AgentFeedbackWhereInput
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    cursor?: AgentFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentFeedbackScalarFieldEnum | AgentFeedbackScalarFieldEnum[]
  }

  /**
   * AgentTrace without action
   */
  export type AgentTraceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTrace
     */
    select?: AgentTraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTrace
     */
    omit?: AgentTraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTraceInclude<ExtArgs> | null
  }


  /**
   * Model ConversationEvaluation
   */

  export type AggregateConversationEvaluation = {
    _count: ConversationEvaluationCountAggregateOutputType | null
    _avg: ConversationEvaluationAvgAggregateOutputType | null
    _sum: ConversationEvaluationSumAggregateOutputType | null
    _min: ConversationEvaluationMinAggregateOutputType | null
    _max: ConversationEvaluationMaxAggregateOutputType | null
  }

  export type ConversationEvaluationAvgAggregateOutputType = {
    goalCompletionConfidence: number | null
    userSatisfactionScore: number | null
  }

  export type ConversationEvaluationSumAggregateOutputType = {
    goalCompletionConfidence: number | null
    userSatisfactionScore: number | null
  }

  export type ConversationEvaluationMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    evaluatedAt: Date | null
    goalCompleted: boolean | null
    goalCompletionConfidence: number | null
    userSatisfactionScore: number | null
  }

  export type ConversationEvaluationMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    evaluatedAt: Date | null
    goalCompleted: boolean | null
    goalCompletionConfidence: number | null
    userSatisfactionScore: number | null
  }

  export type ConversationEvaluationCountAggregateOutputType = {
    id: number
    conversationId: number
    evaluatedAt: number
    goalCompleted: number
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories: number
    failureModes: number
    improvementSuggestions: number
    metadata: number
    _all: number
  }


  export type ConversationEvaluationAvgAggregateInputType = {
    goalCompletionConfidence?: true
    userSatisfactionScore?: true
  }

  export type ConversationEvaluationSumAggregateInputType = {
    goalCompletionConfidence?: true
    userSatisfactionScore?: true
  }

  export type ConversationEvaluationMinAggregateInputType = {
    id?: true
    conversationId?: true
    evaluatedAt?: true
    goalCompleted?: true
    goalCompletionConfidence?: true
    userSatisfactionScore?: true
  }

  export type ConversationEvaluationMaxAggregateInputType = {
    id?: true
    conversationId?: true
    evaluatedAt?: true
    goalCompleted?: true
    goalCompletionConfidence?: true
    userSatisfactionScore?: true
  }

  export type ConversationEvaluationCountAggregateInputType = {
    id?: true
    conversationId?: true
    evaluatedAt?: true
    goalCompleted?: true
    goalCompletionConfidence?: true
    userSatisfactionScore?: true
    categories?: true
    failureModes?: true
    improvementSuggestions?: true
    metadata?: true
    _all?: true
  }

  export type ConversationEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationEvaluation to aggregate.
     */
    where?: ConversationEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationEvaluations to fetch.
     */
    orderBy?: ConversationEvaluationOrderByWithRelationInput | ConversationEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationEvaluations
    **/
    _count?: true | ConversationEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationEvaluationMaxAggregateInputType
  }

  export type GetConversationEvaluationAggregateType<T extends ConversationEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationEvaluation[P]>
      : GetScalarType<T[P], AggregateConversationEvaluation[P]>
  }




  export type ConversationEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationEvaluationWhereInput
    orderBy?: ConversationEvaluationOrderByWithAggregationInput | ConversationEvaluationOrderByWithAggregationInput[]
    by: ConversationEvaluationScalarFieldEnum[] | ConversationEvaluationScalarFieldEnum
    having?: ConversationEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationEvaluationCountAggregateInputType | true
    _avg?: ConversationEvaluationAvgAggregateInputType
    _sum?: ConversationEvaluationSumAggregateInputType
    _min?: ConversationEvaluationMinAggregateInputType
    _max?: ConversationEvaluationMaxAggregateInputType
  }

  export type ConversationEvaluationGroupByOutputType = {
    id: string
    conversationId: string
    evaluatedAt: Date
    goalCompleted: boolean
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories: string[]
    failureModes: string[]
    improvementSuggestions: string[]
    metadata: JsonValue
    _count: ConversationEvaluationCountAggregateOutputType | null
    _avg: ConversationEvaluationAvgAggregateOutputType | null
    _sum: ConversationEvaluationSumAggregateOutputType | null
    _min: ConversationEvaluationMinAggregateOutputType | null
    _max: ConversationEvaluationMaxAggregateOutputType | null
  }

  type GetConversationEvaluationGroupByPayload<T extends ConversationEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    evaluatedAt?: boolean
    goalCompleted?: boolean
    goalCompletionConfidence?: boolean
    userSatisfactionScore?: boolean
    categories?: boolean
    failureModes?: boolean
    improvementSuggestions?: boolean
    metadata?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationEvaluation"]>

  export type ConversationEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    evaluatedAt?: boolean
    goalCompleted?: boolean
    goalCompletionConfidence?: boolean
    userSatisfactionScore?: boolean
    categories?: boolean
    failureModes?: boolean
    improvementSuggestions?: boolean
    metadata?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationEvaluation"]>

  export type ConversationEvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    evaluatedAt?: boolean
    goalCompleted?: boolean
    goalCompletionConfidence?: boolean
    userSatisfactionScore?: boolean
    categories?: boolean
    failureModes?: boolean
    improvementSuggestions?: boolean
    metadata?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationEvaluation"]>

  export type ConversationEvaluationSelectScalar = {
    id?: boolean
    conversationId?: boolean
    evaluatedAt?: boolean
    goalCompleted?: boolean
    goalCompletionConfidence?: boolean
    userSatisfactionScore?: boolean
    categories?: boolean
    failureModes?: boolean
    improvementSuggestions?: boolean
    metadata?: boolean
  }

  export type ConversationEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "evaluatedAt" | "goalCompleted" | "goalCompletionConfidence" | "userSatisfactionScore" | "categories" | "failureModes" | "improvementSuggestions" | "metadata", ExtArgs["result"]["conversationEvaluation"]>
  export type ConversationEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationEvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ConversationEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationEvaluation"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      evaluatedAt: Date
      goalCompleted: boolean
      goalCompletionConfidence: number
      userSatisfactionScore: number
      categories: string[]
      failureModes: string[]
      improvementSuggestions: string[]
      metadata: Prisma.JsonValue
    }, ExtArgs["result"]["conversationEvaluation"]>
    composites: {}
  }

  type ConversationEvaluationGetPayload<S extends boolean | null | undefined | ConversationEvaluationDefaultArgs> = $Result.GetResult<Prisma.$ConversationEvaluationPayload, S>

  type ConversationEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationEvaluationCountAggregateInputType | true
    }

  export interface ConversationEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationEvaluation'], meta: { name: 'ConversationEvaluation' } }
    /**
     * Find zero or one ConversationEvaluation that matches the filter.
     * @param {ConversationEvaluationFindUniqueArgs} args - Arguments to find a ConversationEvaluation
     * @example
     * // Get one ConversationEvaluation
     * const conversationEvaluation = await prisma.conversationEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationEvaluationFindUniqueArgs>(args: SelectSubset<T, ConversationEvaluationFindUniqueArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationEvaluationFindUniqueOrThrowArgs} args - Arguments to find a ConversationEvaluation
     * @example
     * // Get one ConversationEvaluation
     * const conversationEvaluation = await prisma.conversationEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationFindFirstArgs} args - Arguments to find a ConversationEvaluation
     * @example
     * // Get one ConversationEvaluation
     * const conversationEvaluation = await prisma.conversationEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationEvaluationFindFirstArgs>(args?: SelectSubset<T, ConversationEvaluationFindFirstArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationFindFirstOrThrowArgs} args - Arguments to find a ConversationEvaluation
     * @example
     * // Get one ConversationEvaluation
     * const conversationEvaluation = await prisma.conversationEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationEvaluations
     * const conversationEvaluations = await prisma.conversationEvaluation.findMany()
     * 
     * // Get first 10 ConversationEvaluations
     * const conversationEvaluations = await prisma.conversationEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationEvaluationWithIdOnly = await prisma.conversationEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationEvaluationFindManyArgs>(args?: SelectSubset<T, ConversationEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationEvaluation.
     * @param {ConversationEvaluationCreateArgs} args - Arguments to create a ConversationEvaluation.
     * @example
     * // Create one ConversationEvaluation
     * const ConversationEvaluation = await prisma.conversationEvaluation.create({
     *   data: {
     *     // ... data to create a ConversationEvaluation
     *   }
     * })
     * 
     */
    create<T extends ConversationEvaluationCreateArgs>(args: SelectSubset<T, ConversationEvaluationCreateArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationEvaluations.
     * @param {ConversationEvaluationCreateManyArgs} args - Arguments to create many ConversationEvaluations.
     * @example
     * // Create many ConversationEvaluations
     * const conversationEvaluation = await prisma.conversationEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationEvaluationCreateManyArgs>(args?: SelectSubset<T, ConversationEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationEvaluations and returns the data saved in the database.
     * @param {ConversationEvaluationCreateManyAndReturnArgs} args - Arguments to create many ConversationEvaluations.
     * @example
     * // Create many ConversationEvaluations
     * const conversationEvaluation = await prisma.conversationEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationEvaluations and only return the `id`
     * const conversationEvaluationWithIdOnly = await prisma.conversationEvaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationEvaluation.
     * @param {ConversationEvaluationDeleteArgs} args - Arguments to delete one ConversationEvaluation.
     * @example
     * // Delete one ConversationEvaluation
     * const ConversationEvaluation = await prisma.conversationEvaluation.delete({
     *   where: {
     *     // ... filter to delete one ConversationEvaluation
     *   }
     * })
     * 
     */
    delete<T extends ConversationEvaluationDeleteArgs>(args: SelectSubset<T, ConversationEvaluationDeleteArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationEvaluation.
     * @param {ConversationEvaluationUpdateArgs} args - Arguments to update one ConversationEvaluation.
     * @example
     * // Update one ConversationEvaluation
     * const conversationEvaluation = await prisma.conversationEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationEvaluationUpdateArgs>(args: SelectSubset<T, ConversationEvaluationUpdateArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationEvaluations.
     * @param {ConversationEvaluationDeleteManyArgs} args - Arguments to filter ConversationEvaluations to delete.
     * @example
     * // Delete a few ConversationEvaluations
     * const { count } = await prisma.conversationEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationEvaluationDeleteManyArgs>(args?: SelectSubset<T, ConversationEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationEvaluations
     * const conversationEvaluation = await prisma.conversationEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationEvaluationUpdateManyArgs>(args: SelectSubset<T, ConversationEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationEvaluations and returns the data updated in the database.
     * @param {ConversationEvaluationUpdateManyAndReturnArgs} args - Arguments to update many ConversationEvaluations.
     * @example
     * // Update many ConversationEvaluations
     * const conversationEvaluation = await prisma.conversationEvaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationEvaluations and only return the `id`
     * const conversationEvaluationWithIdOnly = await prisma.conversationEvaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationEvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationEvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationEvaluation.
     * @param {ConversationEvaluationUpsertArgs} args - Arguments to update or create a ConversationEvaluation.
     * @example
     * // Update or create a ConversationEvaluation
     * const conversationEvaluation = await prisma.conversationEvaluation.upsert({
     *   create: {
     *     // ... data to create a ConversationEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationEvaluationUpsertArgs>(args: SelectSubset<T, ConversationEvaluationUpsertArgs<ExtArgs>>): Prisma__ConversationEvaluationClient<$Result.GetResult<Prisma.$ConversationEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationCountArgs} args - Arguments to filter ConversationEvaluations to count.
     * @example
     * // Count the number of ConversationEvaluations
     * const count = await prisma.conversationEvaluation.count({
     *   where: {
     *     // ... the filter for the ConversationEvaluations we want to count
     *   }
     * })
    **/
    count<T extends ConversationEvaluationCountArgs>(
      args?: Subset<T, ConversationEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationEvaluationAggregateArgs>(args: Subset<T, ConversationEvaluationAggregateArgs>): Prisma.PrismaPromise<GetConversationEvaluationAggregateType<T>>

    /**
     * Group by ConversationEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationEvaluation model
   */
  readonly fields: ConversationEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationEvaluation model
   */
  interface ConversationEvaluationFieldRefs {
    readonly id: FieldRef<"ConversationEvaluation", 'String'>
    readonly conversationId: FieldRef<"ConversationEvaluation", 'String'>
    readonly evaluatedAt: FieldRef<"ConversationEvaluation", 'DateTime'>
    readonly goalCompleted: FieldRef<"ConversationEvaluation", 'Boolean'>
    readonly goalCompletionConfidence: FieldRef<"ConversationEvaluation", 'Float'>
    readonly userSatisfactionScore: FieldRef<"ConversationEvaluation", 'Float'>
    readonly categories: FieldRef<"ConversationEvaluation", 'String[]'>
    readonly failureModes: FieldRef<"ConversationEvaluation", 'String[]'>
    readonly improvementSuggestions: FieldRef<"ConversationEvaluation", 'String[]'>
    readonly metadata: FieldRef<"ConversationEvaluation", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ConversationEvaluation findUnique
   */
  export type ConversationEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ConversationEvaluation to fetch.
     */
    where: ConversationEvaluationWhereUniqueInput
  }

  /**
   * ConversationEvaluation findUniqueOrThrow
   */
  export type ConversationEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ConversationEvaluation to fetch.
     */
    where: ConversationEvaluationWhereUniqueInput
  }

  /**
   * ConversationEvaluation findFirst
   */
  export type ConversationEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ConversationEvaluation to fetch.
     */
    where?: ConversationEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationEvaluations to fetch.
     */
    orderBy?: ConversationEvaluationOrderByWithRelationInput | ConversationEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationEvaluations.
     */
    cursor?: ConversationEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationEvaluations.
     */
    distinct?: ConversationEvaluationScalarFieldEnum | ConversationEvaluationScalarFieldEnum[]
  }

  /**
   * ConversationEvaluation findFirstOrThrow
   */
  export type ConversationEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ConversationEvaluation to fetch.
     */
    where?: ConversationEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationEvaluations to fetch.
     */
    orderBy?: ConversationEvaluationOrderByWithRelationInput | ConversationEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationEvaluations.
     */
    cursor?: ConversationEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationEvaluations.
     */
    distinct?: ConversationEvaluationScalarFieldEnum | ConversationEvaluationScalarFieldEnum[]
  }

  /**
   * ConversationEvaluation findMany
   */
  export type ConversationEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ConversationEvaluations to fetch.
     */
    where?: ConversationEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationEvaluations to fetch.
     */
    orderBy?: ConversationEvaluationOrderByWithRelationInput | ConversationEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationEvaluations.
     */
    cursor?: ConversationEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationEvaluations.
     */
    skip?: number
    distinct?: ConversationEvaluationScalarFieldEnum | ConversationEvaluationScalarFieldEnum[]
  }

  /**
   * ConversationEvaluation create
   */
  export type ConversationEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationEvaluation.
     */
    data: XOR<ConversationEvaluationCreateInput, ConversationEvaluationUncheckedCreateInput>
  }

  /**
   * ConversationEvaluation createMany
   */
  export type ConversationEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationEvaluations.
     */
    data: ConversationEvaluationCreateManyInput | ConversationEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationEvaluation createManyAndReturn
   */
  export type ConversationEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationEvaluations.
     */
    data: ConversationEvaluationCreateManyInput | ConversationEvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationEvaluation update
   */
  export type ConversationEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationEvaluation.
     */
    data: XOR<ConversationEvaluationUpdateInput, ConversationEvaluationUncheckedUpdateInput>
    /**
     * Choose, which ConversationEvaluation to update.
     */
    where: ConversationEvaluationWhereUniqueInput
  }

  /**
   * ConversationEvaluation updateMany
   */
  export type ConversationEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationEvaluations.
     */
    data: XOR<ConversationEvaluationUpdateManyMutationInput, ConversationEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which ConversationEvaluations to update
     */
    where?: ConversationEvaluationWhereInput
    /**
     * Limit how many ConversationEvaluations to update.
     */
    limit?: number
  }

  /**
   * ConversationEvaluation updateManyAndReturn
   */
  export type ConversationEvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * The data used to update ConversationEvaluations.
     */
    data: XOR<ConversationEvaluationUpdateManyMutationInput, ConversationEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which ConversationEvaluations to update
     */
    where?: ConversationEvaluationWhereInput
    /**
     * Limit how many ConversationEvaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationEvaluation upsert
   */
  export type ConversationEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationEvaluation to update in case it exists.
     */
    where: ConversationEvaluationWhereUniqueInput
    /**
     * In case the ConversationEvaluation found by the `where` argument doesn't exist, create a new ConversationEvaluation with this data.
     */
    create: XOR<ConversationEvaluationCreateInput, ConversationEvaluationUncheckedCreateInput>
    /**
     * In case the ConversationEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationEvaluationUpdateInput, ConversationEvaluationUncheckedUpdateInput>
  }

  /**
   * ConversationEvaluation delete
   */
  export type ConversationEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
    /**
     * Filter which ConversationEvaluation to delete.
     */
    where: ConversationEvaluationWhereUniqueInput
  }

  /**
   * ConversationEvaluation deleteMany
   */
  export type ConversationEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationEvaluations to delete
     */
    where?: ConversationEvaluationWhereInput
    /**
     * Limit how many ConversationEvaluations to delete.
     */
    limit?: number
  }

  /**
   * ConversationEvaluation without action
   */
  export type ConversationEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationEvaluation
     */
    select?: ConversationEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationEvaluation
     */
    omit?: ConversationEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model AgentInsight
   */

  export type AggregateAgentInsight = {
    _count: AgentInsightCountAggregateOutputType | null
    _min: AgentInsightMinAggregateOutputType | null
    _max: AgentInsightMaxAggregateOutputType | null
  }

  export type AgentInsightMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    generatedAt: Date | null
    timeframeStart: Date | null
    timeframeEnd: Date | null
  }

  export type AgentInsightMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    generatedAt: Date | null
    timeframeStart: Date | null
    timeframeEnd: Date | null
  }

  export type AgentInsightCountAggregateOutputType = {
    id: number
    agentId: number
    generatedAt: number
    timeframeStart: number
    timeframeEnd: number
    clusters: number
    patterns: number
    anomalies: number
    opportunities: number
    _all: number
  }


  export type AgentInsightMinAggregateInputType = {
    id?: true
    agentId?: true
    generatedAt?: true
    timeframeStart?: true
    timeframeEnd?: true
  }

  export type AgentInsightMaxAggregateInputType = {
    id?: true
    agentId?: true
    generatedAt?: true
    timeframeStart?: true
    timeframeEnd?: true
  }

  export type AgentInsightCountAggregateInputType = {
    id?: true
    agentId?: true
    generatedAt?: true
    timeframeStart?: true
    timeframeEnd?: true
    clusters?: true
    patterns?: true
    anomalies?: true
    opportunities?: true
    _all?: true
  }

  export type AgentInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentInsight to aggregate.
     */
    where?: AgentInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInsights to fetch.
     */
    orderBy?: AgentInsightOrderByWithRelationInput | AgentInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentInsights
    **/
    _count?: true | AgentInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentInsightMaxAggregateInputType
  }

  export type GetAgentInsightAggregateType<T extends AgentInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentInsight[P]>
      : GetScalarType<T[P], AggregateAgentInsight[P]>
  }




  export type AgentInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentInsightWhereInput
    orderBy?: AgentInsightOrderByWithAggregationInput | AgentInsightOrderByWithAggregationInput[]
    by: AgentInsightScalarFieldEnum[] | AgentInsightScalarFieldEnum
    having?: AgentInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentInsightCountAggregateInputType | true
    _min?: AgentInsightMinAggregateInputType
    _max?: AgentInsightMaxAggregateInputType
  }

  export type AgentInsightGroupByOutputType = {
    id: string
    agentId: string
    generatedAt: Date
    timeframeStart: Date
    timeframeEnd: Date
    clusters: JsonValue
    patterns: JsonValue
    anomalies: JsonValue
    opportunities: JsonValue
    _count: AgentInsightCountAggregateOutputType | null
    _min: AgentInsightMinAggregateOutputType | null
    _max: AgentInsightMaxAggregateOutputType | null
  }

  type GetAgentInsightGroupByPayload<T extends AgentInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentInsightGroupByOutputType[P]>
            : GetScalarType<T[P], AgentInsightGroupByOutputType[P]>
        }
      >
    >


  export type AgentInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    generatedAt?: boolean
    timeframeStart?: boolean
    timeframeEnd?: boolean
    clusters?: boolean
    patterns?: boolean
    anomalies?: boolean
    opportunities?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentInsight"]>

  export type AgentInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    generatedAt?: boolean
    timeframeStart?: boolean
    timeframeEnd?: boolean
    clusters?: boolean
    patterns?: boolean
    anomalies?: boolean
    opportunities?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentInsight"]>

  export type AgentInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    generatedAt?: boolean
    timeframeStart?: boolean
    timeframeEnd?: boolean
    clusters?: boolean
    patterns?: boolean
    anomalies?: boolean
    opportunities?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentInsight"]>

  export type AgentInsightSelectScalar = {
    id?: boolean
    agentId?: boolean
    generatedAt?: boolean
    timeframeStart?: boolean
    timeframeEnd?: boolean
    clusters?: boolean
    patterns?: boolean
    anomalies?: boolean
    opportunities?: boolean
  }

  export type AgentInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "generatedAt" | "timeframeStart" | "timeframeEnd" | "clusters" | "patterns" | "anomalies" | "opportunities", ExtArgs["result"]["agentInsight"]>
  export type AgentInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentInsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentInsight"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      generatedAt: Date
      timeframeStart: Date
      timeframeEnd: Date
      clusters: Prisma.JsonValue
      patterns: Prisma.JsonValue
      anomalies: Prisma.JsonValue
      opportunities: Prisma.JsonValue
    }, ExtArgs["result"]["agentInsight"]>
    composites: {}
  }

  type AgentInsightGetPayload<S extends boolean | null | undefined | AgentInsightDefaultArgs> = $Result.GetResult<Prisma.$AgentInsightPayload, S>

  type AgentInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentInsightCountAggregateInputType | true
    }

  export interface AgentInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentInsight'], meta: { name: 'AgentInsight' } }
    /**
     * Find zero or one AgentInsight that matches the filter.
     * @param {AgentInsightFindUniqueArgs} args - Arguments to find a AgentInsight
     * @example
     * // Get one AgentInsight
     * const agentInsight = await prisma.agentInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentInsightFindUniqueArgs>(args: SelectSubset<T, AgentInsightFindUniqueArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentInsightFindUniqueOrThrowArgs} args - Arguments to find a AgentInsight
     * @example
     * // Get one AgentInsight
     * const agentInsight = await prisma.agentInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightFindFirstArgs} args - Arguments to find a AgentInsight
     * @example
     * // Get one AgentInsight
     * const agentInsight = await prisma.agentInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentInsightFindFirstArgs>(args?: SelectSubset<T, AgentInsightFindFirstArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightFindFirstOrThrowArgs} args - Arguments to find a AgentInsight
     * @example
     * // Get one AgentInsight
     * const agentInsight = await prisma.agentInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentInsights
     * const agentInsights = await prisma.agentInsight.findMany()
     * 
     * // Get first 10 AgentInsights
     * const agentInsights = await prisma.agentInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentInsightWithIdOnly = await prisma.agentInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentInsightFindManyArgs>(args?: SelectSubset<T, AgentInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentInsight.
     * @param {AgentInsightCreateArgs} args - Arguments to create a AgentInsight.
     * @example
     * // Create one AgentInsight
     * const AgentInsight = await prisma.agentInsight.create({
     *   data: {
     *     // ... data to create a AgentInsight
     *   }
     * })
     * 
     */
    create<T extends AgentInsightCreateArgs>(args: SelectSubset<T, AgentInsightCreateArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentInsights.
     * @param {AgentInsightCreateManyArgs} args - Arguments to create many AgentInsights.
     * @example
     * // Create many AgentInsights
     * const agentInsight = await prisma.agentInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentInsightCreateManyArgs>(args?: SelectSubset<T, AgentInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentInsights and returns the data saved in the database.
     * @param {AgentInsightCreateManyAndReturnArgs} args - Arguments to create many AgentInsights.
     * @example
     * // Create many AgentInsights
     * const agentInsight = await prisma.agentInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentInsights and only return the `id`
     * const agentInsightWithIdOnly = await prisma.agentInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentInsight.
     * @param {AgentInsightDeleteArgs} args - Arguments to delete one AgentInsight.
     * @example
     * // Delete one AgentInsight
     * const AgentInsight = await prisma.agentInsight.delete({
     *   where: {
     *     // ... filter to delete one AgentInsight
     *   }
     * })
     * 
     */
    delete<T extends AgentInsightDeleteArgs>(args: SelectSubset<T, AgentInsightDeleteArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentInsight.
     * @param {AgentInsightUpdateArgs} args - Arguments to update one AgentInsight.
     * @example
     * // Update one AgentInsight
     * const agentInsight = await prisma.agentInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentInsightUpdateArgs>(args: SelectSubset<T, AgentInsightUpdateArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentInsights.
     * @param {AgentInsightDeleteManyArgs} args - Arguments to filter AgentInsights to delete.
     * @example
     * // Delete a few AgentInsights
     * const { count } = await prisma.agentInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentInsightDeleteManyArgs>(args?: SelectSubset<T, AgentInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentInsights
     * const agentInsight = await prisma.agentInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentInsightUpdateManyArgs>(args: SelectSubset<T, AgentInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentInsights and returns the data updated in the database.
     * @param {AgentInsightUpdateManyAndReturnArgs} args - Arguments to update many AgentInsights.
     * @example
     * // Update many AgentInsights
     * const agentInsight = await prisma.agentInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentInsights and only return the `id`
     * const agentInsightWithIdOnly = await prisma.agentInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentInsight.
     * @param {AgentInsightUpsertArgs} args - Arguments to update or create a AgentInsight.
     * @example
     * // Update or create a AgentInsight
     * const agentInsight = await prisma.agentInsight.upsert({
     *   create: {
     *     // ... data to create a AgentInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentInsight we want to update
     *   }
     * })
     */
    upsert<T extends AgentInsightUpsertArgs>(args: SelectSubset<T, AgentInsightUpsertArgs<ExtArgs>>): Prisma__AgentInsightClient<$Result.GetResult<Prisma.$AgentInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightCountArgs} args - Arguments to filter AgentInsights to count.
     * @example
     * // Count the number of AgentInsights
     * const count = await prisma.agentInsight.count({
     *   where: {
     *     // ... the filter for the AgentInsights we want to count
     *   }
     * })
    **/
    count<T extends AgentInsightCountArgs>(
      args?: Subset<T, AgentInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentInsightAggregateArgs>(args: Subset<T, AgentInsightAggregateArgs>): Prisma.PrismaPromise<GetAgentInsightAggregateType<T>>

    /**
     * Group by AgentInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentInsightGroupByArgs['orderBy'] }
        : { orderBy?: AgentInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentInsight model
   */
  readonly fields: AgentInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentInsight model
   */
  interface AgentInsightFieldRefs {
    readonly id: FieldRef<"AgentInsight", 'String'>
    readonly agentId: FieldRef<"AgentInsight", 'String'>
    readonly generatedAt: FieldRef<"AgentInsight", 'DateTime'>
    readonly timeframeStart: FieldRef<"AgentInsight", 'DateTime'>
    readonly timeframeEnd: FieldRef<"AgentInsight", 'DateTime'>
    readonly clusters: FieldRef<"AgentInsight", 'Json'>
    readonly patterns: FieldRef<"AgentInsight", 'Json'>
    readonly anomalies: FieldRef<"AgentInsight", 'Json'>
    readonly opportunities: FieldRef<"AgentInsight", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AgentInsight findUnique
   */
  export type AgentInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * Filter, which AgentInsight to fetch.
     */
    where: AgentInsightWhereUniqueInput
  }

  /**
   * AgentInsight findUniqueOrThrow
   */
  export type AgentInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * Filter, which AgentInsight to fetch.
     */
    where: AgentInsightWhereUniqueInput
  }

  /**
   * AgentInsight findFirst
   */
  export type AgentInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * Filter, which AgentInsight to fetch.
     */
    where?: AgentInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInsights to fetch.
     */
    orderBy?: AgentInsightOrderByWithRelationInput | AgentInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentInsights.
     */
    cursor?: AgentInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentInsights.
     */
    distinct?: AgentInsightScalarFieldEnum | AgentInsightScalarFieldEnum[]
  }

  /**
   * AgentInsight findFirstOrThrow
   */
  export type AgentInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * Filter, which AgentInsight to fetch.
     */
    where?: AgentInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInsights to fetch.
     */
    orderBy?: AgentInsightOrderByWithRelationInput | AgentInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentInsights.
     */
    cursor?: AgentInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentInsights.
     */
    distinct?: AgentInsightScalarFieldEnum | AgentInsightScalarFieldEnum[]
  }

  /**
   * AgentInsight findMany
   */
  export type AgentInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * Filter, which AgentInsights to fetch.
     */
    where?: AgentInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInsights to fetch.
     */
    orderBy?: AgentInsightOrderByWithRelationInput | AgentInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentInsights.
     */
    cursor?: AgentInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInsights.
     */
    skip?: number
    distinct?: AgentInsightScalarFieldEnum | AgentInsightScalarFieldEnum[]
  }

  /**
   * AgentInsight create
   */
  export type AgentInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentInsight.
     */
    data: XOR<AgentInsightCreateInput, AgentInsightUncheckedCreateInput>
  }

  /**
   * AgentInsight createMany
   */
  export type AgentInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentInsights.
     */
    data: AgentInsightCreateManyInput | AgentInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentInsight createManyAndReturn
   */
  export type AgentInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * The data used to create many AgentInsights.
     */
    data: AgentInsightCreateManyInput | AgentInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentInsight update
   */
  export type AgentInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentInsight.
     */
    data: XOR<AgentInsightUpdateInput, AgentInsightUncheckedUpdateInput>
    /**
     * Choose, which AgentInsight to update.
     */
    where: AgentInsightWhereUniqueInput
  }

  /**
   * AgentInsight updateMany
   */
  export type AgentInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentInsights.
     */
    data: XOR<AgentInsightUpdateManyMutationInput, AgentInsightUncheckedUpdateManyInput>
    /**
     * Filter which AgentInsights to update
     */
    where?: AgentInsightWhereInput
    /**
     * Limit how many AgentInsights to update.
     */
    limit?: number
  }

  /**
   * AgentInsight updateManyAndReturn
   */
  export type AgentInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * The data used to update AgentInsights.
     */
    data: XOR<AgentInsightUpdateManyMutationInput, AgentInsightUncheckedUpdateManyInput>
    /**
     * Filter which AgentInsights to update
     */
    where?: AgentInsightWhereInput
    /**
     * Limit how many AgentInsights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentInsight upsert
   */
  export type AgentInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentInsight to update in case it exists.
     */
    where: AgentInsightWhereUniqueInput
    /**
     * In case the AgentInsight found by the `where` argument doesn't exist, create a new AgentInsight with this data.
     */
    create: XOR<AgentInsightCreateInput, AgentInsightUncheckedCreateInput>
    /**
     * In case the AgentInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentInsightUpdateInput, AgentInsightUncheckedUpdateInput>
  }

  /**
   * AgentInsight delete
   */
  export type AgentInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
    /**
     * Filter which AgentInsight to delete.
     */
    where: AgentInsightWhereUniqueInput
  }

  /**
   * AgentInsight deleteMany
   */
  export type AgentInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentInsights to delete
     */
    where?: AgentInsightWhereInput
    /**
     * Limit how many AgentInsights to delete.
     */
    limit?: number
  }

  /**
   * AgentInsight without action
   */
  export type AgentInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInsight
     */
    select?: AgentInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInsight
     */
    omit?: AgentInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInsightInclude<ExtArgs> | null
  }


  /**
   * Model AgentFeedback
   */

  export type AggregateAgentFeedback = {
    _count: AgentFeedbackCountAggregateOutputType | null
    _avg: AgentFeedbackAvgAggregateOutputType | null
    _sum: AgentFeedbackSumAggregateOutputType | null
    _min: AgentFeedbackMinAggregateOutputType | null
    _max: AgentFeedbackMaxAggregateOutputType | null
  }

  export type AgentFeedbackAvgAggregateOutputType = {
    stepNumber: number | null
  }

  export type AgentFeedbackSumAggregateOutputType = {
    stepNumber: number | null
  }

  export type AgentFeedbackMinAggregateOutputType = {
    id: string | null
    traceId: string | null
    conversationId: string | null
    userId: string | null
    agentId: string | null
    type: $Enums.FeedbackType | null
    timestamp: Date | null
    originalOutput: string | null
    userEdit: string | null
    correctionText: string | null
    stepNumber: number | null
  }

  export type AgentFeedbackMaxAggregateOutputType = {
    id: string | null
    traceId: string | null
    conversationId: string | null
    userId: string | null
    agentId: string | null
    type: $Enums.FeedbackType | null
    timestamp: Date | null
    originalOutput: string | null
    userEdit: string | null
    correctionText: string | null
    stepNumber: number | null
  }

  export type AgentFeedbackCountAggregateOutputType = {
    id: number
    traceId: number
    conversationId: number
    userId: number
    agentId: number
    type: number
    timestamp: number
    originalOutput: number
    userEdit: number
    correctionText: number
    stepNumber: number
    metadata: number
    _all: number
  }


  export type AgentFeedbackAvgAggregateInputType = {
    stepNumber?: true
  }

  export type AgentFeedbackSumAggregateInputType = {
    stepNumber?: true
  }

  export type AgentFeedbackMinAggregateInputType = {
    id?: true
    traceId?: true
    conversationId?: true
    userId?: true
    agentId?: true
    type?: true
    timestamp?: true
    originalOutput?: true
    userEdit?: true
    correctionText?: true
    stepNumber?: true
  }

  export type AgentFeedbackMaxAggregateInputType = {
    id?: true
    traceId?: true
    conversationId?: true
    userId?: true
    agentId?: true
    type?: true
    timestamp?: true
    originalOutput?: true
    userEdit?: true
    correctionText?: true
    stepNumber?: true
  }

  export type AgentFeedbackCountAggregateInputType = {
    id?: true
    traceId?: true
    conversationId?: true
    userId?: true
    agentId?: true
    type?: true
    timestamp?: true
    originalOutput?: true
    userEdit?: true
    correctionText?: true
    stepNumber?: true
    metadata?: true
    _all?: true
  }

  export type AgentFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentFeedback to aggregate.
     */
    where?: AgentFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentFeedbacks to fetch.
     */
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentFeedbacks
    **/
    _count?: true | AgentFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentFeedbackMaxAggregateInputType
  }

  export type GetAgentFeedbackAggregateType<T extends AgentFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentFeedback[P]>
      : GetScalarType<T[P], AggregateAgentFeedback[P]>
  }




  export type AgentFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentFeedbackWhereInput
    orderBy?: AgentFeedbackOrderByWithAggregationInput | AgentFeedbackOrderByWithAggregationInput[]
    by: AgentFeedbackScalarFieldEnum[] | AgentFeedbackScalarFieldEnum
    having?: AgentFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentFeedbackCountAggregateInputType | true
    _avg?: AgentFeedbackAvgAggregateInputType
    _sum?: AgentFeedbackSumAggregateInputType
    _min?: AgentFeedbackMinAggregateInputType
    _max?: AgentFeedbackMaxAggregateInputType
  }

  export type AgentFeedbackGroupByOutputType = {
    id: string
    traceId: string
    conversationId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp: Date
    originalOutput: string
    userEdit: string | null
    correctionText: string | null
    stepNumber: number
    metadata: JsonValue | null
    _count: AgentFeedbackCountAggregateOutputType | null
    _avg: AgentFeedbackAvgAggregateOutputType | null
    _sum: AgentFeedbackSumAggregateOutputType | null
    _min: AgentFeedbackMinAggregateOutputType | null
    _max: AgentFeedbackMaxAggregateOutputType | null
  }

  type GetAgentFeedbackGroupByPayload<T extends AgentFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], AgentFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type AgentFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    conversationId?: boolean
    userId?: boolean
    agentId?: boolean
    type?: boolean
    timestamp?: boolean
    originalOutput?: boolean
    userEdit?: boolean
    correctionText?: boolean
    stepNumber?: boolean
    metadata?: boolean
    trace?: boolean | AgentTraceDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentFeedback"]>

  export type AgentFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    conversationId?: boolean
    userId?: boolean
    agentId?: boolean
    type?: boolean
    timestamp?: boolean
    originalOutput?: boolean
    userEdit?: boolean
    correctionText?: boolean
    stepNumber?: boolean
    metadata?: boolean
    trace?: boolean | AgentTraceDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentFeedback"]>

  export type AgentFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    traceId?: boolean
    conversationId?: boolean
    userId?: boolean
    agentId?: boolean
    type?: boolean
    timestamp?: boolean
    originalOutput?: boolean
    userEdit?: boolean
    correctionText?: boolean
    stepNumber?: boolean
    metadata?: boolean
    trace?: boolean | AgentTraceDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentFeedback"]>

  export type AgentFeedbackSelectScalar = {
    id?: boolean
    traceId?: boolean
    conversationId?: boolean
    userId?: boolean
    agentId?: boolean
    type?: boolean
    timestamp?: boolean
    originalOutput?: boolean
    userEdit?: boolean
    correctionText?: boolean
    stepNumber?: boolean
    metadata?: boolean
  }

  export type AgentFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "traceId" | "conversationId" | "userId" | "agentId" | "type" | "timestamp" | "originalOutput" | "userEdit" | "correctionText" | "stepNumber" | "metadata", ExtArgs["result"]["agentFeedback"]>
  export type AgentFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trace?: boolean | AgentTraceDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trace?: boolean | AgentTraceDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trace?: boolean | AgentTraceDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentFeedback"
    objects: {
      trace: Prisma.$AgentTracePayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      traceId: string
      conversationId: string
      userId: string
      agentId: string
      type: $Enums.FeedbackType
      timestamp: Date
      originalOutput: string
      userEdit: string | null
      correctionText: string | null
      stepNumber: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["agentFeedback"]>
    composites: {}
  }

  type AgentFeedbackGetPayload<S extends boolean | null | undefined | AgentFeedbackDefaultArgs> = $Result.GetResult<Prisma.$AgentFeedbackPayload, S>

  type AgentFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentFeedbackCountAggregateInputType | true
    }

  export interface AgentFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentFeedback'], meta: { name: 'AgentFeedback' } }
    /**
     * Find zero or one AgentFeedback that matches the filter.
     * @param {AgentFeedbackFindUniqueArgs} args - Arguments to find a AgentFeedback
     * @example
     * // Get one AgentFeedback
     * const agentFeedback = await prisma.agentFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFeedbackFindUniqueArgs>(args: SelectSubset<T, AgentFeedbackFindUniqueArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFeedbackFindUniqueOrThrowArgs} args - Arguments to find a AgentFeedback
     * @example
     * // Get one AgentFeedback
     * const agentFeedback = await prisma.agentFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackFindFirstArgs} args - Arguments to find a AgentFeedback
     * @example
     * // Get one AgentFeedback
     * const agentFeedback = await prisma.agentFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFeedbackFindFirstArgs>(args?: SelectSubset<T, AgentFeedbackFindFirstArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackFindFirstOrThrowArgs} args - Arguments to find a AgentFeedback
     * @example
     * // Get one AgentFeedback
     * const agentFeedback = await prisma.agentFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentFeedbacks
     * const agentFeedbacks = await prisma.agentFeedback.findMany()
     * 
     * // Get first 10 AgentFeedbacks
     * const agentFeedbacks = await prisma.agentFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentFeedbackWithIdOnly = await prisma.agentFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFeedbackFindManyArgs>(args?: SelectSubset<T, AgentFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentFeedback.
     * @param {AgentFeedbackCreateArgs} args - Arguments to create a AgentFeedback.
     * @example
     * // Create one AgentFeedback
     * const AgentFeedback = await prisma.agentFeedback.create({
     *   data: {
     *     // ... data to create a AgentFeedback
     *   }
     * })
     * 
     */
    create<T extends AgentFeedbackCreateArgs>(args: SelectSubset<T, AgentFeedbackCreateArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentFeedbacks.
     * @param {AgentFeedbackCreateManyArgs} args - Arguments to create many AgentFeedbacks.
     * @example
     * // Create many AgentFeedbacks
     * const agentFeedback = await prisma.agentFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentFeedbackCreateManyArgs>(args?: SelectSubset<T, AgentFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentFeedbacks and returns the data saved in the database.
     * @param {AgentFeedbackCreateManyAndReturnArgs} args - Arguments to create many AgentFeedbacks.
     * @example
     * // Create many AgentFeedbacks
     * const agentFeedback = await prisma.agentFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentFeedbacks and only return the `id`
     * const agentFeedbackWithIdOnly = await prisma.agentFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentFeedback.
     * @param {AgentFeedbackDeleteArgs} args - Arguments to delete one AgentFeedback.
     * @example
     * // Delete one AgentFeedback
     * const AgentFeedback = await prisma.agentFeedback.delete({
     *   where: {
     *     // ... filter to delete one AgentFeedback
     *   }
     * })
     * 
     */
    delete<T extends AgentFeedbackDeleteArgs>(args: SelectSubset<T, AgentFeedbackDeleteArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentFeedback.
     * @param {AgentFeedbackUpdateArgs} args - Arguments to update one AgentFeedback.
     * @example
     * // Update one AgentFeedback
     * const agentFeedback = await prisma.agentFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentFeedbackUpdateArgs>(args: SelectSubset<T, AgentFeedbackUpdateArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentFeedbacks.
     * @param {AgentFeedbackDeleteManyArgs} args - Arguments to filter AgentFeedbacks to delete.
     * @example
     * // Delete a few AgentFeedbacks
     * const { count } = await prisma.agentFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentFeedbackDeleteManyArgs>(args?: SelectSubset<T, AgentFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentFeedbacks
     * const agentFeedback = await prisma.agentFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentFeedbackUpdateManyArgs>(args: SelectSubset<T, AgentFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentFeedbacks and returns the data updated in the database.
     * @param {AgentFeedbackUpdateManyAndReturnArgs} args - Arguments to update many AgentFeedbacks.
     * @example
     * // Update many AgentFeedbacks
     * const agentFeedback = await prisma.agentFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentFeedbacks and only return the `id`
     * const agentFeedbackWithIdOnly = await prisma.agentFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentFeedback.
     * @param {AgentFeedbackUpsertArgs} args - Arguments to update or create a AgentFeedback.
     * @example
     * // Update or create a AgentFeedback
     * const agentFeedback = await prisma.agentFeedback.upsert({
     *   create: {
     *     // ... data to create a AgentFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentFeedback we want to update
     *   }
     * })
     */
    upsert<T extends AgentFeedbackUpsertArgs>(args: SelectSubset<T, AgentFeedbackUpsertArgs<ExtArgs>>): Prisma__AgentFeedbackClient<$Result.GetResult<Prisma.$AgentFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackCountArgs} args - Arguments to filter AgentFeedbacks to count.
     * @example
     * // Count the number of AgentFeedbacks
     * const count = await prisma.agentFeedback.count({
     *   where: {
     *     // ... the filter for the AgentFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends AgentFeedbackCountArgs>(
      args?: Subset<T, AgentFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentFeedbackAggregateArgs>(args: Subset<T, AgentFeedbackAggregateArgs>): Prisma.PrismaPromise<GetAgentFeedbackAggregateType<T>>

    /**
     * Group by AgentFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: AgentFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentFeedback model
   */
  readonly fields: AgentFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trace<T extends AgentTraceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentTraceDefaultArgs<ExtArgs>>): Prisma__AgentTraceClient<$Result.GetResult<Prisma.$AgentTracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentFeedback model
   */
  interface AgentFeedbackFieldRefs {
    readonly id: FieldRef<"AgentFeedback", 'String'>
    readonly traceId: FieldRef<"AgentFeedback", 'String'>
    readonly conversationId: FieldRef<"AgentFeedback", 'String'>
    readonly userId: FieldRef<"AgentFeedback", 'String'>
    readonly agentId: FieldRef<"AgentFeedback", 'String'>
    readonly type: FieldRef<"AgentFeedback", 'FeedbackType'>
    readonly timestamp: FieldRef<"AgentFeedback", 'DateTime'>
    readonly originalOutput: FieldRef<"AgentFeedback", 'String'>
    readonly userEdit: FieldRef<"AgentFeedback", 'String'>
    readonly correctionText: FieldRef<"AgentFeedback", 'String'>
    readonly stepNumber: FieldRef<"AgentFeedback", 'Int'>
    readonly metadata: FieldRef<"AgentFeedback", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AgentFeedback findUnique
   */
  export type AgentFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which AgentFeedback to fetch.
     */
    where: AgentFeedbackWhereUniqueInput
  }

  /**
   * AgentFeedback findUniqueOrThrow
   */
  export type AgentFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which AgentFeedback to fetch.
     */
    where: AgentFeedbackWhereUniqueInput
  }

  /**
   * AgentFeedback findFirst
   */
  export type AgentFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which AgentFeedback to fetch.
     */
    where?: AgentFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentFeedbacks to fetch.
     */
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentFeedbacks.
     */
    cursor?: AgentFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentFeedbacks.
     */
    distinct?: AgentFeedbackScalarFieldEnum | AgentFeedbackScalarFieldEnum[]
  }

  /**
   * AgentFeedback findFirstOrThrow
   */
  export type AgentFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which AgentFeedback to fetch.
     */
    where?: AgentFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentFeedbacks to fetch.
     */
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentFeedbacks.
     */
    cursor?: AgentFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentFeedbacks.
     */
    distinct?: AgentFeedbackScalarFieldEnum | AgentFeedbackScalarFieldEnum[]
  }

  /**
   * AgentFeedback findMany
   */
  export type AgentFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which AgentFeedbacks to fetch.
     */
    where?: AgentFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentFeedbacks to fetch.
     */
    orderBy?: AgentFeedbackOrderByWithRelationInput | AgentFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentFeedbacks.
     */
    cursor?: AgentFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentFeedbacks.
     */
    skip?: number
    distinct?: AgentFeedbackScalarFieldEnum | AgentFeedbackScalarFieldEnum[]
  }

  /**
   * AgentFeedback create
   */
  export type AgentFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentFeedback.
     */
    data: XOR<AgentFeedbackCreateInput, AgentFeedbackUncheckedCreateInput>
  }

  /**
   * AgentFeedback createMany
   */
  export type AgentFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentFeedbacks.
     */
    data: AgentFeedbackCreateManyInput | AgentFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentFeedback createManyAndReturn
   */
  export type AgentFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many AgentFeedbacks.
     */
    data: AgentFeedbackCreateManyInput | AgentFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentFeedback update
   */
  export type AgentFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentFeedback.
     */
    data: XOR<AgentFeedbackUpdateInput, AgentFeedbackUncheckedUpdateInput>
    /**
     * Choose, which AgentFeedback to update.
     */
    where: AgentFeedbackWhereUniqueInput
  }

  /**
   * AgentFeedback updateMany
   */
  export type AgentFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentFeedbacks.
     */
    data: XOR<AgentFeedbackUpdateManyMutationInput, AgentFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which AgentFeedbacks to update
     */
    where?: AgentFeedbackWhereInput
    /**
     * Limit how many AgentFeedbacks to update.
     */
    limit?: number
  }

  /**
   * AgentFeedback updateManyAndReturn
   */
  export type AgentFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update AgentFeedbacks.
     */
    data: XOR<AgentFeedbackUpdateManyMutationInput, AgentFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which AgentFeedbacks to update
     */
    where?: AgentFeedbackWhereInput
    /**
     * Limit how many AgentFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentFeedback upsert
   */
  export type AgentFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentFeedback to update in case it exists.
     */
    where: AgentFeedbackWhereUniqueInput
    /**
     * In case the AgentFeedback found by the `where` argument doesn't exist, create a new AgentFeedback with this data.
     */
    create: XOR<AgentFeedbackCreateInput, AgentFeedbackUncheckedCreateInput>
    /**
     * In case the AgentFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentFeedbackUpdateInput, AgentFeedbackUncheckedUpdateInput>
  }

  /**
   * AgentFeedback delete
   */
  export type AgentFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
    /**
     * Filter which AgentFeedback to delete.
     */
    where: AgentFeedbackWhereUniqueInput
  }

  /**
   * AgentFeedback deleteMany
   */
  export type AgentFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentFeedbacks to delete
     */
    where?: AgentFeedbackWhereInput
    /**
     * Limit how many AgentFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * AgentFeedback without action
   */
  export type AgentFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentFeedback
     */
    select?: AgentFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentFeedback
     */
    omit?: AgentFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model AgentABTest
   */

  export type AggregateAgentABTest = {
    _count: AgentABTestCountAggregateOutputType | null
    _avg: AgentABTestAvgAggregateOutputType | null
    _sum: AgentABTestSumAggregateOutputType | null
    _min: AgentABTestMinAggregateOutputType | null
    _max: AgentABTestMaxAggregateOutputType | null
  }

  export type AgentABTestAvgAggregateOutputType = {
    trafficSplit: number | null
    variantATraces: number | null
    variantBTraces: number | null
    variantAScore: number | null
    variantBScore: number | null
  }

  export type AgentABTestSumAggregateOutputType = {
    trafficSplit: number | null
    variantATraces: number | null
    variantBTraces: number | null
    variantAScore: number | null
    variantBScore: number | null
  }

  export type AgentABTestMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    variantAPrompt: string | null
    variantBPrompt: string | null
    trafficSplit: number | null
    status: $Enums.ABTestStatus | null
    startedAt: Date | null
    endedAt: Date | null
    variantATraces: number | null
    variantBTraces: number | null
    variantAScore: number | null
    variantBScore: number | null
    winningVariant: string | null
  }

  export type AgentABTestMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    variantAPrompt: string | null
    variantBPrompt: string | null
    trafficSplit: number | null
    status: $Enums.ABTestStatus | null
    startedAt: Date | null
    endedAt: Date | null
    variantATraces: number | null
    variantBTraces: number | null
    variantAScore: number | null
    variantBScore: number | null
    winningVariant: string | null
  }

  export type AgentABTestCountAggregateOutputType = {
    id: number
    agentId: number
    variantAPrompt: number
    variantBPrompt: number
    trafficSplit: number
    status: number
    startedAt: number
    endedAt: number
    variantATraces: number
    variantBTraces: number
    variantAScore: number
    variantBScore: number
    winningVariant: number
    _all: number
  }


  export type AgentABTestAvgAggregateInputType = {
    trafficSplit?: true
    variantATraces?: true
    variantBTraces?: true
    variantAScore?: true
    variantBScore?: true
  }

  export type AgentABTestSumAggregateInputType = {
    trafficSplit?: true
    variantATraces?: true
    variantBTraces?: true
    variantAScore?: true
    variantBScore?: true
  }

  export type AgentABTestMinAggregateInputType = {
    id?: true
    agentId?: true
    variantAPrompt?: true
    variantBPrompt?: true
    trafficSplit?: true
    status?: true
    startedAt?: true
    endedAt?: true
    variantATraces?: true
    variantBTraces?: true
    variantAScore?: true
    variantBScore?: true
    winningVariant?: true
  }

  export type AgentABTestMaxAggregateInputType = {
    id?: true
    agentId?: true
    variantAPrompt?: true
    variantBPrompt?: true
    trafficSplit?: true
    status?: true
    startedAt?: true
    endedAt?: true
    variantATraces?: true
    variantBTraces?: true
    variantAScore?: true
    variantBScore?: true
    winningVariant?: true
  }

  export type AgentABTestCountAggregateInputType = {
    id?: true
    agentId?: true
    variantAPrompt?: true
    variantBPrompt?: true
    trafficSplit?: true
    status?: true
    startedAt?: true
    endedAt?: true
    variantATraces?: true
    variantBTraces?: true
    variantAScore?: true
    variantBScore?: true
    winningVariant?: true
    _all?: true
  }

  export type AgentABTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentABTest to aggregate.
     */
    where?: AgentABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentABTests to fetch.
     */
    orderBy?: AgentABTestOrderByWithRelationInput | AgentABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentABTests
    **/
    _count?: true | AgentABTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentABTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentABTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentABTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentABTestMaxAggregateInputType
  }

  export type GetAgentABTestAggregateType<T extends AgentABTestAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentABTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentABTest[P]>
      : GetScalarType<T[P], AggregateAgentABTest[P]>
  }




  export type AgentABTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentABTestWhereInput
    orderBy?: AgentABTestOrderByWithAggregationInput | AgentABTestOrderByWithAggregationInput[]
    by: AgentABTestScalarFieldEnum[] | AgentABTestScalarFieldEnum
    having?: AgentABTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentABTestCountAggregateInputType | true
    _avg?: AgentABTestAvgAggregateInputType
    _sum?: AgentABTestSumAggregateInputType
    _min?: AgentABTestMinAggregateInputType
    _max?: AgentABTestMaxAggregateInputType
  }

  export type AgentABTestGroupByOutputType = {
    id: string
    agentId: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit: number
    status: $Enums.ABTestStatus
    startedAt: Date
    endedAt: Date | null
    variantATraces: number
    variantBTraces: number
    variantAScore: number | null
    variantBScore: number | null
    winningVariant: string | null
    _count: AgentABTestCountAggregateOutputType | null
    _avg: AgentABTestAvgAggregateOutputType | null
    _sum: AgentABTestSumAggregateOutputType | null
    _min: AgentABTestMinAggregateOutputType | null
    _max: AgentABTestMaxAggregateOutputType | null
  }

  type GetAgentABTestGroupByPayload<T extends AgentABTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentABTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentABTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentABTestGroupByOutputType[P]>
            : GetScalarType<T[P], AgentABTestGroupByOutputType[P]>
        }
      >
    >


  export type AgentABTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    variantAPrompt?: boolean
    variantBPrompt?: boolean
    trafficSplit?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    variantATraces?: boolean
    variantBTraces?: boolean
    variantAScore?: boolean
    variantBScore?: boolean
    winningVariant?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentABTest"]>

  export type AgentABTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    variantAPrompt?: boolean
    variantBPrompt?: boolean
    trafficSplit?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    variantATraces?: boolean
    variantBTraces?: boolean
    variantAScore?: boolean
    variantBScore?: boolean
    winningVariant?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentABTest"]>

  export type AgentABTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    variantAPrompt?: boolean
    variantBPrompt?: boolean
    trafficSplit?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    variantATraces?: boolean
    variantBTraces?: boolean
    variantAScore?: boolean
    variantBScore?: boolean
    winningVariant?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentABTest"]>

  export type AgentABTestSelectScalar = {
    id?: boolean
    agentId?: boolean
    variantAPrompt?: boolean
    variantBPrompt?: boolean
    trafficSplit?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    variantATraces?: boolean
    variantBTraces?: boolean
    variantAScore?: boolean
    variantBScore?: boolean
    winningVariant?: boolean
  }

  export type AgentABTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "variantAPrompt" | "variantBPrompt" | "trafficSplit" | "status" | "startedAt" | "endedAt" | "variantATraces" | "variantBTraces" | "variantAScore" | "variantBScore" | "winningVariant", ExtArgs["result"]["agentABTest"]>
  export type AgentABTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentABTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentABTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentABTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentABTest"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      variantAPrompt: string
      variantBPrompt: string
      trafficSplit: number
      status: $Enums.ABTestStatus
      startedAt: Date
      endedAt: Date | null
      variantATraces: number
      variantBTraces: number
      variantAScore: number | null
      variantBScore: number | null
      winningVariant: string | null
    }, ExtArgs["result"]["agentABTest"]>
    composites: {}
  }

  type AgentABTestGetPayload<S extends boolean | null | undefined | AgentABTestDefaultArgs> = $Result.GetResult<Prisma.$AgentABTestPayload, S>

  type AgentABTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentABTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentABTestCountAggregateInputType | true
    }

  export interface AgentABTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentABTest'], meta: { name: 'AgentABTest' } }
    /**
     * Find zero or one AgentABTest that matches the filter.
     * @param {AgentABTestFindUniqueArgs} args - Arguments to find a AgentABTest
     * @example
     * // Get one AgentABTest
     * const agentABTest = await prisma.agentABTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentABTestFindUniqueArgs>(args: SelectSubset<T, AgentABTestFindUniqueArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentABTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentABTestFindUniqueOrThrowArgs} args - Arguments to find a AgentABTest
     * @example
     * // Get one AgentABTest
     * const agentABTest = await prisma.agentABTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentABTestFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentABTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentABTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestFindFirstArgs} args - Arguments to find a AgentABTest
     * @example
     * // Get one AgentABTest
     * const agentABTest = await prisma.agentABTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentABTestFindFirstArgs>(args?: SelectSubset<T, AgentABTestFindFirstArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentABTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestFindFirstOrThrowArgs} args - Arguments to find a AgentABTest
     * @example
     * // Get one AgentABTest
     * const agentABTest = await prisma.agentABTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentABTestFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentABTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentABTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentABTests
     * const agentABTests = await prisma.agentABTest.findMany()
     * 
     * // Get first 10 AgentABTests
     * const agentABTests = await prisma.agentABTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentABTestWithIdOnly = await prisma.agentABTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentABTestFindManyArgs>(args?: SelectSubset<T, AgentABTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentABTest.
     * @param {AgentABTestCreateArgs} args - Arguments to create a AgentABTest.
     * @example
     * // Create one AgentABTest
     * const AgentABTest = await prisma.agentABTest.create({
     *   data: {
     *     // ... data to create a AgentABTest
     *   }
     * })
     * 
     */
    create<T extends AgentABTestCreateArgs>(args: SelectSubset<T, AgentABTestCreateArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentABTests.
     * @param {AgentABTestCreateManyArgs} args - Arguments to create many AgentABTests.
     * @example
     * // Create many AgentABTests
     * const agentABTest = await prisma.agentABTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentABTestCreateManyArgs>(args?: SelectSubset<T, AgentABTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentABTests and returns the data saved in the database.
     * @param {AgentABTestCreateManyAndReturnArgs} args - Arguments to create many AgentABTests.
     * @example
     * // Create many AgentABTests
     * const agentABTest = await prisma.agentABTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentABTests and only return the `id`
     * const agentABTestWithIdOnly = await prisma.agentABTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentABTestCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentABTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentABTest.
     * @param {AgentABTestDeleteArgs} args - Arguments to delete one AgentABTest.
     * @example
     * // Delete one AgentABTest
     * const AgentABTest = await prisma.agentABTest.delete({
     *   where: {
     *     // ... filter to delete one AgentABTest
     *   }
     * })
     * 
     */
    delete<T extends AgentABTestDeleteArgs>(args: SelectSubset<T, AgentABTestDeleteArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentABTest.
     * @param {AgentABTestUpdateArgs} args - Arguments to update one AgentABTest.
     * @example
     * // Update one AgentABTest
     * const agentABTest = await prisma.agentABTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentABTestUpdateArgs>(args: SelectSubset<T, AgentABTestUpdateArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentABTests.
     * @param {AgentABTestDeleteManyArgs} args - Arguments to filter AgentABTests to delete.
     * @example
     * // Delete a few AgentABTests
     * const { count } = await prisma.agentABTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentABTestDeleteManyArgs>(args?: SelectSubset<T, AgentABTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentABTests
     * const agentABTest = await prisma.agentABTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentABTestUpdateManyArgs>(args: SelectSubset<T, AgentABTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentABTests and returns the data updated in the database.
     * @param {AgentABTestUpdateManyAndReturnArgs} args - Arguments to update many AgentABTests.
     * @example
     * // Update many AgentABTests
     * const agentABTest = await prisma.agentABTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentABTests and only return the `id`
     * const agentABTestWithIdOnly = await prisma.agentABTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentABTestUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentABTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentABTest.
     * @param {AgentABTestUpsertArgs} args - Arguments to update or create a AgentABTest.
     * @example
     * // Update or create a AgentABTest
     * const agentABTest = await prisma.agentABTest.upsert({
     *   create: {
     *     // ... data to create a AgentABTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentABTest we want to update
     *   }
     * })
     */
    upsert<T extends AgentABTestUpsertArgs>(args: SelectSubset<T, AgentABTestUpsertArgs<ExtArgs>>): Prisma__AgentABTestClient<$Result.GetResult<Prisma.$AgentABTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestCountArgs} args - Arguments to filter AgentABTests to count.
     * @example
     * // Count the number of AgentABTests
     * const count = await prisma.agentABTest.count({
     *   where: {
     *     // ... the filter for the AgentABTests we want to count
     *   }
     * })
    **/
    count<T extends AgentABTestCountArgs>(
      args?: Subset<T, AgentABTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentABTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentABTestAggregateArgs>(args: Subset<T, AgentABTestAggregateArgs>): Prisma.PrismaPromise<GetAgentABTestAggregateType<T>>

    /**
     * Group by AgentABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentABTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentABTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentABTestGroupByArgs['orderBy'] }
        : { orderBy?: AgentABTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentABTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentABTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentABTest model
   */
  readonly fields: AgentABTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentABTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentABTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentABTest model
   */
  interface AgentABTestFieldRefs {
    readonly id: FieldRef<"AgentABTest", 'String'>
    readonly agentId: FieldRef<"AgentABTest", 'String'>
    readonly variantAPrompt: FieldRef<"AgentABTest", 'String'>
    readonly variantBPrompt: FieldRef<"AgentABTest", 'String'>
    readonly trafficSplit: FieldRef<"AgentABTest", 'Float'>
    readonly status: FieldRef<"AgentABTest", 'ABTestStatus'>
    readonly startedAt: FieldRef<"AgentABTest", 'DateTime'>
    readonly endedAt: FieldRef<"AgentABTest", 'DateTime'>
    readonly variantATraces: FieldRef<"AgentABTest", 'Int'>
    readonly variantBTraces: FieldRef<"AgentABTest", 'Int'>
    readonly variantAScore: FieldRef<"AgentABTest", 'Float'>
    readonly variantBScore: FieldRef<"AgentABTest", 'Float'>
    readonly winningVariant: FieldRef<"AgentABTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgentABTest findUnique
   */
  export type AgentABTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * Filter, which AgentABTest to fetch.
     */
    where: AgentABTestWhereUniqueInput
  }

  /**
   * AgentABTest findUniqueOrThrow
   */
  export type AgentABTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * Filter, which AgentABTest to fetch.
     */
    where: AgentABTestWhereUniqueInput
  }

  /**
   * AgentABTest findFirst
   */
  export type AgentABTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * Filter, which AgentABTest to fetch.
     */
    where?: AgentABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentABTests to fetch.
     */
    orderBy?: AgentABTestOrderByWithRelationInput | AgentABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentABTests.
     */
    cursor?: AgentABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentABTests.
     */
    distinct?: AgentABTestScalarFieldEnum | AgentABTestScalarFieldEnum[]
  }

  /**
   * AgentABTest findFirstOrThrow
   */
  export type AgentABTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * Filter, which AgentABTest to fetch.
     */
    where?: AgentABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentABTests to fetch.
     */
    orderBy?: AgentABTestOrderByWithRelationInput | AgentABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentABTests.
     */
    cursor?: AgentABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentABTests.
     */
    distinct?: AgentABTestScalarFieldEnum | AgentABTestScalarFieldEnum[]
  }

  /**
   * AgentABTest findMany
   */
  export type AgentABTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * Filter, which AgentABTests to fetch.
     */
    where?: AgentABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentABTests to fetch.
     */
    orderBy?: AgentABTestOrderByWithRelationInput | AgentABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentABTests.
     */
    cursor?: AgentABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentABTests.
     */
    skip?: number
    distinct?: AgentABTestScalarFieldEnum | AgentABTestScalarFieldEnum[]
  }

  /**
   * AgentABTest create
   */
  export type AgentABTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentABTest.
     */
    data: XOR<AgentABTestCreateInput, AgentABTestUncheckedCreateInput>
  }

  /**
   * AgentABTest createMany
   */
  export type AgentABTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentABTests.
     */
    data: AgentABTestCreateManyInput | AgentABTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentABTest createManyAndReturn
   */
  export type AgentABTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * The data used to create many AgentABTests.
     */
    data: AgentABTestCreateManyInput | AgentABTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentABTest update
   */
  export type AgentABTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentABTest.
     */
    data: XOR<AgentABTestUpdateInput, AgentABTestUncheckedUpdateInput>
    /**
     * Choose, which AgentABTest to update.
     */
    where: AgentABTestWhereUniqueInput
  }

  /**
   * AgentABTest updateMany
   */
  export type AgentABTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentABTests.
     */
    data: XOR<AgentABTestUpdateManyMutationInput, AgentABTestUncheckedUpdateManyInput>
    /**
     * Filter which AgentABTests to update
     */
    where?: AgentABTestWhereInput
    /**
     * Limit how many AgentABTests to update.
     */
    limit?: number
  }

  /**
   * AgentABTest updateManyAndReturn
   */
  export type AgentABTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * The data used to update AgentABTests.
     */
    data: XOR<AgentABTestUpdateManyMutationInput, AgentABTestUncheckedUpdateManyInput>
    /**
     * Filter which AgentABTests to update
     */
    where?: AgentABTestWhereInput
    /**
     * Limit how many AgentABTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentABTest upsert
   */
  export type AgentABTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentABTest to update in case it exists.
     */
    where: AgentABTestWhereUniqueInput
    /**
     * In case the AgentABTest found by the `where` argument doesn't exist, create a new AgentABTest with this data.
     */
    create: XOR<AgentABTestCreateInput, AgentABTestUncheckedCreateInput>
    /**
     * In case the AgentABTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentABTestUpdateInput, AgentABTestUncheckedUpdateInput>
  }

  /**
   * AgentABTest delete
   */
  export type AgentABTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
    /**
     * Filter which AgentABTest to delete.
     */
    where: AgentABTestWhereUniqueInput
  }

  /**
   * AgentABTest deleteMany
   */
  export type AgentABTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentABTests to delete
     */
    where?: AgentABTestWhereInput
    /**
     * Limit how many AgentABTests to delete.
     */
    limit?: number
  }

  /**
   * AgentABTest without action
   */
  export type AgentABTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentABTest
     */
    select?: AgentABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentABTest
     */
    omit?: AgentABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentABTestInclude<ExtArgs> | null
  }


  /**
   * Model OptimizationRun
   */

  export type AggregateOptimizationRun = {
    _count: OptimizationRunCountAggregateOutputType | null
    _min: OptimizationRunMinAggregateOutputType | null
    _max: OptimizationRunMaxAggregateOutputType | null
  }

  export type OptimizationRunMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    triggeredAt: Date | null
    triggeredBy: string | null
    recommendation: string | null
    abTestId: string | null
    status: string | null
  }

  export type OptimizationRunMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    triggeredAt: Date | null
    triggeredBy: string | null
    recommendation: string | null
    abTestId: string | null
    status: string | null
  }

  export type OptimizationRunCountAggregateOutputType = {
    id: number
    agentId: number
    triggeredAt: number
    triggeredBy: number
    editPatterns: number
    promptVariations: number
    testResults: number
    recommendation: number
    abTestId: number
    status: number
    _all: number
  }


  export type OptimizationRunMinAggregateInputType = {
    id?: true
    agentId?: true
    triggeredAt?: true
    triggeredBy?: true
    recommendation?: true
    abTestId?: true
    status?: true
  }

  export type OptimizationRunMaxAggregateInputType = {
    id?: true
    agentId?: true
    triggeredAt?: true
    triggeredBy?: true
    recommendation?: true
    abTestId?: true
    status?: true
  }

  export type OptimizationRunCountAggregateInputType = {
    id?: true
    agentId?: true
    triggeredAt?: true
    triggeredBy?: true
    editPatterns?: true
    promptVariations?: true
    testResults?: true
    recommendation?: true
    abTestId?: true
    status?: true
    _all?: true
  }

  export type OptimizationRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptimizationRun to aggregate.
     */
    where?: OptimizationRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRuns to fetch.
     */
    orderBy?: OptimizationRunOrderByWithRelationInput | OptimizationRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptimizationRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptimizationRuns
    **/
    _count?: true | OptimizationRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptimizationRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptimizationRunMaxAggregateInputType
  }

  export type GetOptimizationRunAggregateType<T extends OptimizationRunAggregateArgs> = {
        [P in keyof T & keyof AggregateOptimizationRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptimizationRun[P]>
      : GetScalarType<T[P], AggregateOptimizationRun[P]>
  }




  export type OptimizationRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptimizationRunWhereInput
    orderBy?: OptimizationRunOrderByWithAggregationInput | OptimizationRunOrderByWithAggregationInput[]
    by: OptimizationRunScalarFieldEnum[] | OptimizationRunScalarFieldEnum
    having?: OptimizationRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptimizationRunCountAggregateInputType | true
    _min?: OptimizationRunMinAggregateInputType
    _max?: OptimizationRunMaxAggregateInputType
  }

  export type OptimizationRunGroupByOutputType = {
    id: string
    agentId: string
    triggeredAt: Date
    triggeredBy: string
    editPatterns: JsonValue
    promptVariations: JsonValue
    testResults: JsonValue
    recommendation: string
    abTestId: string | null
    status: string
    _count: OptimizationRunCountAggregateOutputType | null
    _min: OptimizationRunMinAggregateOutputType | null
    _max: OptimizationRunMaxAggregateOutputType | null
  }

  type GetOptimizationRunGroupByPayload<T extends OptimizationRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptimizationRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptimizationRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptimizationRunGroupByOutputType[P]>
            : GetScalarType<T[P], OptimizationRunGroupByOutputType[P]>
        }
      >
    >


  export type OptimizationRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    editPatterns?: boolean
    promptVariations?: boolean
    testResults?: boolean
    recommendation?: boolean
    abTestId?: boolean
    status?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRun"]>

  export type OptimizationRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    editPatterns?: boolean
    promptVariations?: boolean
    testResults?: boolean
    recommendation?: boolean
    abTestId?: boolean
    status?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRun"]>

  export type OptimizationRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    editPatterns?: boolean
    promptVariations?: boolean
    testResults?: boolean
    recommendation?: boolean
    abTestId?: boolean
    status?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRun"]>

  export type OptimizationRunSelectScalar = {
    id?: boolean
    agentId?: boolean
    triggeredAt?: boolean
    triggeredBy?: boolean
    editPatterns?: boolean
    promptVariations?: boolean
    testResults?: boolean
    recommendation?: boolean
    abTestId?: boolean
    status?: boolean
  }

  export type OptimizationRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "triggeredAt" | "triggeredBy" | "editPatterns" | "promptVariations" | "testResults" | "recommendation" | "abTestId" | "status", ExtArgs["result"]["optimizationRun"]>
  export type OptimizationRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type OptimizationRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type OptimizationRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $OptimizationRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptimizationRun"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      triggeredAt: Date
      triggeredBy: string
      editPatterns: Prisma.JsonValue
      promptVariations: Prisma.JsonValue
      testResults: Prisma.JsonValue
      recommendation: string
      abTestId: string | null
      status: string
    }, ExtArgs["result"]["optimizationRun"]>
    composites: {}
  }

  type OptimizationRunGetPayload<S extends boolean | null | undefined | OptimizationRunDefaultArgs> = $Result.GetResult<Prisma.$OptimizationRunPayload, S>

  type OptimizationRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptimizationRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptimizationRunCountAggregateInputType | true
    }

  export interface OptimizationRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptimizationRun'], meta: { name: 'OptimizationRun' } }
    /**
     * Find zero or one OptimizationRun that matches the filter.
     * @param {OptimizationRunFindUniqueArgs} args - Arguments to find a OptimizationRun
     * @example
     * // Get one OptimizationRun
     * const optimizationRun = await prisma.optimizationRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptimizationRunFindUniqueArgs>(args: SelectSubset<T, OptimizationRunFindUniqueArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OptimizationRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptimizationRunFindUniqueOrThrowArgs} args - Arguments to find a OptimizationRun
     * @example
     * // Get one OptimizationRun
     * const optimizationRun = await prisma.optimizationRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptimizationRunFindUniqueOrThrowArgs>(args: SelectSubset<T, OptimizationRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptimizationRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunFindFirstArgs} args - Arguments to find a OptimizationRun
     * @example
     * // Get one OptimizationRun
     * const optimizationRun = await prisma.optimizationRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptimizationRunFindFirstArgs>(args?: SelectSubset<T, OptimizationRunFindFirstArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptimizationRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunFindFirstOrThrowArgs} args - Arguments to find a OptimizationRun
     * @example
     * // Get one OptimizationRun
     * const optimizationRun = await prisma.optimizationRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptimizationRunFindFirstOrThrowArgs>(args?: SelectSubset<T, OptimizationRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OptimizationRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptimizationRuns
     * const optimizationRuns = await prisma.optimizationRun.findMany()
     * 
     * // Get first 10 OptimizationRuns
     * const optimizationRuns = await prisma.optimizationRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optimizationRunWithIdOnly = await prisma.optimizationRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptimizationRunFindManyArgs>(args?: SelectSubset<T, OptimizationRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OptimizationRun.
     * @param {OptimizationRunCreateArgs} args - Arguments to create a OptimizationRun.
     * @example
     * // Create one OptimizationRun
     * const OptimizationRun = await prisma.optimizationRun.create({
     *   data: {
     *     // ... data to create a OptimizationRun
     *   }
     * })
     * 
     */
    create<T extends OptimizationRunCreateArgs>(args: SelectSubset<T, OptimizationRunCreateArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OptimizationRuns.
     * @param {OptimizationRunCreateManyArgs} args - Arguments to create many OptimizationRuns.
     * @example
     * // Create many OptimizationRuns
     * const optimizationRun = await prisma.optimizationRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptimizationRunCreateManyArgs>(args?: SelectSubset<T, OptimizationRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OptimizationRuns and returns the data saved in the database.
     * @param {OptimizationRunCreateManyAndReturnArgs} args - Arguments to create many OptimizationRuns.
     * @example
     * // Create many OptimizationRuns
     * const optimizationRun = await prisma.optimizationRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OptimizationRuns and only return the `id`
     * const optimizationRunWithIdOnly = await prisma.optimizationRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptimizationRunCreateManyAndReturnArgs>(args?: SelectSubset<T, OptimizationRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OptimizationRun.
     * @param {OptimizationRunDeleteArgs} args - Arguments to delete one OptimizationRun.
     * @example
     * // Delete one OptimizationRun
     * const OptimizationRun = await prisma.optimizationRun.delete({
     *   where: {
     *     // ... filter to delete one OptimizationRun
     *   }
     * })
     * 
     */
    delete<T extends OptimizationRunDeleteArgs>(args: SelectSubset<T, OptimizationRunDeleteArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OptimizationRun.
     * @param {OptimizationRunUpdateArgs} args - Arguments to update one OptimizationRun.
     * @example
     * // Update one OptimizationRun
     * const optimizationRun = await prisma.optimizationRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptimizationRunUpdateArgs>(args: SelectSubset<T, OptimizationRunUpdateArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OptimizationRuns.
     * @param {OptimizationRunDeleteManyArgs} args - Arguments to filter OptimizationRuns to delete.
     * @example
     * // Delete a few OptimizationRuns
     * const { count } = await prisma.optimizationRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptimizationRunDeleteManyArgs>(args?: SelectSubset<T, OptimizationRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptimizationRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptimizationRuns
     * const optimizationRun = await prisma.optimizationRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptimizationRunUpdateManyArgs>(args: SelectSubset<T, OptimizationRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptimizationRuns and returns the data updated in the database.
     * @param {OptimizationRunUpdateManyAndReturnArgs} args - Arguments to update many OptimizationRuns.
     * @example
     * // Update many OptimizationRuns
     * const optimizationRun = await prisma.optimizationRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OptimizationRuns and only return the `id`
     * const optimizationRunWithIdOnly = await prisma.optimizationRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptimizationRunUpdateManyAndReturnArgs>(args: SelectSubset<T, OptimizationRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OptimizationRun.
     * @param {OptimizationRunUpsertArgs} args - Arguments to update or create a OptimizationRun.
     * @example
     * // Update or create a OptimizationRun
     * const optimizationRun = await prisma.optimizationRun.upsert({
     *   create: {
     *     // ... data to create a OptimizationRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptimizationRun we want to update
     *   }
     * })
     */
    upsert<T extends OptimizationRunUpsertArgs>(args: SelectSubset<T, OptimizationRunUpsertArgs<ExtArgs>>): Prisma__OptimizationRunClient<$Result.GetResult<Prisma.$OptimizationRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OptimizationRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunCountArgs} args - Arguments to filter OptimizationRuns to count.
     * @example
     * // Count the number of OptimizationRuns
     * const count = await prisma.optimizationRun.count({
     *   where: {
     *     // ... the filter for the OptimizationRuns we want to count
     *   }
     * })
    **/
    count<T extends OptimizationRunCountArgs>(
      args?: Subset<T, OptimizationRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptimizationRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptimizationRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptimizationRunAggregateArgs>(args: Subset<T, OptimizationRunAggregateArgs>): Prisma.PrismaPromise<GetOptimizationRunAggregateType<T>>

    /**
     * Group by OptimizationRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptimizationRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptimizationRunGroupByArgs['orderBy'] }
        : { orderBy?: OptimizationRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptimizationRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptimizationRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptimizationRun model
   */
  readonly fields: OptimizationRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptimizationRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptimizationRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptimizationRun model
   */
  interface OptimizationRunFieldRefs {
    readonly id: FieldRef<"OptimizationRun", 'String'>
    readonly agentId: FieldRef<"OptimizationRun", 'String'>
    readonly triggeredAt: FieldRef<"OptimizationRun", 'DateTime'>
    readonly triggeredBy: FieldRef<"OptimizationRun", 'String'>
    readonly editPatterns: FieldRef<"OptimizationRun", 'Json'>
    readonly promptVariations: FieldRef<"OptimizationRun", 'Json'>
    readonly testResults: FieldRef<"OptimizationRun", 'Json'>
    readonly recommendation: FieldRef<"OptimizationRun", 'String'>
    readonly abTestId: FieldRef<"OptimizationRun", 'String'>
    readonly status: FieldRef<"OptimizationRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OptimizationRun findUnique
   */
  export type OptimizationRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRun to fetch.
     */
    where: OptimizationRunWhereUniqueInput
  }

  /**
   * OptimizationRun findUniqueOrThrow
   */
  export type OptimizationRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRun to fetch.
     */
    where: OptimizationRunWhereUniqueInput
  }

  /**
   * OptimizationRun findFirst
   */
  export type OptimizationRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRun to fetch.
     */
    where?: OptimizationRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRuns to fetch.
     */
    orderBy?: OptimizationRunOrderByWithRelationInput | OptimizationRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptimizationRuns.
     */
    cursor?: OptimizationRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptimizationRuns.
     */
    distinct?: OptimizationRunScalarFieldEnum | OptimizationRunScalarFieldEnum[]
  }

  /**
   * OptimizationRun findFirstOrThrow
   */
  export type OptimizationRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRun to fetch.
     */
    where?: OptimizationRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRuns to fetch.
     */
    orderBy?: OptimizationRunOrderByWithRelationInput | OptimizationRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptimizationRuns.
     */
    cursor?: OptimizationRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptimizationRuns.
     */
    distinct?: OptimizationRunScalarFieldEnum | OptimizationRunScalarFieldEnum[]
  }

  /**
   * OptimizationRun findMany
   */
  export type OptimizationRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRuns to fetch.
     */
    where?: OptimizationRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRuns to fetch.
     */
    orderBy?: OptimizationRunOrderByWithRelationInput | OptimizationRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptimizationRuns.
     */
    cursor?: OptimizationRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRuns.
     */
    skip?: number
    distinct?: OptimizationRunScalarFieldEnum | OptimizationRunScalarFieldEnum[]
  }

  /**
   * OptimizationRun create
   */
  export type OptimizationRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * The data needed to create a OptimizationRun.
     */
    data: XOR<OptimizationRunCreateInput, OptimizationRunUncheckedCreateInput>
  }

  /**
   * OptimizationRun createMany
   */
  export type OptimizationRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptimizationRuns.
     */
    data: OptimizationRunCreateManyInput | OptimizationRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OptimizationRun createManyAndReturn
   */
  export type OptimizationRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * The data used to create many OptimizationRuns.
     */
    data: OptimizationRunCreateManyInput | OptimizationRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptimizationRun update
   */
  export type OptimizationRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * The data needed to update a OptimizationRun.
     */
    data: XOR<OptimizationRunUpdateInput, OptimizationRunUncheckedUpdateInput>
    /**
     * Choose, which OptimizationRun to update.
     */
    where: OptimizationRunWhereUniqueInput
  }

  /**
   * OptimizationRun updateMany
   */
  export type OptimizationRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptimizationRuns.
     */
    data: XOR<OptimizationRunUpdateManyMutationInput, OptimizationRunUncheckedUpdateManyInput>
    /**
     * Filter which OptimizationRuns to update
     */
    where?: OptimizationRunWhereInput
    /**
     * Limit how many OptimizationRuns to update.
     */
    limit?: number
  }

  /**
   * OptimizationRun updateManyAndReturn
   */
  export type OptimizationRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * The data used to update OptimizationRuns.
     */
    data: XOR<OptimizationRunUpdateManyMutationInput, OptimizationRunUncheckedUpdateManyInput>
    /**
     * Filter which OptimizationRuns to update
     */
    where?: OptimizationRunWhereInput
    /**
     * Limit how many OptimizationRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptimizationRun upsert
   */
  export type OptimizationRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * The filter to search for the OptimizationRun to update in case it exists.
     */
    where: OptimizationRunWhereUniqueInput
    /**
     * In case the OptimizationRun found by the `where` argument doesn't exist, create a new OptimizationRun with this data.
     */
    create: XOR<OptimizationRunCreateInput, OptimizationRunUncheckedCreateInput>
    /**
     * In case the OptimizationRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptimizationRunUpdateInput, OptimizationRunUncheckedUpdateInput>
  }

  /**
   * OptimizationRun delete
   */
  export type OptimizationRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
    /**
     * Filter which OptimizationRun to delete.
     */
    where: OptimizationRunWhereUniqueInput
  }

  /**
   * OptimizationRun deleteMany
   */
  export type OptimizationRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptimizationRuns to delete
     */
    where?: OptimizationRunWhereInput
    /**
     * Limit how many OptimizationRuns to delete.
     */
    limit?: number
  }

  /**
   * OptimizationRun without action
   */
  export type OptimizationRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRun
     */
    select?: OptimizationRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRun
     */
    omit?: OptimizationRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRunInclude<ExtArgs> | null
  }


  /**
   * Model ModificationProposal
   */

  export type AggregateModificationProposal = {
    _count: ModificationProposalCountAggregateOutputType | null
    _min: ModificationProposalMinAggregateOutputType | null
    _max: ModificationProposalMaxAggregateOutputType | null
  }

  export type ModificationProposalMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    proposedAt: Date | null
    type: $Enums.ModificationType | null
    current: string | null
    proposed: string | null
    rationale: string | null
    impact: string | null
    status: $Enums.ProposalStatus | null
    reviewedAt: Date | null
    reviewedBy: string | null
    appliedAt: Date | null
  }

  export type ModificationProposalMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    proposedAt: Date | null
    type: $Enums.ModificationType | null
    current: string | null
    proposed: string | null
    rationale: string | null
    impact: string | null
    status: $Enums.ProposalStatus | null
    reviewedAt: Date | null
    reviewedBy: string | null
    appliedAt: Date | null
  }

  export type ModificationProposalCountAggregateOutputType = {
    id: number
    agentId: number
    proposedAt: number
    type: number
    current: number
    proposed: number
    rationale: number
    impact: number
    status: number
    reviewedAt: number
    reviewedBy: number
    appliedAt: number
    _all: number
  }


  export type ModificationProposalMinAggregateInputType = {
    id?: true
    agentId?: true
    proposedAt?: true
    type?: true
    current?: true
    proposed?: true
    rationale?: true
    impact?: true
    status?: true
    reviewedAt?: true
    reviewedBy?: true
    appliedAt?: true
  }

  export type ModificationProposalMaxAggregateInputType = {
    id?: true
    agentId?: true
    proposedAt?: true
    type?: true
    current?: true
    proposed?: true
    rationale?: true
    impact?: true
    status?: true
    reviewedAt?: true
    reviewedBy?: true
    appliedAt?: true
  }

  export type ModificationProposalCountAggregateInputType = {
    id?: true
    agentId?: true
    proposedAt?: true
    type?: true
    current?: true
    proposed?: true
    rationale?: true
    impact?: true
    status?: true
    reviewedAt?: true
    reviewedBy?: true
    appliedAt?: true
    _all?: true
  }

  export type ModificationProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModificationProposal to aggregate.
     */
    where?: ModificationProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModificationProposals to fetch.
     */
    orderBy?: ModificationProposalOrderByWithRelationInput | ModificationProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModificationProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModificationProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModificationProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModificationProposals
    **/
    _count?: true | ModificationProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModificationProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModificationProposalMaxAggregateInputType
  }

  export type GetModificationProposalAggregateType<T extends ModificationProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateModificationProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModificationProposal[P]>
      : GetScalarType<T[P], AggregateModificationProposal[P]>
  }




  export type ModificationProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModificationProposalWhereInput
    orderBy?: ModificationProposalOrderByWithAggregationInput | ModificationProposalOrderByWithAggregationInput[]
    by: ModificationProposalScalarFieldEnum[] | ModificationProposalScalarFieldEnum
    having?: ModificationProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModificationProposalCountAggregateInputType | true
    _min?: ModificationProposalMinAggregateInputType
    _max?: ModificationProposalMaxAggregateInputType
  }

  export type ModificationProposalGroupByOutputType = {
    id: string
    agentId: string
    proposedAt: Date
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status: $Enums.ProposalStatus
    reviewedAt: Date | null
    reviewedBy: string | null
    appliedAt: Date | null
    _count: ModificationProposalCountAggregateOutputType | null
    _min: ModificationProposalMinAggregateOutputType | null
    _max: ModificationProposalMaxAggregateOutputType | null
  }

  type GetModificationProposalGroupByPayload<T extends ModificationProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModificationProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModificationProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModificationProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ModificationProposalGroupByOutputType[P]>
        }
      >
    >


  export type ModificationProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    proposedAt?: boolean
    type?: boolean
    current?: boolean
    proposed?: boolean
    rationale?: boolean
    impact?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    appliedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modificationProposal"]>

  export type ModificationProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    proposedAt?: boolean
    type?: boolean
    current?: boolean
    proposed?: boolean
    rationale?: boolean
    impact?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    appliedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modificationProposal"]>

  export type ModificationProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    proposedAt?: boolean
    type?: boolean
    current?: boolean
    proposed?: boolean
    rationale?: boolean
    impact?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    appliedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modificationProposal"]>

  export type ModificationProposalSelectScalar = {
    id?: boolean
    agentId?: boolean
    proposedAt?: boolean
    type?: boolean
    current?: boolean
    proposed?: boolean
    rationale?: boolean
    impact?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    appliedAt?: boolean
  }

  export type ModificationProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "proposedAt" | "type" | "current" | "proposed" | "rationale" | "impact" | "status" | "reviewedAt" | "reviewedBy" | "appliedAt", ExtArgs["result"]["modificationProposal"]>
  export type ModificationProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type ModificationProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type ModificationProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $ModificationProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModificationProposal"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      proposedAt: Date
      type: $Enums.ModificationType
      current: string
      proposed: string
      rationale: string
      impact: string
      status: $Enums.ProposalStatus
      reviewedAt: Date | null
      reviewedBy: string | null
      appliedAt: Date | null
    }, ExtArgs["result"]["modificationProposal"]>
    composites: {}
  }

  type ModificationProposalGetPayload<S extends boolean | null | undefined | ModificationProposalDefaultArgs> = $Result.GetResult<Prisma.$ModificationProposalPayload, S>

  type ModificationProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModificationProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModificationProposalCountAggregateInputType | true
    }

  export interface ModificationProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModificationProposal'], meta: { name: 'ModificationProposal' } }
    /**
     * Find zero or one ModificationProposal that matches the filter.
     * @param {ModificationProposalFindUniqueArgs} args - Arguments to find a ModificationProposal
     * @example
     * // Get one ModificationProposal
     * const modificationProposal = await prisma.modificationProposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModificationProposalFindUniqueArgs>(args: SelectSubset<T, ModificationProposalFindUniqueArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModificationProposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModificationProposalFindUniqueOrThrowArgs} args - Arguments to find a ModificationProposal
     * @example
     * // Get one ModificationProposal
     * const modificationProposal = await prisma.modificationProposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModificationProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ModificationProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModificationProposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalFindFirstArgs} args - Arguments to find a ModificationProposal
     * @example
     * // Get one ModificationProposal
     * const modificationProposal = await prisma.modificationProposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModificationProposalFindFirstArgs>(args?: SelectSubset<T, ModificationProposalFindFirstArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModificationProposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalFindFirstOrThrowArgs} args - Arguments to find a ModificationProposal
     * @example
     * // Get one ModificationProposal
     * const modificationProposal = await prisma.modificationProposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModificationProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ModificationProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModificationProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModificationProposals
     * const modificationProposals = await prisma.modificationProposal.findMany()
     * 
     * // Get first 10 ModificationProposals
     * const modificationProposals = await prisma.modificationProposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modificationProposalWithIdOnly = await prisma.modificationProposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModificationProposalFindManyArgs>(args?: SelectSubset<T, ModificationProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModificationProposal.
     * @param {ModificationProposalCreateArgs} args - Arguments to create a ModificationProposal.
     * @example
     * // Create one ModificationProposal
     * const ModificationProposal = await prisma.modificationProposal.create({
     *   data: {
     *     // ... data to create a ModificationProposal
     *   }
     * })
     * 
     */
    create<T extends ModificationProposalCreateArgs>(args: SelectSubset<T, ModificationProposalCreateArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModificationProposals.
     * @param {ModificationProposalCreateManyArgs} args - Arguments to create many ModificationProposals.
     * @example
     * // Create many ModificationProposals
     * const modificationProposal = await prisma.modificationProposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModificationProposalCreateManyArgs>(args?: SelectSubset<T, ModificationProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModificationProposals and returns the data saved in the database.
     * @param {ModificationProposalCreateManyAndReturnArgs} args - Arguments to create many ModificationProposals.
     * @example
     * // Create many ModificationProposals
     * const modificationProposal = await prisma.modificationProposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModificationProposals and only return the `id`
     * const modificationProposalWithIdOnly = await prisma.modificationProposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModificationProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, ModificationProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModificationProposal.
     * @param {ModificationProposalDeleteArgs} args - Arguments to delete one ModificationProposal.
     * @example
     * // Delete one ModificationProposal
     * const ModificationProposal = await prisma.modificationProposal.delete({
     *   where: {
     *     // ... filter to delete one ModificationProposal
     *   }
     * })
     * 
     */
    delete<T extends ModificationProposalDeleteArgs>(args: SelectSubset<T, ModificationProposalDeleteArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModificationProposal.
     * @param {ModificationProposalUpdateArgs} args - Arguments to update one ModificationProposal.
     * @example
     * // Update one ModificationProposal
     * const modificationProposal = await prisma.modificationProposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModificationProposalUpdateArgs>(args: SelectSubset<T, ModificationProposalUpdateArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModificationProposals.
     * @param {ModificationProposalDeleteManyArgs} args - Arguments to filter ModificationProposals to delete.
     * @example
     * // Delete a few ModificationProposals
     * const { count } = await prisma.modificationProposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModificationProposalDeleteManyArgs>(args?: SelectSubset<T, ModificationProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModificationProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModificationProposals
     * const modificationProposal = await prisma.modificationProposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModificationProposalUpdateManyArgs>(args: SelectSubset<T, ModificationProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModificationProposals and returns the data updated in the database.
     * @param {ModificationProposalUpdateManyAndReturnArgs} args - Arguments to update many ModificationProposals.
     * @example
     * // Update many ModificationProposals
     * const modificationProposal = await prisma.modificationProposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModificationProposals and only return the `id`
     * const modificationProposalWithIdOnly = await prisma.modificationProposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModificationProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, ModificationProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModificationProposal.
     * @param {ModificationProposalUpsertArgs} args - Arguments to update or create a ModificationProposal.
     * @example
     * // Update or create a ModificationProposal
     * const modificationProposal = await prisma.modificationProposal.upsert({
     *   create: {
     *     // ... data to create a ModificationProposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModificationProposal we want to update
     *   }
     * })
     */
    upsert<T extends ModificationProposalUpsertArgs>(args: SelectSubset<T, ModificationProposalUpsertArgs<ExtArgs>>): Prisma__ModificationProposalClient<$Result.GetResult<Prisma.$ModificationProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModificationProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalCountArgs} args - Arguments to filter ModificationProposals to count.
     * @example
     * // Count the number of ModificationProposals
     * const count = await prisma.modificationProposal.count({
     *   where: {
     *     // ... the filter for the ModificationProposals we want to count
     *   }
     * })
    **/
    count<T extends ModificationProposalCountArgs>(
      args?: Subset<T, ModificationProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModificationProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModificationProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModificationProposalAggregateArgs>(args: Subset<T, ModificationProposalAggregateArgs>): Prisma.PrismaPromise<GetModificationProposalAggregateType<T>>

    /**
     * Group by ModificationProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModificationProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModificationProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModificationProposalGroupByArgs['orderBy'] }
        : { orderBy?: ModificationProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModificationProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModificationProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModificationProposal model
   */
  readonly fields: ModificationProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModificationProposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModificationProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModificationProposal model
   */
  interface ModificationProposalFieldRefs {
    readonly id: FieldRef<"ModificationProposal", 'String'>
    readonly agentId: FieldRef<"ModificationProposal", 'String'>
    readonly proposedAt: FieldRef<"ModificationProposal", 'DateTime'>
    readonly type: FieldRef<"ModificationProposal", 'ModificationType'>
    readonly current: FieldRef<"ModificationProposal", 'String'>
    readonly proposed: FieldRef<"ModificationProposal", 'String'>
    readonly rationale: FieldRef<"ModificationProposal", 'String'>
    readonly impact: FieldRef<"ModificationProposal", 'String'>
    readonly status: FieldRef<"ModificationProposal", 'ProposalStatus'>
    readonly reviewedAt: FieldRef<"ModificationProposal", 'DateTime'>
    readonly reviewedBy: FieldRef<"ModificationProposal", 'String'>
    readonly appliedAt: FieldRef<"ModificationProposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModificationProposal findUnique
   */
  export type ModificationProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * Filter, which ModificationProposal to fetch.
     */
    where: ModificationProposalWhereUniqueInput
  }

  /**
   * ModificationProposal findUniqueOrThrow
   */
  export type ModificationProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * Filter, which ModificationProposal to fetch.
     */
    where: ModificationProposalWhereUniqueInput
  }

  /**
   * ModificationProposal findFirst
   */
  export type ModificationProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * Filter, which ModificationProposal to fetch.
     */
    where?: ModificationProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModificationProposals to fetch.
     */
    orderBy?: ModificationProposalOrderByWithRelationInput | ModificationProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModificationProposals.
     */
    cursor?: ModificationProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModificationProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModificationProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModificationProposals.
     */
    distinct?: ModificationProposalScalarFieldEnum | ModificationProposalScalarFieldEnum[]
  }

  /**
   * ModificationProposal findFirstOrThrow
   */
  export type ModificationProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * Filter, which ModificationProposal to fetch.
     */
    where?: ModificationProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModificationProposals to fetch.
     */
    orderBy?: ModificationProposalOrderByWithRelationInput | ModificationProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModificationProposals.
     */
    cursor?: ModificationProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModificationProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModificationProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModificationProposals.
     */
    distinct?: ModificationProposalScalarFieldEnum | ModificationProposalScalarFieldEnum[]
  }

  /**
   * ModificationProposal findMany
   */
  export type ModificationProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * Filter, which ModificationProposals to fetch.
     */
    where?: ModificationProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModificationProposals to fetch.
     */
    orderBy?: ModificationProposalOrderByWithRelationInput | ModificationProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModificationProposals.
     */
    cursor?: ModificationProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModificationProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModificationProposals.
     */
    skip?: number
    distinct?: ModificationProposalScalarFieldEnum | ModificationProposalScalarFieldEnum[]
  }

  /**
   * ModificationProposal create
   */
  export type ModificationProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a ModificationProposal.
     */
    data: XOR<ModificationProposalCreateInput, ModificationProposalUncheckedCreateInput>
  }

  /**
   * ModificationProposal createMany
   */
  export type ModificationProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModificationProposals.
     */
    data: ModificationProposalCreateManyInput | ModificationProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModificationProposal createManyAndReturn
   */
  export type ModificationProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * The data used to create many ModificationProposals.
     */
    data: ModificationProposalCreateManyInput | ModificationProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModificationProposal update
   */
  export type ModificationProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a ModificationProposal.
     */
    data: XOR<ModificationProposalUpdateInput, ModificationProposalUncheckedUpdateInput>
    /**
     * Choose, which ModificationProposal to update.
     */
    where: ModificationProposalWhereUniqueInput
  }

  /**
   * ModificationProposal updateMany
   */
  export type ModificationProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModificationProposals.
     */
    data: XOR<ModificationProposalUpdateManyMutationInput, ModificationProposalUncheckedUpdateManyInput>
    /**
     * Filter which ModificationProposals to update
     */
    where?: ModificationProposalWhereInput
    /**
     * Limit how many ModificationProposals to update.
     */
    limit?: number
  }

  /**
   * ModificationProposal updateManyAndReturn
   */
  export type ModificationProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * The data used to update ModificationProposals.
     */
    data: XOR<ModificationProposalUpdateManyMutationInput, ModificationProposalUncheckedUpdateManyInput>
    /**
     * Filter which ModificationProposals to update
     */
    where?: ModificationProposalWhereInput
    /**
     * Limit how many ModificationProposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModificationProposal upsert
   */
  export type ModificationProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the ModificationProposal to update in case it exists.
     */
    where: ModificationProposalWhereUniqueInput
    /**
     * In case the ModificationProposal found by the `where` argument doesn't exist, create a new ModificationProposal with this data.
     */
    create: XOR<ModificationProposalCreateInput, ModificationProposalUncheckedCreateInput>
    /**
     * In case the ModificationProposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModificationProposalUpdateInput, ModificationProposalUncheckedUpdateInput>
  }

  /**
   * ModificationProposal delete
   */
  export type ModificationProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
    /**
     * Filter which ModificationProposal to delete.
     */
    where: ModificationProposalWhereUniqueInput
  }

  /**
   * ModificationProposal deleteMany
   */
  export type ModificationProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModificationProposals to delete
     */
    where?: ModificationProposalWhereInput
    /**
     * Limit how many ModificationProposals to delete.
     */
    limit?: number
  }

  /**
   * ModificationProposal without action
   */
  export type ModificationProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModificationProposal
     */
    select?: ModificationProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModificationProposal
     */
    omit?: ModificationProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModificationProposalInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const NodeScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    name: 'name',
    type: 'type',
    position: 'position',
    data: 'data',
    credentialId: 'credentialId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NodeScalarFieldEnum = (typeof NodeScalarFieldEnum)[keyof typeof NodeScalarFieldEnum]


  export const ConnectionScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    fromNodeId: 'fromNodeId',
    toNodeId: 'toNodeId',
    fromOutput: 'fromOutput',
    toInput: 'toInput',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConnectionScalarFieldEnum = (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum]


  export const ExecutionScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    status: 'status',
    error: 'error',
    errorStack: 'errorStack',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    inngestEventId: 'inngestEventId',
    output: 'output'
  };

  export type ExecutionScalarFieldEnum = (typeof ExecutionScalarFieldEnum)[keyof typeof ExecutionScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    systemPrompt: 'systemPrompt',
    context: 'context',
    model: 'model',
    temperature: 'temperature',
    safeMode: 'safeMode',
    llmTier: 'llmTier',
    maxStepsPerRun: 'maxStepsPerRun',
    evalRules: 'evalRules',
    workspaceId: 'workspaceId',
    avatar: 'avatar',
    tags: 'tags',
    isFavorite: 'isFavorite',
    isEnabled: 'isEnabled',
    templateId: 'templateId',
    flowData: 'flowData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    credentialId: 'credentialId'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const AgentConnectionScalarFieldEnum: {
    id: 'id',
    sourceAgentId: 'sourceAgentId',
    targetAgentId: 'targetAgentId',
    alias: 'alias',
    description: 'description',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentConnectionScalarFieldEnum = (typeof AgentConnectionScalarFieldEnum)[keyof typeof AgentConnectionScalarFieldEnum]


  export const AgentToolScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    workflowId: 'workflowId',
    composioAppKey: 'composioAppKey',
    composioActionName: 'composioActionName',
    composioConfig: 'composioConfig',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentToolScalarFieldEnum = (typeof AgentToolScalarFieldEnum)[keyof typeof AgentToolScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    agentId: 'agentId',
    isArchived: 'isArchived',
    isPinned: 'isPinned',
    shareToken: 'shareToken',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    toolName: 'toolName',
    toolInput: 'toolInput',
    toolOutput: 'toolOutput',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ConversationActivityScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    type: 'type',
    title: 'title',
    details: 'details',
    requiresConfirmation: 'requiresConfirmation',
    confirmedAt: 'confirmedAt',
    rejectedAt: 'rejectedAt',
    createdAt: 'createdAt'
  };

  export type ConversationActivityScalarFieldEnum = (typeof ConversationActivityScalarFieldEnum)[keyof typeof ConversationActivityScalarFieldEnum]


  export const AgentMemoryScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    key: 'key',
    value: 'value',
    category: 'category',
    embedding: 'embedding',
    source: 'source',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentMemoryScalarFieldEnum = (typeof AgentMemoryScalarFieldEnum)[keyof typeof AgentMemoryScalarFieldEnum]


  export const KnowledgeDocumentScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    title: 'title',
    content: 'content',
    source: 'source',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    sourceType: 'sourceType',
    externalId: 'externalId',
    externalUrl: 'externalUrl',
    syncStatus: 'syncStatus',
    lastSyncedAt: 'lastSyncedAt',
    syncError: 'syncError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeDocumentScalarFieldEnum = (typeof KnowledgeDocumentScalarFieldEnum)[keyof typeof KnowledgeDocumentScalarFieldEnum]


  export const KnowledgeChunkScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    content: 'content',
    embedding: 'embedding',
    position: 'position',
    pageNumber: 'pageNumber',
    heading: 'heading',
    createdAt: 'createdAt'
  };

  export type KnowledgeChunkScalarFieldEnum = (typeof KnowledgeChunkScalarFieldEnum)[keyof typeof KnowledgeChunkScalarFieldEnum]


  export const KnowledgeSettingsScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    searchFuzziness: 'searchFuzziness',
    maxResults: 'maxResults',
    autoRefresh: 'autoRefresh',
    refreshInterval: 'refreshInterval',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeSettingsScalarFieldEnum = (typeof KnowledgeSettingsScalarFieldEnum)[keyof typeof KnowledgeSettingsScalarFieldEnum]


  export const AgentTriggerScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    name: 'name',
    type: 'type',
    enabled: 'enabled',
    config: 'config',
    cronExpression: 'cronExpression',
    nextRunAt: 'nextRunAt',
    lastRunAt: 'lastRunAt',
    webhookSecret: 'webhookSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentTriggerScalarFieldEnum = (typeof AgentTriggerScalarFieldEnum)[keyof typeof AgentTriggerScalarFieldEnum]


  export const AgentTemplateScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    subtitle: 'subtitle',
    description: 'description',
    category: 'category',
    role: 'role',
    useCase: 'useCase',
    systemPrompt: 'systemPrompt',
    context: 'context',
    model: 'model',
    temperature: 'temperature',
    trigger: 'trigger',
    llmTier: 'llmTier',
    maxStepsPerRun: 'maxStepsPerRun',
    fetchSources: 'fetchSources',
    actions: 'actions',
    evalRules: 'evalRules',
    suggestedTools: 'suggestedTools',
    suggestedTriggers: 'suggestedTriggers',
    suggestedIntegrations: 'suggestedIntegrations',
    flowData: 'flowData',
    defaultTriggers: 'defaultTriggers',
    defaultTools: 'defaultTools',
    icon: 'icon',
    color: 'color',
    coverImage: 'coverImage',
    isPublic: 'isPublic',
    isFeatured: 'isFeatured',
    createdById: 'createdById',
    createdByName: 'createdByName',
    usageCount: 'usageCount',
    rating: 'rating',
    reviewCount: 'reviewCount',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentTemplateScalarFieldEnum = (typeof AgentTemplateScalarFieldEnum)[keyof typeof AgentTemplateScalarFieldEnum]


  export const AgentEmbedScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    enabled: 'enabled',
    allowedDomains: 'allowedDomains',
    displayName: 'displayName',
    welcomeMessage: 'welcomeMessage',
    logo: 'logo',
    accentColor: 'accentColor',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    userBubbleColor: 'userBubbleColor',
    botBubbleColor: 'botBubbleColor',
    position: 'position',
    buttonSize: 'buttonSize',
    windowWidth: 'windowWidth',
    windowHeight: 'windowHeight',
    autoOpen: 'autoOpen',
    autoOpenDelay: 'autoOpenDelay',
    showBranding: 'showBranding',
    collectEmail: 'collectEmail',
    requireEmail: 'requireEmail',
    conversationStarters: 'conversationStarters',
    customCss: 'customCss',
    totalConversations: 'totalConversations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentEmbedScalarFieldEnum = (typeof AgentEmbedScalarFieldEnum)[keyof typeof AgentEmbedScalarFieldEnum]


  export const AgentEmailAddressScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    localPart: 'localPart',
    domain: 'domain',
    autoReply: 'autoReply',
    createdAt: 'createdAt'
  };

  export type AgentEmailAddressScalarFieldEnum = (typeof AgentEmailAddressScalarFieldEnum)[keyof typeof AgentEmailAddressScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    accountEmail: 'accountEmail',
    accountName: 'accountName',
    scopes: 'scopes',
    teamId: 'teamId',
    teamName: 'teamName',
    botUserId: 'botUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const AgentSwarmScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    name: 'name',
    taskTemplate: 'taskTemplate',
    status: 'status',
    totalTasks: 'totalTasks',
    completedTasks: 'completedTasks',
    failedTasks: 'failedTasks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentSwarmScalarFieldEnum = (typeof AgentSwarmScalarFieldEnum)[keyof typeof AgentSwarmScalarFieldEnum]


  export const SwarmTaskScalarFieldEnum: {
    id: 'id',
    swarmId: 'swarmId',
    input: 'input',
    status: 'status',
    output: 'output',
    error: 'error',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type SwarmTaskScalarFieldEnum = (typeof SwarmTaskScalarFieldEnum)[keyof typeof SwarmTaskScalarFieldEnum]


  export const MeetingRecordingScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    title: 'title',
    meetingUrl: 'meetingUrl',
    meetingPlatform: 'meetingPlatform',
    calendarEventId: 'calendarEventId',
    status: 'status',
    recordingUrl: 'recordingUrl',
    transcript: 'transcript',
    summary: 'summary',
    actionItems: 'actionItems',
    participants: 'participants',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingRecordingScalarFieldEnum = (typeof MeetingRecordingScalarFieldEnum)[keyof typeof MeetingRecordingScalarFieldEnum]


  export const AgentPhoneNumberScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    phoneNumber: 'phoneNumber',
    twilioSid: 'twilioSid',
    voiceEnabled: 'voiceEnabled',
    voiceGreeting: 'voiceGreeting',
    createdAt: 'createdAt'
  };

  export type AgentPhoneNumberScalarFieldEnum = (typeof AgentPhoneNumberScalarFieldEnum)[keyof typeof AgentPhoneNumberScalarFieldEnum]


  export const PhoneCallScalarFieldEnum: {
    id: 'id',
    phoneNumberId: 'phoneNumberId',
    direction: 'direction',
    fromNumber: 'fromNumber',
    toNumber: 'toNumber',
    status: 'status',
    twilioCallSid: 'twilioCallSid',
    recordingUrl: 'recordingUrl',
    transcript: 'transcript',
    conversationId: 'conversationId',
    duration: 'duration',
    startedAt: 'startedAt',
    endedAt: 'endedAt'
  };

  export type PhoneCallScalarFieldEnum = (typeof PhoneCallScalarFieldEnum)[keyof typeof PhoneCallScalarFieldEnum]


  export const AgentMetricScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    date: 'date',
    totalConversations: 'totalConversations',
    totalMessages: 'totalMessages',
    avgMessagesPerConvo: 'avgMessagesPerConvo',
    avgResponseTimeMs: 'avgResponseTimeMs',
    totalTokensUsed: 'totalTokensUsed',
    toolCallsCount: 'toolCallsCount',
    toolSuccessRate: 'toolSuccessRate',
    feedbackPositive: 'feedbackPositive',
    feedbackNegative: 'feedbackNegative',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentMetricScalarFieldEnum = (typeof AgentMetricScalarFieldEnum)[keyof typeof AgentMetricScalarFieldEnum]


  export const ScanResultScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    category: 'category',
    signals: 'signals',
    totalSignals: 'totalSignals',
    criticalCount: 'criticalCount',
    highCount: 'highCount',
    mediumCount: 'mediumCount',
    lowCount: 'lowCount',
    scannedAt: 'scannedAt'
  };

  export type ScanResultScalarFieldEnum = (typeof ScanResultScalarFieldEnum)[keyof typeof ScanResultScalarFieldEnum]


  export const SignalScalarFieldEnum: {
    id: 'id',
    scanResultId: 'scanResultId',
    type: 'type',
    category: 'category',
    severity: 'severity',
    source: 'source',
    title: 'title',
    description: 'description',
    metadata: 'metadata',
    suggestedTemplateId: 'suggestedTemplateId',
    snoozedUntil: 'snoozedUntil',
    dismissedAt: 'dismissedAt',
    actedOnAt: 'actedOnAt',
    detectedAt: 'detectedAt'
  };

  export type SignalScalarFieldEnum = (typeof SignalScalarFieldEnum)[keyof typeof SignalScalarFieldEnum]


  export const AgentRunScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    userId: 'userId',
    workspaceId: 'workspaceId',
    triggeredAt: 'triggeredAt',
    triggeredBy: 'triggeredBy',
    dataSources: 'dataSources',
    outputType: 'outputType',
    outputContent: 'outputContent',
    llmModel: 'llmModel',
    llmTokensUsed: 'llmTokensUsed',
    llmCost: 'llmCost',
    l1Assertions: 'l1Assertions',
    l1Passed: 'l1Passed',
    l2Score: 'l2Score',
    l2Breakdown: 'l2Breakdown',
    l3Triggered: 'l3Triggered',
    l3Blocked: 'l3Blocked',
    l3Reason: 'l3Reason',
    userAction: 'userAction',
    draftDiff: 'draftDiff',
    finalAction: 'finalAction',
    finalAt: 'finalAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentRunScalarFieldEnum = (typeof AgentRunScalarFieldEnum)[keyof typeof AgentRunScalarFieldEnum]


  export const AiEventScalarFieldEnum: {
    id: 'id',
    traceId: 'traceId',
    agentId: 'agentId',
    conversationId: 'conversationId',
    userId: 'userId',
    workspaceId: 'workspaceId',
    model: 'model',
    tier: 'tier',
    tokensIn: 'tokensIn',
    tokensOut: 'tokensOut',
    cost: 'cost',
    latencyMs: 'latencyMs',
    stepNumber: 'stepNumber',
    action: 'action',
    toolName: 'toolName',
    toolInput: 'toolInput',
    toolOutput: 'toolOutput',
    stepsUsed: 'stepsUsed',
    evalResult: 'evalResult',
    timestamp: 'timestamp'
  };

  export type AiEventScalarFieldEnum = (typeof AiEventScalarFieldEnum)[keyof typeof AiEventScalarFieldEnum]


  export const AgentTraceScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    conversationId: 'conversationId',
    userId: 'userId',
    workspaceId: 'workspaceId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    status: 'status',
    steps: 'steps',
    totalSteps: 'totalSteps',
    maxSteps: 'maxSteps',
    totalTokensIn: 'totalTokensIn',
    totalTokensOut: 'totalTokensOut',
    totalCost: 'totalCost',
    latencyMs: 'latencyMs',
    toolCalls: 'toolCalls',
    toolSuccesses: 'toolSuccesses',
    toolFailures: 'toolFailures',
    l1Passed: 'l1Passed',
    l1Failures: 'l1Failures',
    l2Score: 'l2Score',
    l2Breakdown: 'l2Breakdown',
    l3Triggered: 'l3Triggered',
    l3Blocked: 'l3Blocked',
    feedbackScore: 'feedbackScore',
    feedbackComment: 'feedbackComment',
    userEdited: 'userEdited',
    editDiff: 'editDiff'
  };

  export type AgentTraceScalarFieldEnum = (typeof AgentTraceScalarFieldEnum)[keyof typeof AgentTraceScalarFieldEnum]


  export const ConversationEvaluationScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    evaluatedAt: 'evaluatedAt',
    goalCompleted: 'goalCompleted',
    goalCompletionConfidence: 'goalCompletionConfidence',
    userSatisfactionScore: 'userSatisfactionScore',
    categories: 'categories',
    failureModes: 'failureModes',
    improvementSuggestions: 'improvementSuggestions',
    metadata: 'metadata'
  };

  export type ConversationEvaluationScalarFieldEnum = (typeof ConversationEvaluationScalarFieldEnum)[keyof typeof ConversationEvaluationScalarFieldEnum]


  export const AgentInsightScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    generatedAt: 'generatedAt',
    timeframeStart: 'timeframeStart',
    timeframeEnd: 'timeframeEnd',
    clusters: 'clusters',
    patterns: 'patterns',
    anomalies: 'anomalies',
    opportunities: 'opportunities'
  };

  export type AgentInsightScalarFieldEnum = (typeof AgentInsightScalarFieldEnum)[keyof typeof AgentInsightScalarFieldEnum]


  export const AgentFeedbackScalarFieldEnum: {
    id: 'id',
    traceId: 'traceId',
    conversationId: 'conversationId',
    userId: 'userId',
    agentId: 'agentId',
    type: 'type',
    timestamp: 'timestamp',
    originalOutput: 'originalOutput',
    userEdit: 'userEdit',
    correctionText: 'correctionText',
    stepNumber: 'stepNumber',
    metadata: 'metadata'
  };

  export type AgentFeedbackScalarFieldEnum = (typeof AgentFeedbackScalarFieldEnum)[keyof typeof AgentFeedbackScalarFieldEnum]


  export const AgentABTestScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    variantAPrompt: 'variantAPrompt',
    variantBPrompt: 'variantBPrompt',
    trafficSplit: 'trafficSplit',
    status: 'status',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    variantATraces: 'variantATraces',
    variantBTraces: 'variantBTraces',
    variantAScore: 'variantAScore',
    variantBScore: 'variantBScore',
    winningVariant: 'winningVariant'
  };

  export type AgentABTestScalarFieldEnum = (typeof AgentABTestScalarFieldEnum)[keyof typeof AgentABTestScalarFieldEnum]


  export const OptimizationRunScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    triggeredAt: 'triggeredAt',
    triggeredBy: 'triggeredBy',
    editPatterns: 'editPatterns',
    promptVariations: 'promptVariations',
    testResults: 'testResults',
    recommendation: 'recommendation',
    abTestId: 'abTestId',
    status: 'status'
  };

  export type OptimizationRunScalarFieldEnum = (typeof OptimizationRunScalarFieldEnum)[keyof typeof OptimizationRunScalarFieldEnum]


  export const ModificationProposalScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    proposedAt: 'proposedAt',
    type: 'type',
    current: 'current',
    proposed: 'proposed',
    rationale: 'rationale',
    impact: 'impact',
    status: 'status',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    appliedAt: 'appliedAt'
  };

  export type ModificationProposalScalarFieldEnum = (typeof ModificationProposalScalarFieldEnum)[keyof typeof ModificationProposalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CredentialType'
   */
  export type EnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType'>
    


  /**
   * Reference to a field of type 'CredentialType[]'
   */
  export type ListEnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType[]'>
    


  /**
   * Reference to a field of type 'NodeType'
   */
  export type EnumNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeType'>
    


  /**
   * Reference to a field of type 'NodeType[]'
   */
  export type ListEnumNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ExecutionStatus'
   */
  export type EnumExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExecutionStatus'>
    


  /**
   * Reference to a field of type 'ExecutionStatus[]'
   */
  export type ListEnumExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExecutionStatus[]'>
    


  /**
   * Reference to a field of type 'AgentModel'
   */
  export type EnumAgentModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentModel'>
    


  /**
   * Reference to a field of type 'AgentModel[]'
   */
  export type ListEnumAgentModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentModel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ConversationSource'
   */
  export type EnumConversationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationSource'>
    


  /**
   * Reference to a field of type 'ConversationSource[]'
   */
  export type ListEnumConversationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationSource[]'>
    


  /**
   * Reference to a field of type 'MessageRole'
   */
  export type EnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole'>
    


  /**
   * Reference to a field of type 'MessageRole[]'
   */
  export type ListEnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'MemoryCategory'
   */
  export type EnumMemoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemoryCategory'>
    


  /**
   * Reference to a field of type 'MemoryCategory[]'
   */
  export type ListEnumMemoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemoryCategory[]'>
    


  /**
   * Reference to a field of type 'KnowledgeSourceType'
   */
  export type EnumKnowledgeSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeSourceType'>
    


  /**
   * Reference to a field of type 'KnowledgeSourceType[]'
   */
  export type ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeSourceType[]'>
    


  /**
   * Reference to a field of type 'KnowledgeSyncStatus'
   */
  export type EnumKnowledgeSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeSyncStatus'>
    


  /**
   * Reference to a field of type 'KnowledgeSyncStatus[]'
   */
  export type ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeSyncStatus[]'>
    


  /**
   * Reference to a field of type 'TriggerType'
   */
  export type EnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType'>
    


  /**
   * Reference to a field of type 'TriggerType[]'
   */
  export type ListEnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType[]'>
    


  /**
   * Reference to a field of type 'TemplateCategory'
   */
  export type EnumTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateCategory'>
    


  /**
   * Reference to a field of type 'TemplateCategory[]'
   */
  export type ListEnumTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateCategory[]'>
    


  /**
   * Reference to a field of type 'TemplateRole'
   */
  export type EnumTemplateRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateRole'>
    


  /**
   * Reference to a field of type 'TemplateRole[]'
   */
  export type ListEnumTemplateRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateRole[]'>
    


  /**
   * Reference to a field of type 'TemplateUseCase'
   */
  export type EnumTemplateUseCaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateUseCase'>
    


  /**
   * Reference to a field of type 'TemplateUseCase[]'
   */
  export type ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateUseCase[]'>
    


  /**
   * Reference to a field of type 'EmbedPosition'
   */
  export type EnumEmbedPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmbedPosition'>
    


  /**
   * Reference to a field of type 'EmbedPosition[]'
   */
  export type ListEnumEmbedPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmbedPosition[]'>
    


  /**
   * Reference to a field of type 'IntegrationType'
   */
  export type EnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType'>
    


  /**
   * Reference to a field of type 'IntegrationType[]'
   */
  export type ListEnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType[]'>
    


  /**
   * Reference to a field of type 'SwarmStatus'
   */
  export type EnumSwarmStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SwarmStatus'>
    


  /**
   * Reference to a field of type 'SwarmStatus[]'
   */
  export type ListEnumSwarmStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SwarmStatus[]'>
    


  /**
   * Reference to a field of type 'SwarmTaskStatus'
   */
  export type EnumSwarmTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SwarmTaskStatus'>
    


  /**
   * Reference to a field of type 'SwarmTaskStatus[]'
   */
  export type ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SwarmTaskStatus[]'>
    


  /**
   * Reference to a field of type 'MeetingPlatform'
   */
  export type EnumMeetingPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingPlatform'>
    


  /**
   * Reference to a field of type 'MeetingPlatform[]'
   */
  export type ListEnumMeetingPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingPlatform[]'>
    


  /**
   * Reference to a field of type 'RecordingStatus'
   */
  export type EnumRecordingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingStatus'>
    


  /**
   * Reference to a field of type 'RecordingStatus[]'
   */
  export type ListEnumRecordingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingStatus[]'>
    


  /**
   * Reference to a field of type 'CallDirection'
   */
  export type EnumCallDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallDirection'>
    


  /**
   * Reference to a field of type 'CallDirection[]'
   */
  export type ListEnumCallDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallDirection[]'>
    


  /**
   * Reference to a field of type 'CallStatus'
   */
  export type EnumCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallStatus'>
    


  /**
   * Reference to a field of type 'CallStatus[]'
   */
  export type ListEnumCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallStatus[]'>
    


  /**
   * Reference to a field of type 'ScanCategory'
   */
  export type EnumScanCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScanCategory'>
    


  /**
   * Reference to a field of type 'ScanCategory[]'
   */
  export type ListEnumScanCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScanCategory[]'>
    


  /**
   * Reference to a field of type 'SignalSeverity'
   */
  export type EnumSignalSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignalSeverity'>
    


  /**
   * Reference to a field of type 'SignalSeverity[]'
   */
  export type ListEnumSignalSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignalSeverity[]'>
    


  /**
   * Reference to a field of type 'TraceStatus'
   */
  export type EnumTraceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TraceStatus'>
    


  /**
   * Reference to a field of type 'TraceStatus[]'
   */
  export type ListEnumTraceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TraceStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'ABTestStatus'
   */
  export type EnumABTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ABTestStatus'>
    


  /**
   * Reference to a field of type 'ABTestStatus[]'
   */
  export type ListEnumABTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ABTestStatus[]'>
    


  /**
   * Reference to a field of type 'ModificationType'
   */
  export type EnumModificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModificationType'>
    


  /**
   * Reference to a field of type 'ModificationType[]'
   */
  export type ListEnumModificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModificationType[]'>
    


  /**
   * Reference to a field of type 'ProposalStatus'
   */
  export type EnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus'>
    


  /**
   * Reference to a field of type 'ProposalStatus[]'
   */
  export type ListEnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    workflows?: WorkflowListRelationFilter
    credentials?: CredentialListRelationFilter
    agents?: AgentListRelationFilter
    integrations?: IntegrationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    credentials?: CredentialOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    workflows?: WorkflowListRelationFilter
    credentials?: CredentialListRelationFilter
    agents?: AgentListRelationFilter
    integrations?: IntegrationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type CredentialWhereInput = {
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    id?: StringFilter<"Credential"> | string
    name?: StringFilter<"Credential"> | string
    value?: StringFilter<"Credential"> | string
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    userId?: StringFilter<"Credential"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Node?: NodeListRelationFilter
    agents?: AgentListRelationFilter
  }

  export type CredentialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    Node?: NodeOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
  }

  export type CredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    name?: StringFilter<"Credential"> | string
    value?: StringFilter<"Credential"> | string
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    userId?: StringFilter<"Credential"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Node?: NodeListRelationFilter
    agents?: AgentListRelationFilter
  }, "id">

  export type CredentialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: CredentialCountOrderByAggregateInput
    _max?: CredentialMaxOrderByAggregateInput
    _min?: CredentialMinOrderByAggregateInput
  }

  export type CredentialScalarWhereWithAggregatesInput = {
    AND?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    OR?: CredentialScalarWhereWithAggregatesInput[]
    NOT?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credential"> | string
    name?: StringWithAggregatesFilter<"Credential"> | string
    value?: StringWithAggregatesFilter<"Credential"> | string
    type?: EnumCredentialTypeWithAggregatesFilter<"Credential"> | $Enums.CredentialType
    createdAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    userId?: StringWithAggregatesFilter<"Credential"> | string
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    userId?: StringFilter<"Workflow"> | string
    nodes?: NodeListRelationFilter
    connections?: ConnectionListRelationFilter
    executions?: ExecutionListRelationFilter
    agentTools?: AgentToolListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    nodes?: NodeOrderByRelationAggregateInput
    connections?: ConnectionOrderByRelationAggregateInput
    executions?: ExecutionOrderByRelationAggregateInput
    agentTools?: AgentToolOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    name?: StringFilter<"Workflow"> | string
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    userId?: StringFilter<"Workflow"> | string
    nodes?: NodeListRelationFilter
    connections?: ConnectionListRelationFilter
    executions?: ExecutionListRelationFilter
    agentTools?: AgentToolListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    name?: StringWithAggregatesFilter<"Workflow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    userId?: StringWithAggregatesFilter<"Workflow"> | string
  }

  export type NodeWhereInput = {
    AND?: NodeWhereInput | NodeWhereInput[]
    OR?: NodeWhereInput[]
    NOT?: NodeWhereInput | NodeWhereInput[]
    id?: StringFilter<"Node"> | string
    workflowId?: StringFilter<"Node"> | string
    name?: StringFilter<"Node"> | string
    type?: EnumNodeTypeFilter<"Node"> | $Enums.NodeType
    position?: JsonFilter<"Node">
    data?: JsonFilter<"Node">
    credentialId?: StringNullableFilter<"Node"> | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    outputConnections?: ConnectionListRelationFilter
    inputConnections?: ConnectionListRelationFilter
  }

  export type NodeOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    data?: SortOrder
    credentialId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    credential?: CredentialOrderByWithRelationInput
    outputConnections?: ConnectionOrderByRelationAggregateInput
    inputConnections?: ConnectionOrderByRelationAggregateInput
  }

  export type NodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NodeWhereInput | NodeWhereInput[]
    OR?: NodeWhereInput[]
    NOT?: NodeWhereInput | NodeWhereInput[]
    workflowId?: StringFilter<"Node"> | string
    name?: StringFilter<"Node"> | string
    type?: EnumNodeTypeFilter<"Node"> | $Enums.NodeType
    position?: JsonFilter<"Node">
    data?: JsonFilter<"Node">
    credentialId?: StringNullableFilter<"Node"> | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    outputConnections?: ConnectionListRelationFilter
    inputConnections?: ConnectionListRelationFilter
  }, "id">

  export type NodeOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    data?: SortOrder
    credentialId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NodeCountOrderByAggregateInput
    _max?: NodeMaxOrderByAggregateInput
    _min?: NodeMinOrderByAggregateInput
  }

  export type NodeScalarWhereWithAggregatesInput = {
    AND?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]
    OR?: NodeScalarWhereWithAggregatesInput[]
    NOT?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Node"> | string
    workflowId?: StringWithAggregatesFilter<"Node"> | string
    name?: StringWithAggregatesFilter<"Node"> | string
    type?: EnumNodeTypeWithAggregatesFilter<"Node"> | $Enums.NodeType
    position?: JsonWithAggregatesFilter<"Node">
    data?: JsonWithAggregatesFilter<"Node">
    credentialId?: StringNullableWithAggregatesFilter<"Node"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Node"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Node"> | Date | string
  }

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    id?: StringFilter<"Connection"> | string
    workflowId?: StringFilter<"Connection"> | string
    fromNodeId?: StringFilter<"Connection"> | string
    toNodeId?: StringFilter<"Connection"> | string
    fromOutput?: StringFilter<"Connection"> | string
    toInput?: StringFilter<"Connection"> | string
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    updatedAt?: DateTimeFilter<"Connection"> | Date | string
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    fromNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    toNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
  }

  export type ConnectionOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    fromOutput?: SortOrder
    toInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    fromNode?: NodeOrderByWithRelationInput
    toNode?: NodeOrderByWithRelationInput
  }

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromNodeId_toNodeId_fromOutput_toInput?: ConnectionFromNodeIdToNodeIdFromOutputToInputCompoundUniqueInput
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    workflowId?: StringFilter<"Connection"> | string
    fromNodeId?: StringFilter<"Connection"> | string
    toNodeId?: StringFilter<"Connection"> | string
    fromOutput?: StringFilter<"Connection"> | string
    toInput?: StringFilter<"Connection"> | string
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    updatedAt?: DateTimeFilter<"Connection"> | Date | string
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    fromNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    toNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
  }, "id" | "fromNodeId_toNodeId_fromOutput_toInput">

  export type ConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    fromOutput?: SortOrder
    toInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConnectionCountOrderByAggregateInput
    _max?: ConnectionMaxOrderByAggregateInput
    _min?: ConnectionMinOrderByAggregateInput
  }

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    OR?: ConnectionScalarWhereWithAggregatesInput[]
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Connection"> | string
    workflowId?: StringWithAggregatesFilter<"Connection"> | string
    fromNodeId?: StringWithAggregatesFilter<"Connection"> | string
    toNodeId?: StringWithAggregatesFilter<"Connection"> | string
    fromOutput?: StringWithAggregatesFilter<"Connection"> | string
    toInput?: StringWithAggregatesFilter<"Connection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Connection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Connection"> | Date | string
  }

  export type ExecutionWhereInput = {
    AND?: ExecutionWhereInput | ExecutionWhereInput[]
    OR?: ExecutionWhereInput[]
    NOT?: ExecutionWhereInput | ExecutionWhereInput[]
    id?: StringFilter<"Execution"> | string
    workflowId?: StringFilter<"Execution"> | string
    status?: EnumExecutionStatusFilter<"Execution"> | $Enums.ExecutionStatus
    error?: StringNullableFilter<"Execution"> | string | null
    errorStack?: StringNullableFilter<"Execution"> | string | null
    startedAt?: DateTimeFilter<"Execution"> | Date | string
    completedAt?: DateTimeNullableFilter<"Execution"> | Date | string | null
    inngestEventId?: StringFilter<"Execution"> | string
    output?: JsonNullableFilter<"Execution">
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
  }

  export type ExecutionOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    inngestEventId?: SortOrder
    output?: SortOrderInput | SortOrder
    workflow?: WorkflowOrderByWithRelationInput
  }

  export type ExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inngestEventId?: string
    AND?: ExecutionWhereInput | ExecutionWhereInput[]
    OR?: ExecutionWhereInput[]
    NOT?: ExecutionWhereInput | ExecutionWhereInput[]
    workflowId?: StringFilter<"Execution"> | string
    status?: EnumExecutionStatusFilter<"Execution"> | $Enums.ExecutionStatus
    error?: StringNullableFilter<"Execution"> | string | null
    errorStack?: StringNullableFilter<"Execution"> | string | null
    startedAt?: DateTimeFilter<"Execution"> | Date | string
    completedAt?: DateTimeNullableFilter<"Execution"> | Date | string | null
    output?: JsonNullableFilter<"Execution">
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
  }, "id" | "inngestEventId">

  export type ExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    inngestEventId?: SortOrder
    output?: SortOrderInput | SortOrder
    _count?: ExecutionCountOrderByAggregateInput
    _max?: ExecutionMaxOrderByAggregateInput
    _min?: ExecutionMinOrderByAggregateInput
  }

  export type ExecutionScalarWhereWithAggregatesInput = {
    AND?: ExecutionScalarWhereWithAggregatesInput | ExecutionScalarWhereWithAggregatesInput[]
    OR?: ExecutionScalarWhereWithAggregatesInput[]
    NOT?: ExecutionScalarWhereWithAggregatesInput | ExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Execution"> | string
    workflowId?: StringWithAggregatesFilter<"Execution"> | string
    status?: EnumExecutionStatusWithAggregatesFilter<"Execution"> | $Enums.ExecutionStatus
    error?: StringNullableWithAggregatesFilter<"Execution"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"Execution"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"Execution"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Execution"> | Date | string | null
    inngestEventId?: StringWithAggregatesFilter<"Execution"> | string
    output?: JsonNullableWithAggregatesFilter<"Execution">
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    systemPrompt?: StringFilter<"Agent"> | string
    context?: StringNullableFilter<"Agent"> | string | null
    model?: EnumAgentModelFilter<"Agent"> | $Enums.AgentModel
    temperature?: FloatFilter<"Agent"> | number
    safeMode?: BoolFilter<"Agent"> | boolean
    llmTier?: StringNullableFilter<"Agent"> | string | null
    maxStepsPerRun?: IntNullableFilter<"Agent"> | number | null
    evalRules?: JsonNullableFilter<"Agent">
    workspaceId?: StringNullableFilter<"Agent"> | string | null
    avatar?: StringNullableFilter<"Agent"> | string | null
    tags?: StringNullableListFilter<"Agent">
    isFavorite?: BoolFilter<"Agent"> | boolean
    isEnabled?: BoolFilter<"Agent"> | boolean
    templateId?: StringNullableFilter<"Agent"> | string | null
    flowData?: JsonNullableFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    userId?: StringFilter<"Agent"> | string
    credentialId?: StringNullableFilter<"Agent"> | string | null
    template?: XOR<AgentTemplateNullableScalarRelationFilter, AgentTemplateWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    conversations?: ConversationListRelationFilter
    agentTools?: AgentToolListRelationFilter
    memories?: AgentMemoryListRelationFilter
    knowledgeDocuments?: KnowledgeDocumentListRelationFilter
    knowledgeSettings?: XOR<KnowledgeSettingsNullableScalarRelationFilter, KnowledgeSettingsWhereInput> | null
    triggers?: AgentTriggerListRelationFilter
    embed?: XOR<AgentEmbedNullableScalarRelationFilter, AgentEmbedWhereInput> | null
    connectedTo?: AgentConnectionListRelationFilter
    connectedFrom?: AgentConnectionListRelationFilter
    swarms?: AgentSwarmListRelationFilter
    emailAddress?: XOR<AgentEmailAddressNullableScalarRelationFilter, AgentEmailAddressWhereInput> | null
    meetingRecordings?: MeetingRecordingListRelationFilter
    phoneNumber?: XOR<AgentPhoneNumberNullableScalarRelationFilter, AgentPhoneNumberWhereInput> | null
    metrics?: AgentMetricListRelationFilter
    traces?: AgentTraceListRelationFilter
    insights?: AgentInsightListRelationFilter
    feedbacks?: AgentFeedbackListRelationFilter
    abTests?: AgentABTestListRelationFilter
    optimizationRuns?: OptimizationRunListRelationFilter
    modificationProposals?: ModificationProposalListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    systemPrompt?: SortOrder
    context?: SortOrderInput | SortOrder
    model?: SortOrder
    temperature?: SortOrder
    safeMode?: SortOrder
    llmTier?: SortOrderInput | SortOrder
    maxStepsPerRun?: SortOrderInput | SortOrder
    evalRules?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    tags?: SortOrder
    isFavorite?: SortOrder
    isEnabled?: SortOrder
    templateId?: SortOrderInput | SortOrder
    flowData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrderInput | SortOrder
    template?: AgentTemplateOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    credential?: CredentialOrderByWithRelationInput
    conversations?: ConversationOrderByRelationAggregateInput
    agentTools?: AgentToolOrderByRelationAggregateInput
    memories?: AgentMemoryOrderByRelationAggregateInput
    knowledgeDocuments?: KnowledgeDocumentOrderByRelationAggregateInput
    knowledgeSettings?: KnowledgeSettingsOrderByWithRelationInput
    triggers?: AgentTriggerOrderByRelationAggregateInput
    embed?: AgentEmbedOrderByWithRelationInput
    connectedTo?: AgentConnectionOrderByRelationAggregateInput
    connectedFrom?: AgentConnectionOrderByRelationAggregateInput
    swarms?: AgentSwarmOrderByRelationAggregateInput
    emailAddress?: AgentEmailAddressOrderByWithRelationInput
    meetingRecordings?: MeetingRecordingOrderByRelationAggregateInput
    phoneNumber?: AgentPhoneNumberOrderByWithRelationInput
    metrics?: AgentMetricOrderByRelationAggregateInput
    traces?: AgentTraceOrderByRelationAggregateInput
    insights?: AgentInsightOrderByRelationAggregateInput
    feedbacks?: AgentFeedbackOrderByRelationAggregateInput
    abTests?: AgentABTestOrderByRelationAggregateInput
    optimizationRuns?: OptimizationRunOrderByRelationAggregateInput
    modificationProposals?: ModificationProposalOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    systemPrompt?: StringFilter<"Agent"> | string
    context?: StringNullableFilter<"Agent"> | string | null
    model?: EnumAgentModelFilter<"Agent"> | $Enums.AgentModel
    temperature?: FloatFilter<"Agent"> | number
    safeMode?: BoolFilter<"Agent"> | boolean
    llmTier?: StringNullableFilter<"Agent"> | string | null
    maxStepsPerRun?: IntNullableFilter<"Agent"> | number | null
    evalRules?: JsonNullableFilter<"Agent">
    workspaceId?: StringNullableFilter<"Agent"> | string | null
    avatar?: StringNullableFilter<"Agent"> | string | null
    tags?: StringNullableListFilter<"Agent">
    isFavorite?: BoolFilter<"Agent"> | boolean
    isEnabled?: BoolFilter<"Agent"> | boolean
    templateId?: StringNullableFilter<"Agent"> | string | null
    flowData?: JsonNullableFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    userId?: StringFilter<"Agent"> | string
    credentialId?: StringNullableFilter<"Agent"> | string | null
    template?: XOR<AgentTemplateNullableScalarRelationFilter, AgentTemplateWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    conversations?: ConversationListRelationFilter
    agentTools?: AgentToolListRelationFilter
    memories?: AgentMemoryListRelationFilter
    knowledgeDocuments?: KnowledgeDocumentListRelationFilter
    knowledgeSettings?: XOR<KnowledgeSettingsNullableScalarRelationFilter, KnowledgeSettingsWhereInput> | null
    triggers?: AgentTriggerListRelationFilter
    embed?: XOR<AgentEmbedNullableScalarRelationFilter, AgentEmbedWhereInput> | null
    connectedTo?: AgentConnectionListRelationFilter
    connectedFrom?: AgentConnectionListRelationFilter
    swarms?: AgentSwarmListRelationFilter
    emailAddress?: XOR<AgentEmailAddressNullableScalarRelationFilter, AgentEmailAddressWhereInput> | null
    meetingRecordings?: MeetingRecordingListRelationFilter
    phoneNumber?: XOR<AgentPhoneNumberNullableScalarRelationFilter, AgentPhoneNumberWhereInput> | null
    metrics?: AgentMetricListRelationFilter
    traces?: AgentTraceListRelationFilter
    insights?: AgentInsightListRelationFilter
    feedbacks?: AgentFeedbackListRelationFilter
    abTests?: AgentABTestListRelationFilter
    optimizationRuns?: OptimizationRunListRelationFilter
    modificationProposals?: ModificationProposalListRelationFilter
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    systemPrompt?: SortOrder
    context?: SortOrderInput | SortOrder
    model?: SortOrder
    temperature?: SortOrder
    safeMode?: SortOrder
    llmTier?: SortOrderInput | SortOrder
    maxStepsPerRun?: SortOrderInput | SortOrder
    evalRules?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    tags?: SortOrder
    isFavorite?: SortOrder
    isEnabled?: SortOrder
    templateId?: SortOrderInput | SortOrder
    flowData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrderInput | SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    description?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    systemPrompt?: StringWithAggregatesFilter<"Agent"> | string
    context?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    model?: EnumAgentModelWithAggregatesFilter<"Agent"> | $Enums.AgentModel
    temperature?: FloatWithAggregatesFilter<"Agent"> | number
    safeMode?: BoolWithAggregatesFilter<"Agent"> | boolean
    llmTier?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    maxStepsPerRun?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    evalRules?: JsonNullableWithAggregatesFilter<"Agent">
    workspaceId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    tags?: StringNullableListFilter<"Agent">
    isFavorite?: BoolWithAggregatesFilter<"Agent"> | boolean
    isEnabled?: BoolWithAggregatesFilter<"Agent"> | boolean
    templateId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    flowData?: JsonNullableWithAggregatesFilter<"Agent">
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    userId?: StringWithAggregatesFilter<"Agent"> | string
    credentialId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
  }

  export type AgentConnectionWhereInput = {
    AND?: AgentConnectionWhereInput | AgentConnectionWhereInput[]
    OR?: AgentConnectionWhereInput[]
    NOT?: AgentConnectionWhereInput | AgentConnectionWhereInput[]
    id?: StringFilter<"AgentConnection"> | string
    sourceAgentId?: StringFilter<"AgentConnection"> | string
    targetAgentId?: StringFilter<"AgentConnection"> | string
    alias?: StringFilter<"AgentConnection"> | string
    description?: StringFilter<"AgentConnection"> | string
    enabled?: BoolFilter<"AgentConnection"> | boolean
    createdAt?: DateTimeFilter<"AgentConnection"> | Date | string
    updatedAt?: DateTimeFilter<"AgentConnection"> | Date | string
    sourceAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    targetAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentConnectionOrderByWithRelationInput = {
    id?: SortOrder
    sourceAgentId?: SortOrder
    targetAgentId?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceAgent?: AgentOrderByWithRelationInput
    targetAgent?: AgentOrderByWithRelationInput
  }

  export type AgentConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceAgentId_targetAgentId?: AgentConnectionSourceAgentIdTargetAgentIdCompoundUniqueInput
    sourceAgentId_alias?: AgentConnectionSourceAgentIdAliasCompoundUniqueInput
    AND?: AgentConnectionWhereInput | AgentConnectionWhereInput[]
    OR?: AgentConnectionWhereInput[]
    NOT?: AgentConnectionWhereInput | AgentConnectionWhereInput[]
    sourceAgentId?: StringFilter<"AgentConnection"> | string
    targetAgentId?: StringFilter<"AgentConnection"> | string
    alias?: StringFilter<"AgentConnection"> | string
    description?: StringFilter<"AgentConnection"> | string
    enabled?: BoolFilter<"AgentConnection"> | boolean
    createdAt?: DateTimeFilter<"AgentConnection"> | Date | string
    updatedAt?: DateTimeFilter<"AgentConnection"> | Date | string
    sourceAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    targetAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "sourceAgentId_targetAgentId" | "sourceAgentId_alias">

  export type AgentConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    sourceAgentId?: SortOrder
    targetAgentId?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentConnectionCountOrderByAggregateInput
    _max?: AgentConnectionMaxOrderByAggregateInput
    _min?: AgentConnectionMinOrderByAggregateInput
  }

  export type AgentConnectionScalarWhereWithAggregatesInput = {
    AND?: AgentConnectionScalarWhereWithAggregatesInput | AgentConnectionScalarWhereWithAggregatesInput[]
    OR?: AgentConnectionScalarWhereWithAggregatesInput[]
    NOT?: AgentConnectionScalarWhereWithAggregatesInput | AgentConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentConnection"> | string
    sourceAgentId?: StringWithAggregatesFilter<"AgentConnection"> | string
    targetAgentId?: StringWithAggregatesFilter<"AgentConnection"> | string
    alias?: StringWithAggregatesFilter<"AgentConnection"> | string
    description?: StringWithAggregatesFilter<"AgentConnection"> | string
    enabled?: BoolWithAggregatesFilter<"AgentConnection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AgentConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentConnection"> | Date | string
  }

  export type AgentToolWhereInput = {
    AND?: AgentToolWhereInput | AgentToolWhereInput[]
    OR?: AgentToolWhereInput[]
    NOT?: AgentToolWhereInput | AgentToolWhereInput[]
    id?: StringFilter<"AgentTool"> | string
    agentId?: StringFilter<"AgentTool"> | string
    workflowId?: StringNullableFilter<"AgentTool"> | string | null
    composioAppKey?: StringNullableFilter<"AgentTool"> | string | null
    composioActionName?: StringNullableFilter<"AgentTool"> | string | null
    composioConfig?: JsonNullableFilter<"AgentTool">
    name?: StringFilter<"AgentTool"> | string
    description?: StringFilter<"AgentTool"> | string
    createdAt?: DateTimeFilter<"AgentTool"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTool"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    workflow?: XOR<WorkflowNullableScalarRelationFilter, WorkflowWhereInput> | null
  }

  export type AgentToolOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    workflowId?: SortOrderInput | SortOrder
    composioAppKey?: SortOrderInput | SortOrder
    composioActionName?: SortOrderInput | SortOrder
    composioConfig?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    workflow?: WorkflowOrderByWithRelationInput
  }

  export type AgentToolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_workflowId?: AgentToolAgentIdWorkflowIdCompoundUniqueInput
    AND?: AgentToolWhereInput | AgentToolWhereInput[]
    OR?: AgentToolWhereInput[]
    NOT?: AgentToolWhereInput | AgentToolWhereInput[]
    agentId?: StringFilter<"AgentTool"> | string
    workflowId?: StringNullableFilter<"AgentTool"> | string | null
    composioAppKey?: StringNullableFilter<"AgentTool"> | string | null
    composioActionName?: StringNullableFilter<"AgentTool"> | string | null
    composioConfig?: JsonNullableFilter<"AgentTool">
    name?: StringFilter<"AgentTool"> | string
    description?: StringFilter<"AgentTool"> | string
    createdAt?: DateTimeFilter<"AgentTool"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTool"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    workflow?: XOR<WorkflowNullableScalarRelationFilter, WorkflowWhereInput> | null
  }, "id" | "agentId_workflowId">

  export type AgentToolOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    workflowId?: SortOrderInput | SortOrder
    composioAppKey?: SortOrderInput | SortOrder
    composioActionName?: SortOrderInput | SortOrder
    composioConfig?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentToolCountOrderByAggregateInput
    _max?: AgentToolMaxOrderByAggregateInput
    _min?: AgentToolMinOrderByAggregateInput
  }

  export type AgentToolScalarWhereWithAggregatesInput = {
    AND?: AgentToolScalarWhereWithAggregatesInput | AgentToolScalarWhereWithAggregatesInput[]
    OR?: AgentToolScalarWhereWithAggregatesInput[]
    NOT?: AgentToolScalarWhereWithAggregatesInput | AgentToolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentTool"> | string
    agentId?: StringWithAggregatesFilter<"AgentTool"> | string
    workflowId?: StringNullableWithAggregatesFilter<"AgentTool"> | string | null
    composioAppKey?: StringNullableWithAggregatesFilter<"AgentTool"> | string | null
    composioActionName?: StringNullableWithAggregatesFilter<"AgentTool"> | string | null
    composioConfig?: JsonNullableWithAggregatesFilter<"AgentTool">
    name?: StringWithAggregatesFilter<"AgentTool"> | string
    description?: StringWithAggregatesFilter<"AgentTool"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgentTool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentTool"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    agentId?: StringFilter<"Conversation"> | string
    isArchived?: BoolFilter<"Conversation"> | boolean
    isPinned?: BoolFilter<"Conversation"> | boolean
    shareToken?: StringNullableFilter<"Conversation"> | string | null
    source?: EnumConversationSourceFilter<"Conversation"> | $Enums.ConversationSource
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    messages?: MessageListRelationFilter
    activities?: ConversationActivityListRelationFilter
    traces?: AgentTraceListRelationFilter
    evaluation?: XOR<ConversationEvaluationNullableScalarRelationFilter, ConversationEvaluationWhereInput> | null
    feedbacks?: AgentFeedbackListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    agentId?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    activities?: ConversationActivityOrderByRelationAggregateInput
    traces?: AgentTraceOrderByRelationAggregateInput
    evaluation?: ConversationEvaluationOrderByWithRelationInput
    feedbacks?: AgentFeedbackOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    title?: StringNullableFilter<"Conversation"> | string | null
    agentId?: StringFilter<"Conversation"> | string
    isArchived?: BoolFilter<"Conversation"> | boolean
    isPinned?: BoolFilter<"Conversation"> | boolean
    source?: EnumConversationSourceFilter<"Conversation"> | $Enums.ConversationSource
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    messages?: MessageListRelationFilter
    activities?: ConversationActivityListRelationFilter
    traces?: AgentTraceListRelationFilter
    evaluation?: XOR<ConversationEvaluationNullableScalarRelationFilter, ConversationEvaluationWhereInput> | null
    feedbacks?: AgentFeedbackListRelationFilter
  }, "id" | "shareToken">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    agentId?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    agentId?: StringWithAggregatesFilter<"Conversation"> | string
    isArchived?: BoolWithAggregatesFilter<"Conversation"> | boolean
    isPinned?: BoolWithAggregatesFilter<"Conversation"> | boolean
    shareToken?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    source?: EnumConversationSourceWithAggregatesFilter<"Conversation"> | $Enums.ConversationSource
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    toolName?: StringNullableFilter<"Message"> | string | null
    toolInput?: JsonNullableFilter<"Message">
    toolOutput?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrderInput | SortOrder
    toolInput?: SortOrderInput | SortOrder
    toolOutput?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    toolName?: StringNullableFilter<"Message"> | string | null
    toolInput?: JsonNullableFilter<"Message">
    toolOutput?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrderInput | SortOrder
    toolInput?: SortOrderInput | SortOrder
    toolOutput?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    role?: EnumMessageRoleWithAggregatesFilter<"Message"> | $Enums.MessageRole
    content?: StringWithAggregatesFilter<"Message"> | string
    toolName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    toolInput?: JsonNullableWithAggregatesFilter<"Message">
    toolOutput?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ConversationActivityWhereInput = {
    AND?: ConversationActivityWhereInput | ConversationActivityWhereInput[]
    OR?: ConversationActivityWhereInput[]
    NOT?: ConversationActivityWhereInput | ConversationActivityWhereInput[]
    id?: StringFilter<"ConversationActivity"> | string
    conversationId?: StringFilter<"ConversationActivity"> | string
    type?: EnumActivityTypeFilter<"ConversationActivity"> | $Enums.ActivityType
    title?: StringFilter<"ConversationActivity"> | string
    details?: JsonNullableFilter<"ConversationActivity">
    requiresConfirmation?: BoolFilter<"ConversationActivity"> | boolean
    confirmedAt?: DateTimeNullableFilter<"ConversationActivity"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ConversationActivity"> | Date | string | null
    createdAt?: DateTimeFilter<"ConversationActivity"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type ConversationActivityOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    details?: SortOrderInput | SortOrder
    requiresConfirmation?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationActivityWhereInput | ConversationActivityWhereInput[]
    OR?: ConversationActivityWhereInput[]
    NOT?: ConversationActivityWhereInput | ConversationActivityWhereInput[]
    conversationId?: StringFilter<"ConversationActivity"> | string
    type?: EnumActivityTypeFilter<"ConversationActivity"> | $Enums.ActivityType
    title?: StringFilter<"ConversationActivity"> | string
    details?: JsonNullableFilter<"ConversationActivity">
    requiresConfirmation?: BoolFilter<"ConversationActivity"> | boolean
    confirmedAt?: DateTimeNullableFilter<"ConversationActivity"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ConversationActivity"> | Date | string | null
    createdAt?: DateTimeFilter<"ConversationActivity"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type ConversationActivityOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    details?: SortOrderInput | SortOrder
    requiresConfirmation?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConversationActivityCountOrderByAggregateInput
    _max?: ConversationActivityMaxOrderByAggregateInput
    _min?: ConversationActivityMinOrderByAggregateInput
  }

  export type ConversationActivityScalarWhereWithAggregatesInput = {
    AND?: ConversationActivityScalarWhereWithAggregatesInput | ConversationActivityScalarWhereWithAggregatesInput[]
    OR?: ConversationActivityScalarWhereWithAggregatesInput[]
    NOT?: ConversationActivityScalarWhereWithAggregatesInput | ConversationActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationActivity"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"ConversationActivity"> | $Enums.ActivityType
    title?: StringWithAggregatesFilter<"ConversationActivity"> | string
    details?: JsonNullableWithAggregatesFilter<"ConversationActivity">
    requiresConfirmation?: BoolWithAggregatesFilter<"ConversationActivity"> | boolean
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"ConversationActivity"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"ConversationActivity"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConversationActivity"> | Date | string
  }

  export type AgentMemoryWhereInput = {
    AND?: AgentMemoryWhereInput | AgentMemoryWhereInput[]
    OR?: AgentMemoryWhereInput[]
    NOT?: AgentMemoryWhereInput | AgentMemoryWhereInput[]
    id?: StringFilter<"AgentMemory"> | string
    agentId?: StringFilter<"AgentMemory"> | string
    key?: StringFilter<"AgentMemory"> | string
    value?: StringFilter<"AgentMemory"> | string
    category?: EnumMemoryCategoryFilter<"AgentMemory"> | $Enums.MemoryCategory
    embedding?: FloatNullableListFilter<"AgentMemory">
    source?: StringNullableFilter<"AgentMemory"> | string | null
    expiresAt?: DateTimeNullableFilter<"AgentMemory"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentMemory"> | Date | string
    updatedAt?: DateTimeFilter<"AgentMemory"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentMemoryOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    embedding?: SortOrder
    source?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentMemoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_key?: AgentMemoryAgentIdKeyCompoundUniqueInput
    AND?: AgentMemoryWhereInput | AgentMemoryWhereInput[]
    OR?: AgentMemoryWhereInput[]
    NOT?: AgentMemoryWhereInput | AgentMemoryWhereInput[]
    agentId?: StringFilter<"AgentMemory"> | string
    key?: StringFilter<"AgentMemory"> | string
    value?: StringFilter<"AgentMemory"> | string
    category?: EnumMemoryCategoryFilter<"AgentMemory"> | $Enums.MemoryCategory
    embedding?: FloatNullableListFilter<"AgentMemory">
    source?: StringNullableFilter<"AgentMemory"> | string | null
    expiresAt?: DateTimeNullableFilter<"AgentMemory"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentMemory"> | Date | string
    updatedAt?: DateTimeFilter<"AgentMemory"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId_key">

  export type AgentMemoryOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    embedding?: SortOrder
    source?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentMemoryCountOrderByAggregateInput
    _avg?: AgentMemoryAvgOrderByAggregateInput
    _max?: AgentMemoryMaxOrderByAggregateInput
    _min?: AgentMemoryMinOrderByAggregateInput
    _sum?: AgentMemorySumOrderByAggregateInput
  }

  export type AgentMemoryScalarWhereWithAggregatesInput = {
    AND?: AgentMemoryScalarWhereWithAggregatesInput | AgentMemoryScalarWhereWithAggregatesInput[]
    OR?: AgentMemoryScalarWhereWithAggregatesInput[]
    NOT?: AgentMemoryScalarWhereWithAggregatesInput | AgentMemoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentMemory"> | string
    agentId?: StringWithAggregatesFilter<"AgentMemory"> | string
    key?: StringWithAggregatesFilter<"AgentMemory"> | string
    value?: StringWithAggregatesFilter<"AgentMemory"> | string
    category?: EnumMemoryCategoryWithAggregatesFilter<"AgentMemory"> | $Enums.MemoryCategory
    embedding?: FloatNullableListFilter<"AgentMemory">
    source?: StringNullableWithAggregatesFilter<"AgentMemory"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AgentMemory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentMemory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentMemory"> | Date | string
  }

  export type KnowledgeDocumentWhereInput = {
    AND?: KnowledgeDocumentWhereInput | KnowledgeDocumentWhereInput[]
    OR?: KnowledgeDocumentWhereInput[]
    NOT?: KnowledgeDocumentWhereInput | KnowledgeDocumentWhereInput[]
    id?: StringFilter<"KnowledgeDocument"> | string
    agentId?: StringFilter<"KnowledgeDocument"> | string
    title?: StringFilter<"KnowledgeDocument"> | string
    content?: StringFilter<"KnowledgeDocument"> | string
    source?: StringNullableFilter<"KnowledgeDocument"> | string | null
    mimeType?: StringFilter<"KnowledgeDocument"> | string
    fileSize?: IntNullableFilter<"KnowledgeDocument"> | number | null
    sourceType?: EnumKnowledgeSourceTypeFilter<"KnowledgeDocument"> | $Enums.KnowledgeSourceType
    externalId?: StringNullableFilter<"KnowledgeDocument"> | string | null
    externalUrl?: StringNullableFilter<"KnowledgeDocument"> | string | null
    syncStatus?: EnumKnowledgeSyncStatusFilter<"KnowledgeDocument"> | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: DateTimeNullableFilter<"KnowledgeDocument"> | Date | string | null
    syncError?: StringNullableFilter<"KnowledgeDocument"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeDocument"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    chunks?: KnowledgeChunkListRelationFilter
  }

  export type KnowledgeDocumentOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    chunks?: KnowledgeChunkOrderByRelationAggregateInput
  }

  export type KnowledgeDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeDocumentWhereInput | KnowledgeDocumentWhereInput[]
    OR?: KnowledgeDocumentWhereInput[]
    NOT?: KnowledgeDocumentWhereInput | KnowledgeDocumentWhereInput[]
    agentId?: StringFilter<"KnowledgeDocument"> | string
    title?: StringFilter<"KnowledgeDocument"> | string
    content?: StringFilter<"KnowledgeDocument"> | string
    source?: StringNullableFilter<"KnowledgeDocument"> | string | null
    mimeType?: StringFilter<"KnowledgeDocument"> | string
    fileSize?: IntNullableFilter<"KnowledgeDocument"> | number | null
    sourceType?: EnumKnowledgeSourceTypeFilter<"KnowledgeDocument"> | $Enums.KnowledgeSourceType
    externalId?: StringNullableFilter<"KnowledgeDocument"> | string | null
    externalUrl?: StringNullableFilter<"KnowledgeDocument"> | string | null
    syncStatus?: EnumKnowledgeSyncStatusFilter<"KnowledgeDocument"> | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: DateTimeNullableFilter<"KnowledgeDocument"> | Date | string | null
    syncError?: StringNullableFilter<"KnowledgeDocument"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeDocument"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    chunks?: KnowledgeChunkListRelationFilter
  }, "id">

  export type KnowledgeDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeDocumentCountOrderByAggregateInput
    _avg?: KnowledgeDocumentAvgOrderByAggregateInput
    _max?: KnowledgeDocumentMaxOrderByAggregateInput
    _min?: KnowledgeDocumentMinOrderByAggregateInput
    _sum?: KnowledgeDocumentSumOrderByAggregateInput
  }

  export type KnowledgeDocumentScalarWhereWithAggregatesInput = {
    AND?: KnowledgeDocumentScalarWhereWithAggregatesInput | KnowledgeDocumentScalarWhereWithAggregatesInput[]
    OR?: KnowledgeDocumentScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeDocumentScalarWhereWithAggregatesInput | KnowledgeDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeDocument"> | string
    agentId?: StringWithAggregatesFilter<"KnowledgeDocument"> | string
    title?: StringWithAggregatesFilter<"KnowledgeDocument"> | string
    content?: StringWithAggregatesFilter<"KnowledgeDocument"> | string
    source?: StringNullableWithAggregatesFilter<"KnowledgeDocument"> | string | null
    mimeType?: StringWithAggregatesFilter<"KnowledgeDocument"> | string
    fileSize?: IntNullableWithAggregatesFilter<"KnowledgeDocument"> | number | null
    sourceType?: EnumKnowledgeSourceTypeWithAggregatesFilter<"KnowledgeDocument"> | $Enums.KnowledgeSourceType
    externalId?: StringNullableWithAggregatesFilter<"KnowledgeDocument"> | string | null
    externalUrl?: StringNullableWithAggregatesFilter<"KnowledgeDocument"> | string | null
    syncStatus?: EnumKnowledgeSyncStatusWithAggregatesFilter<"KnowledgeDocument"> | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"KnowledgeDocument"> | Date | string | null
    syncError?: StringNullableWithAggregatesFilter<"KnowledgeDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeDocument"> | Date | string
  }

  export type KnowledgeChunkWhereInput = {
    AND?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    OR?: KnowledgeChunkWhereInput[]
    NOT?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    id?: StringFilter<"KnowledgeChunk"> | string
    documentId?: StringFilter<"KnowledgeChunk"> | string
    content?: StringFilter<"KnowledgeChunk"> | string
    embedding?: FloatNullableListFilter<"KnowledgeChunk">
    position?: IntFilter<"KnowledgeChunk"> | number
    pageNumber?: IntNullableFilter<"KnowledgeChunk"> | number | null
    heading?: StringNullableFilter<"KnowledgeChunk"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeChunk"> | Date | string
    document?: XOR<KnowledgeDocumentScalarRelationFilter, KnowledgeDocumentWhereInput>
  }

  export type KnowledgeChunkOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    content?: SortOrder
    embedding?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    heading?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    document?: KnowledgeDocumentOrderByWithRelationInput
  }

  export type KnowledgeChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    OR?: KnowledgeChunkWhereInput[]
    NOT?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    documentId?: StringFilter<"KnowledgeChunk"> | string
    content?: StringFilter<"KnowledgeChunk"> | string
    embedding?: FloatNullableListFilter<"KnowledgeChunk">
    position?: IntFilter<"KnowledgeChunk"> | number
    pageNumber?: IntNullableFilter<"KnowledgeChunk"> | number | null
    heading?: StringNullableFilter<"KnowledgeChunk"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeChunk"> | Date | string
    document?: XOR<KnowledgeDocumentScalarRelationFilter, KnowledgeDocumentWhereInput>
  }, "id">

  export type KnowledgeChunkOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    content?: SortOrder
    embedding?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    heading?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: KnowledgeChunkCountOrderByAggregateInput
    _avg?: KnowledgeChunkAvgOrderByAggregateInput
    _max?: KnowledgeChunkMaxOrderByAggregateInput
    _min?: KnowledgeChunkMinOrderByAggregateInput
    _sum?: KnowledgeChunkSumOrderByAggregateInput
  }

  export type KnowledgeChunkScalarWhereWithAggregatesInput = {
    AND?: KnowledgeChunkScalarWhereWithAggregatesInput | KnowledgeChunkScalarWhereWithAggregatesInput[]
    OR?: KnowledgeChunkScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeChunkScalarWhereWithAggregatesInput | KnowledgeChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeChunk"> | string
    documentId?: StringWithAggregatesFilter<"KnowledgeChunk"> | string
    content?: StringWithAggregatesFilter<"KnowledgeChunk"> | string
    embedding?: FloatNullableListFilter<"KnowledgeChunk">
    position?: IntWithAggregatesFilter<"KnowledgeChunk"> | number
    pageNumber?: IntNullableWithAggregatesFilter<"KnowledgeChunk"> | number | null
    heading?: StringNullableWithAggregatesFilter<"KnowledgeChunk"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeChunk"> | Date | string
  }

  export type KnowledgeSettingsWhereInput = {
    AND?: KnowledgeSettingsWhereInput | KnowledgeSettingsWhereInput[]
    OR?: KnowledgeSettingsWhereInput[]
    NOT?: KnowledgeSettingsWhereInput | KnowledgeSettingsWhereInput[]
    id?: StringFilter<"KnowledgeSettings"> | string
    agentId?: StringFilter<"KnowledgeSettings"> | string
    searchFuzziness?: IntFilter<"KnowledgeSettings"> | number
    maxResults?: IntFilter<"KnowledgeSettings"> | number
    autoRefresh?: BoolFilter<"KnowledgeSettings"> | boolean
    refreshInterval?: IntFilter<"KnowledgeSettings"> | number
    createdAt?: DateTimeFilter<"KnowledgeSettings"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeSettings"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type KnowledgeSettingsOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    autoRefresh?: SortOrder
    refreshInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type KnowledgeSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId?: string
    AND?: KnowledgeSettingsWhereInput | KnowledgeSettingsWhereInput[]
    OR?: KnowledgeSettingsWhereInput[]
    NOT?: KnowledgeSettingsWhereInput | KnowledgeSettingsWhereInput[]
    searchFuzziness?: IntFilter<"KnowledgeSettings"> | number
    maxResults?: IntFilter<"KnowledgeSettings"> | number
    autoRefresh?: BoolFilter<"KnowledgeSettings"> | boolean
    refreshInterval?: IntFilter<"KnowledgeSettings"> | number
    createdAt?: DateTimeFilter<"KnowledgeSettings"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeSettings"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId">

  export type KnowledgeSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    autoRefresh?: SortOrder
    refreshInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeSettingsCountOrderByAggregateInput
    _avg?: KnowledgeSettingsAvgOrderByAggregateInput
    _max?: KnowledgeSettingsMaxOrderByAggregateInput
    _min?: KnowledgeSettingsMinOrderByAggregateInput
    _sum?: KnowledgeSettingsSumOrderByAggregateInput
  }

  export type KnowledgeSettingsScalarWhereWithAggregatesInput = {
    AND?: KnowledgeSettingsScalarWhereWithAggregatesInput | KnowledgeSettingsScalarWhereWithAggregatesInput[]
    OR?: KnowledgeSettingsScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeSettingsScalarWhereWithAggregatesInput | KnowledgeSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeSettings"> | string
    agentId?: StringWithAggregatesFilter<"KnowledgeSettings"> | string
    searchFuzziness?: IntWithAggregatesFilter<"KnowledgeSettings"> | number
    maxResults?: IntWithAggregatesFilter<"KnowledgeSettings"> | number
    autoRefresh?: BoolWithAggregatesFilter<"KnowledgeSettings"> | boolean
    refreshInterval?: IntWithAggregatesFilter<"KnowledgeSettings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeSettings"> | Date | string
  }

  export type AgentTriggerWhereInput = {
    AND?: AgentTriggerWhereInput | AgentTriggerWhereInput[]
    OR?: AgentTriggerWhereInput[]
    NOT?: AgentTriggerWhereInput | AgentTriggerWhereInput[]
    id?: StringFilter<"AgentTrigger"> | string
    agentId?: StringFilter<"AgentTrigger"> | string
    name?: StringFilter<"AgentTrigger"> | string
    type?: EnumTriggerTypeFilter<"AgentTrigger"> | $Enums.TriggerType
    enabled?: BoolFilter<"AgentTrigger"> | boolean
    config?: JsonFilter<"AgentTrigger">
    cronExpression?: StringNullableFilter<"AgentTrigger"> | string | null
    nextRunAt?: DateTimeNullableFilter<"AgentTrigger"> | Date | string | null
    lastRunAt?: DateTimeNullableFilter<"AgentTrigger"> | Date | string | null
    webhookSecret?: StringNullableFilter<"AgentTrigger"> | string | null
    createdAt?: DateTimeFilter<"AgentTrigger"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTrigger"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentTriggerOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    config?: SortOrder
    cronExpression?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentTriggerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentTriggerWhereInput | AgentTriggerWhereInput[]
    OR?: AgentTriggerWhereInput[]
    NOT?: AgentTriggerWhereInput | AgentTriggerWhereInput[]
    agentId?: StringFilter<"AgentTrigger"> | string
    name?: StringFilter<"AgentTrigger"> | string
    type?: EnumTriggerTypeFilter<"AgentTrigger"> | $Enums.TriggerType
    enabled?: BoolFilter<"AgentTrigger"> | boolean
    config?: JsonFilter<"AgentTrigger">
    cronExpression?: StringNullableFilter<"AgentTrigger"> | string | null
    nextRunAt?: DateTimeNullableFilter<"AgentTrigger"> | Date | string | null
    lastRunAt?: DateTimeNullableFilter<"AgentTrigger"> | Date | string | null
    webhookSecret?: StringNullableFilter<"AgentTrigger"> | string | null
    createdAt?: DateTimeFilter<"AgentTrigger"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTrigger"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentTriggerOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    config?: SortOrder
    cronExpression?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentTriggerCountOrderByAggregateInput
    _max?: AgentTriggerMaxOrderByAggregateInput
    _min?: AgentTriggerMinOrderByAggregateInput
  }

  export type AgentTriggerScalarWhereWithAggregatesInput = {
    AND?: AgentTriggerScalarWhereWithAggregatesInput | AgentTriggerScalarWhereWithAggregatesInput[]
    OR?: AgentTriggerScalarWhereWithAggregatesInput[]
    NOT?: AgentTriggerScalarWhereWithAggregatesInput | AgentTriggerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentTrigger"> | string
    agentId?: StringWithAggregatesFilter<"AgentTrigger"> | string
    name?: StringWithAggregatesFilter<"AgentTrigger"> | string
    type?: EnumTriggerTypeWithAggregatesFilter<"AgentTrigger"> | $Enums.TriggerType
    enabled?: BoolWithAggregatesFilter<"AgentTrigger"> | boolean
    config?: JsonWithAggregatesFilter<"AgentTrigger">
    cronExpression?: StringNullableWithAggregatesFilter<"AgentTrigger"> | string | null
    nextRunAt?: DateTimeNullableWithAggregatesFilter<"AgentTrigger"> | Date | string | null
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"AgentTrigger"> | Date | string | null
    webhookSecret?: StringNullableWithAggregatesFilter<"AgentTrigger"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentTrigger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentTrigger"> | Date | string
  }

  export type AgentTemplateWhereInput = {
    AND?: AgentTemplateWhereInput | AgentTemplateWhereInput[]
    OR?: AgentTemplateWhereInput[]
    NOT?: AgentTemplateWhereInput | AgentTemplateWhereInput[]
    id?: StringFilter<"AgentTemplate"> | string
    slug?: StringNullableFilter<"AgentTemplate"> | string | null
    name?: StringFilter<"AgentTemplate"> | string
    subtitle?: StringNullableFilter<"AgentTemplate"> | string | null
    description?: StringFilter<"AgentTemplate"> | string
    category?: EnumTemplateCategoryFilter<"AgentTemplate"> | $Enums.TemplateCategory
    role?: EnumTemplateRoleNullableFilter<"AgentTemplate"> | $Enums.TemplateRole | null
    useCase?: EnumTemplateUseCaseNullableFilter<"AgentTemplate"> | $Enums.TemplateUseCase | null
    systemPrompt?: StringFilter<"AgentTemplate"> | string
    context?: StringNullableFilter<"AgentTemplate"> | string | null
    model?: EnumAgentModelFilter<"AgentTemplate"> | $Enums.AgentModel
    temperature?: FloatFilter<"AgentTemplate"> | number
    trigger?: JsonFilter<"AgentTemplate">
    llmTier?: StringFilter<"AgentTemplate"> | string
    maxStepsPerRun?: IntFilter<"AgentTemplate"> | number
    fetchSources?: JsonFilter<"AgentTemplate">
    actions?: JsonFilter<"AgentTemplate">
    evalRules?: JsonFilter<"AgentTemplate">
    suggestedTools?: JsonFilter<"AgentTemplate">
    suggestedTriggers?: JsonFilter<"AgentTemplate">
    suggestedIntegrations?: StringNullableListFilter<"AgentTemplate">
    flowData?: JsonFilter<"AgentTemplate">
    defaultTriggers?: JsonFilter<"AgentTemplate">
    defaultTools?: JsonFilter<"AgentTemplate">
    icon?: StringNullableFilter<"AgentTemplate"> | string | null
    color?: StringNullableFilter<"AgentTemplate"> | string | null
    coverImage?: StringNullableFilter<"AgentTemplate"> | string | null
    isPublic?: BoolFilter<"AgentTemplate"> | boolean
    isFeatured?: BoolFilter<"AgentTemplate"> | boolean
    createdById?: StringNullableFilter<"AgentTemplate"> | string | null
    createdByName?: StringNullableFilter<"AgentTemplate"> | string | null
    usageCount?: IntFilter<"AgentTemplate"> | number
    rating?: FloatFilter<"AgentTemplate"> | number
    reviewCount?: IntFilter<"AgentTemplate"> | number
    tags?: StringNullableListFilter<"AgentTemplate">
    createdAt?: DateTimeFilter<"AgentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTemplate"> | Date | string
    agents?: AgentListRelationFilter
  }

  export type AgentTemplateOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrderInput | SortOrder
    name?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrder
    category?: SortOrder
    role?: SortOrderInput | SortOrder
    useCase?: SortOrderInput | SortOrder
    systemPrompt?: SortOrder
    context?: SortOrderInput | SortOrder
    model?: SortOrder
    temperature?: SortOrder
    trigger?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    fetchSources?: SortOrder
    actions?: SortOrder
    evalRules?: SortOrder
    suggestedTools?: SortOrder
    suggestedTriggers?: SortOrder
    suggestedIntegrations?: SortOrder
    flowData?: SortOrder
    defaultTriggers?: SortOrder
    defaultTools?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agents?: AgentOrderByRelationAggregateInput
  }

  export type AgentTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: AgentTemplateWhereInput | AgentTemplateWhereInput[]
    OR?: AgentTemplateWhereInput[]
    NOT?: AgentTemplateWhereInput | AgentTemplateWhereInput[]
    name?: StringFilter<"AgentTemplate"> | string
    subtitle?: StringNullableFilter<"AgentTemplate"> | string | null
    description?: StringFilter<"AgentTemplate"> | string
    category?: EnumTemplateCategoryFilter<"AgentTemplate"> | $Enums.TemplateCategory
    role?: EnumTemplateRoleNullableFilter<"AgentTemplate"> | $Enums.TemplateRole | null
    useCase?: EnumTemplateUseCaseNullableFilter<"AgentTemplate"> | $Enums.TemplateUseCase | null
    systemPrompt?: StringFilter<"AgentTemplate"> | string
    context?: StringNullableFilter<"AgentTemplate"> | string | null
    model?: EnumAgentModelFilter<"AgentTemplate"> | $Enums.AgentModel
    temperature?: FloatFilter<"AgentTemplate"> | number
    trigger?: JsonFilter<"AgentTemplate">
    llmTier?: StringFilter<"AgentTemplate"> | string
    maxStepsPerRun?: IntFilter<"AgentTemplate"> | number
    fetchSources?: JsonFilter<"AgentTemplate">
    actions?: JsonFilter<"AgentTemplate">
    evalRules?: JsonFilter<"AgentTemplate">
    suggestedTools?: JsonFilter<"AgentTemplate">
    suggestedTriggers?: JsonFilter<"AgentTemplate">
    suggestedIntegrations?: StringNullableListFilter<"AgentTemplate">
    flowData?: JsonFilter<"AgentTemplate">
    defaultTriggers?: JsonFilter<"AgentTemplate">
    defaultTools?: JsonFilter<"AgentTemplate">
    icon?: StringNullableFilter<"AgentTemplate"> | string | null
    color?: StringNullableFilter<"AgentTemplate"> | string | null
    coverImage?: StringNullableFilter<"AgentTemplate"> | string | null
    isPublic?: BoolFilter<"AgentTemplate"> | boolean
    isFeatured?: BoolFilter<"AgentTemplate"> | boolean
    createdById?: StringNullableFilter<"AgentTemplate"> | string | null
    createdByName?: StringNullableFilter<"AgentTemplate"> | string | null
    usageCount?: IntFilter<"AgentTemplate"> | number
    rating?: FloatFilter<"AgentTemplate"> | number
    reviewCount?: IntFilter<"AgentTemplate"> | number
    tags?: StringNullableListFilter<"AgentTemplate">
    createdAt?: DateTimeFilter<"AgentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTemplate"> | Date | string
    agents?: AgentListRelationFilter
  }, "id" | "slug">

  export type AgentTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrderInput | SortOrder
    name?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrder
    category?: SortOrder
    role?: SortOrderInput | SortOrder
    useCase?: SortOrderInput | SortOrder
    systemPrompt?: SortOrder
    context?: SortOrderInput | SortOrder
    model?: SortOrder
    temperature?: SortOrder
    trigger?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    fetchSources?: SortOrder
    actions?: SortOrder
    evalRules?: SortOrder
    suggestedTools?: SortOrder
    suggestedTriggers?: SortOrder
    suggestedIntegrations?: SortOrder
    flowData?: SortOrder
    defaultTriggers?: SortOrder
    defaultTools?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentTemplateCountOrderByAggregateInput
    _avg?: AgentTemplateAvgOrderByAggregateInput
    _max?: AgentTemplateMaxOrderByAggregateInput
    _min?: AgentTemplateMinOrderByAggregateInput
    _sum?: AgentTemplateSumOrderByAggregateInput
  }

  export type AgentTemplateScalarWhereWithAggregatesInput = {
    AND?: AgentTemplateScalarWhereWithAggregatesInput | AgentTemplateScalarWhereWithAggregatesInput[]
    OR?: AgentTemplateScalarWhereWithAggregatesInput[]
    NOT?: AgentTemplateScalarWhereWithAggregatesInput | AgentTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentTemplate"> | string
    slug?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    name?: StringWithAggregatesFilter<"AgentTemplate"> | string
    subtitle?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    description?: StringWithAggregatesFilter<"AgentTemplate"> | string
    category?: EnumTemplateCategoryWithAggregatesFilter<"AgentTemplate"> | $Enums.TemplateCategory
    role?: EnumTemplateRoleNullableWithAggregatesFilter<"AgentTemplate"> | $Enums.TemplateRole | null
    useCase?: EnumTemplateUseCaseNullableWithAggregatesFilter<"AgentTemplate"> | $Enums.TemplateUseCase | null
    systemPrompt?: StringWithAggregatesFilter<"AgentTemplate"> | string
    context?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    model?: EnumAgentModelWithAggregatesFilter<"AgentTemplate"> | $Enums.AgentModel
    temperature?: FloatWithAggregatesFilter<"AgentTemplate"> | number
    trigger?: JsonWithAggregatesFilter<"AgentTemplate">
    llmTier?: StringWithAggregatesFilter<"AgentTemplate"> | string
    maxStepsPerRun?: IntWithAggregatesFilter<"AgentTemplate"> | number
    fetchSources?: JsonWithAggregatesFilter<"AgentTemplate">
    actions?: JsonWithAggregatesFilter<"AgentTemplate">
    evalRules?: JsonWithAggregatesFilter<"AgentTemplate">
    suggestedTools?: JsonWithAggregatesFilter<"AgentTemplate">
    suggestedTriggers?: JsonWithAggregatesFilter<"AgentTemplate">
    suggestedIntegrations?: StringNullableListFilter<"AgentTemplate">
    flowData?: JsonWithAggregatesFilter<"AgentTemplate">
    defaultTriggers?: JsonWithAggregatesFilter<"AgentTemplate">
    defaultTools?: JsonWithAggregatesFilter<"AgentTemplate">
    icon?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    color?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    isPublic?: BoolWithAggregatesFilter<"AgentTemplate"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"AgentTemplate"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    createdByName?: StringNullableWithAggregatesFilter<"AgentTemplate"> | string | null
    usageCount?: IntWithAggregatesFilter<"AgentTemplate"> | number
    rating?: FloatWithAggregatesFilter<"AgentTemplate"> | number
    reviewCount?: IntWithAggregatesFilter<"AgentTemplate"> | number
    tags?: StringNullableListFilter<"AgentTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"AgentTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentTemplate"> | Date | string
  }

  export type AgentEmbedWhereInput = {
    AND?: AgentEmbedWhereInput | AgentEmbedWhereInput[]
    OR?: AgentEmbedWhereInput[]
    NOT?: AgentEmbedWhereInput | AgentEmbedWhereInput[]
    id?: StringFilter<"AgentEmbed"> | string
    agentId?: StringFilter<"AgentEmbed"> | string
    enabled?: BoolFilter<"AgentEmbed"> | boolean
    allowedDomains?: StringNullableListFilter<"AgentEmbed">
    displayName?: StringNullableFilter<"AgentEmbed"> | string | null
    welcomeMessage?: StringNullableFilter<"AgentEmbed"> | string | null
    logo?: StringNullableFilter<"AgentEmbed"> | string | null
    accentColor?: StringFilter<"AgentEmbed"> | string
    backgroundColor?: StringFilter<"AgentEmbed"> | string
    textColor?: StringFilter<"AgentEmbed"> | string
    userBubbleColor?: StringFilter<"AgentEmbed"> | string
    botBubbleColor?: StringFilter<"AgentEmbed"> | string
    position?: EnumEmbedPositionFilter<"AgentEmbed"> | $Enums.EmbedPosition
    buttonSize?: IntFilter<"AgentEmbed"> | number
    windowWidth?: IntFilter<"AgentEmbed"> | number
    windowHeight?: IntFilter<"AgentEmbed"> | number
    autoOpen?: BoolFilter<"AgentEmbed"> | boolean
    autoOpenDelay?: IntFilter<"AgentEmbed"> | number
    showBranding?: BoolFilter<"AgentEmbed"> | boolean
    collectEmail?: BoolFilter<"AgentEmbed"> | boolean
    requireEmail?: BoolFilter<"AgentEmbed"> | boolean
    conversationStarters?: JsonFilter<"AgentEmbed">
    customCss?: StringNullableFilter<"AgentEmbed"> | string | null
    totalConversations?: IntFilter<"AgentEmbed"> | number
    createdAt?: DateTimeFilter<"AgentEmbed"> | Date | string
    updatedAt?: DateTimeFilter<"AgentEmbed"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentEmbedOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    enabled?: SortOrder
    allowedDomains?: SortOrder
    displayName?: SortOrderInput | SortOrder
    welcomeMessage?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    accentColor?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    userBubbleColor?: SortOrder
    botBubbleColor?: SortOrder
    position?: SortOrder
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpen?: SortOrder
    autoOpenDelay?: SortOrder
    showBranding?: SortOrder
    collectEmail?: SortOrder
    requireEmail?: SortOrder
    conversationStarters?: SortOrder
    customCss?: SortOrderInput | SortOrder
    totalConversations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentEmbedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId?: string
    AND?: AgentEmbedWhereInput | AgentEmbedWhereInput[]
    OR?: AgentEmbedWhereInput[]
    NOT?: AgentEmbedWhereInput | AgentEmbedWhereInput[]
    enabled?: BoolFilter<"AgentEmbed"> | boolean
    allowedDomains?: StringNullableListFilter<"AgentEmbed">
    displayName?: StringNullableFilter<"AgentEmbed"> | string | null
    welcomeMessage?: StringNullableFilter<"AgentEmbed"> | string | null
    logo?: StringNullableFilter<"AgentEmbed"> | string | null
    accentColor?: StringFilter<"AgentEmbed"> | string
    backgroundColor?: StringFilter<"AgentEmbed"> | string
    textColor?: StringFilter<"AgentEmbed"> | string
    userBubbleColor?: StringFilter<"AgentEmbed"> | string
    botBubbleColor?: StringFilter<"AgentEmbed"> | string
    position?: EnumEmbedPositionFilter<"AgentEmbed"> | $Enums.EmbedPosition
    buttonSize?: IntFilter<"AgentEmbed"> | number
    windowWidth?: IntFilter<"AgentEmbed"> | number
    windowHeight?: IntFilter<"AgentEmbed"> | number
    autoOpen?: BoolFilter<"AgentEmbed"> | boolean
    autoOpenDelay?: IntFilter<"AgentEmbed"> | number
    showBranding?: BoolFilter<"AgentEmbed"> | boolean
    collectEmail?: BoolFilter<"AgentEmbed"> | boolean
    requireEmail?: BoolFilter<"AgentEmbed"> | boolean
    conversationStarters?: JsonFilter<"AgentEmbed">
    customCss?: StringNullableFilter<"AgentEmbed"> | string | null
    totalConversations?: IntFilter<"AgentEmbed"> | number
    createdAt?: DateTimeFilter<"AgentEmbed"> | Date | string
    updatedAt?: DateTimeFilter<"AgentEmbed"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId">

  export type AgentEmbedOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    enabled?: SortOrder
    allowedDomains?: SortOrder
    displayName?: SortOrderInput | SortOrder
    welcomeMessage?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    accentColor?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    userBubbleColor?: SortOrder
    botBubbleColor?: SortOrder
    position?: SortOrder
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpen?: SortOrder
    autoOpenDelay?: SortOrder
    showBranding?: SortOrder
    collectEmail?: SortOrder
    requireEmail?: SortOrder
    conversationStarters?: SortOrder
    customCss?: SortOrderInput | SortOrder
    totalConversations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentEmbedCountOrderByAggregateInput
    _avg?: AgentEmbedAvgOrderByAggregateInput
    _max?: AgentEmbedMaxOrderByAggregateInput
    _min?: AgentEmbedMinOrderByAggregateInput
    _sum?: AgentEmbedSumOrderByAggregateInput
  }

  export type AgentEmbedScalarWhereWithAggregatesInput = {
    AND?: AgentEmbedScalarWhereWithAggregatesInput | AgentEmbedScalarWhereWithAggregatesInput[]
    OR?: AgentEmbedScalarWhereWithAggregatesInput[]
    NOT?: AgentEmbedScalarWhereWithAggregatesInput | AgentEmbedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentEmbed"> | string
    agentId?: StringWithAggregatesFilter<"AgentEmbed"> | string
    enabled?: BoolWithAggregatesFilter<"AgentEmbed"> | boolean
    allowedDomains?: StringNullableListFilter<"AgentEmbed">
    displayName?: StringNullableWithAggregatesFilter<"AgentEmbed"> | string | null
    welcomeMessage?: StringNullableWithAggregatesFilter<"AgentEmbed"> | string | null
    logo?: StringNullableWithAggregatesFilter<"AgentEmbed"> | string | null
    accentColor?: StringWithAggregatesFilter<"AgentEmbed"> | string
    backgroundColor?: StringWithAggregatesFilter<"AgentEmbed"> | string
    textColor?: StringWithAggregatesFilter<"AgentEmbed"> | string
    userBubbleColor?: StringWithAggregatesFilter<"AgentEmbed"> | string
    botBubbleColor?: StringWithAggregatesFilter<"AgentEmbed"> | string
    position?: EnumEmbedPositionWithAggregatesFilter<"AgentEmbed"> | $Enums.EmbedPosition
    buttonSize?: IntWithAggregatesFilter<"AgentEmbed"> | number
    windowWidth?: IntWithAggregatesFilter<"AgentEmbed"> | number
    windowHeight?: IntWithAggregatesFilter<"AgentEmbed"> | number
    autoOpen?: BoolWithAggregatesFilter<"AgentEmbed"> | boolean
    autoOpenDelay?: IntWithAggregatesFilter<"AgentEmbed"> | number
    showBranding?: BoolWithAggregatesFilter<"AgentEmbed"> | boolean
    collectEmail?: BoolWithAggregatesFilter<"AgentEmbed"> | boolean
    requireEmail?: BoolWithAggregatesFilter<"AgentEmbed"> | boolean
    conversationStarters?: JsonWithAggregatesFilter<"AgentEmbed">
    customCss?: StringNullableWithAggregatesFilter<"AgentEmbed"> | string | null
    totalConversations?: IntWithAggregatesFilter<"AgentEmbed"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgentEmbed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentEmbed"> | Date | string
  }

  export type AgentEmailAddressWhereInput = {
    AND?: AgentEmailAddressWhereInput | AgentEmailAddressWhereInput[]
    OR?: AgentEmailAddressWhereInput[]
    NOT?: AgentEmailAddressWhereInput | AgentEmailAddressWhereInput[]
    id?: StringFilter<"AgentEmailAddress"> | string
    agentId?: StringFilter<"AgentEmailAddress"> | string
    localPart?: StringFilter<"AgentEmailAddress"> | string
    domain?: StringFilter<"AgentEmailAddress"> | string
    autoReply?: BoolFilter<"AgentEmailAddress"> | boolean
    createdAt?: DateTimeFilter<"AgentEmailAddress"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentEmailAddressOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    localPart?: SortOrder
    domain?: SortOrder
    autoReply?: SortOrder
    createdAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentEmailAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId?: string
    localPart_domain?: AgentEmailAddressLocalPartDomainCompoundUniqueInput
    AND?: AgentEmailAddressWhereInput | AgentEmailAddressWhereInput[]
    OR?: AgentEmailAddressWhereInput[]
    NOT?: AgentEmailAddressWhereInput | AgentEmailAddressWhereInput[]
    localPart?: StringFilter<"AgentEmailAddress"> | string
    domain?: StringFilter<"AgentEmailAddress"> | string
    autoReply?: BoolFilter<"AgentEmailAddress"> | boolean
    createdAt?: DateTimeFilter<"AgentEmailAddress"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId" | "localPart_domain">

  export type AgentEmailAddressOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    localPart?: SortOrder
    domain?: SortOrder
    autoReply?: SortOrder
    createdAt?: SortOrder
    _count?: AgentEmailAddressCountOrderByAggregateInput
    _max?: AgentEmailAddressMaxOrderByAggregateInput
    _min?: AgentEmailAddressMinOrderByAggregateInput
  }

  export type AgentEmailAddressScalarWhereWithAggregatesInput = {
    AND?: AgentEmailAddressScalarWhereWithAggregatesInput | AgentEmailAddressScalarWhereWithAggregatesInput[]
    OR?: AgentEmailAddressScalarWhereWithAggregatesInput[]
    NOT?: AgentEmailAddressScalarWhereWithAggregatesInput | AgentEmailAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentEmailAddress"> | string
    agentId?: StringWithAggregatesFilter<"AgentEmailAddress"> | string
    localPart?: StringWithAggregatesFilter<"AgentEmailAddress"> | string
    domain?: StringWithAggregatesFilter<"AgentEmailAddress"> | string
    autoReply?: BoolWithAggregatesFilter<"AgentEmailAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AgentEmailAddress"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    userId?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    accessToken?: StringFilter<"Integration"> | string
    refreshToken?: StringNullableFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    accountEmail?: StringNullableFilter<"Integration"> | string | null
    accountName?: StringNullableFilter<"Integration"> | string | null
    scopes?: StringNullableListFilter<"Integration">
    teamId?: StringNullableFilter<"Integration"> | string | null
    teamName?: StringNullableFilter<"Integration"> | string | null
    botUserId?: StringNullableFilter<"Integration"> | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    accountEmail?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    scopes?: SortOrder
    teamId?: SortOrderInput | SortOrder
    teamName?: SortOrderInput | SortOrder
    botUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_type?: IntegrationUserIdTypeCompoundUniqueInput
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    userId?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    accessToken?: StringFilter<"Integration"> | string
    refreshToken?: StringNullableFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    accountEmail?: StringNullableFilter<"Integration"> | string | null
    accountName?: StringNullableFilter<"Integration"> | string | null
    scopes?: StringNullableListFilter<"Integration">
    teamId?: StringNullableFilter<"Integration"> | string | null
    teamName?: StringNullableFilter<"Integration"> | string | null
    botUserId?: StringNullableFilter<"Integration"> | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_type">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    accountEmail?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    scopes?: SortOrder
    teamId?: SortOrderInput | SortOrder
    teamName?: SortOrderInput | SortOrder
    botUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    userId?: StringWithAggregatesFilter<"Integration"> | string
    type?: EnumIntegrationTypeWithAggregatesFilter<"Integration"> | $Enums.IntegrationType
    accessToken?: StringWithAggregatesFilter<"Integration"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    accountEmail?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    scopes?: StringNullableListFilter<"Integration">
    teamId?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    teamName?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    botUserId?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type AgentSwarmWhereInput = {
    AND?: AgentSwarmWhereInput | AgentSwarmWhereInput[]
    OR?: AgentSwarmWhereInput[]
    NOT?: AgentSwarmWhereInput | AgentSwarmWhereInput[]
    id?: StringFilter<"AgentSwarm"> | string
    agentId?: StringFilter<"AgentSwarm"> | string
    name?: StringFilter<"AgentSwarm"> | string
    taskTemplate?: StringFilter<"AgentSwarm"> | string
    status?: EnumSwarmStatusFilter<"AgentSwarm"> | $Enums.SwarmStatus
    totalTasks?: IntFilter<"AgentSwarm"> | number
    completedTasks?: IntFilter<"AgentSwarm"> | number
    failedTasks?: IntFilter<"AgentSwarm"> | number
    createdAt?: DateTimeFilter<"AgentSwarm"> | Date | string
    updatedAt?: DateTimeFilter<"AgentSwarm"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    tasks?: SwarmTaskListRelationFilter
  }

  export type AgentSwarmOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    taskTemplate?: SortOrder
    status?: SortOrder
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    tasks?: SwarmTaskOrderByRelationAggregateInput
  }

  export type AgentSwarmWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentSwarmWhereInput | AgentSwarmWhereInput[]
    OR?: AgentSwarmWhereInput[]
    NOT?: AgentSwarmWhereInput | AgentSwarmWhereInput[]
    agentId?: StringFilter<"AgentSwarm"> | string
    name?: StringFilter<"AgentSwarm"> | string
    taskTemplate?: StringFilter<"AgentSwarm"> | string
    status?: EnumSwarmStatusFilter<"AgentSwarm"> | $Enums.SwarmStatus
    totalTasks?: IntFilter<"AgentSwarm"> | number
    completedTasks?: IntFilter<"AgentSwarm"> | number
    failedTasks?: IntFilter<"AgentSwarm"> | number
    createdAt?: DateTimeFilter<"AgentSwarm"> | Date | string
    updatedAt?: DateTimeFilter<"AgentSwarm"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    tasks?: SwarmTaskListRelationFilter
  }, "id">

  export type AgentSwarmOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    taskTemplate?: SortOrder
    status?: SortOrder
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentSwarmCountOrderByAggregateInput
    _avg?: AgentSwarmAvgOrderByAggregateInput
    _max?: AgentSwarmMaxOrderByAggregateInput
    _min?: AgentSwarmMinOrderByAggregateInput
    _sum?: AgentSwarmSumOrderByAggregateInput
  }

  export type AgentSwarmScalarWhereWithAggregatesInput = {
    AND?: AgentSwarmScalarWhereWithAggregatesInput | AgentSwarmScalarWhereWithAggregatesInput[]
    OR?: AgentSwarmScalarWhereWithAggregatesInput[]
    NOT?: AgentSwarmScalarWhereWithAggregatesInput | AgentSwarmScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentSwarm"> | string
    agentId?: StringWithAggregatesFilter<"AgentSwarm"> | string
    name?: StringWithAggregatesFilter<"AgentSwarm"> | string
    taskTemplate?: StringWithAggregatesFilter<"AgentSwarm"> | string
    status?: EnumSwarmStatusWithAggregatesFilter<"AgentSwarm"> | $Enums.SwarmStatus
    totalTasks?: IntWithAggregatesFilter<"AgentSwarm"> | number
    completedTasks?: IntWithAggregatesFilter<"AgentSwarm"> | number
    failedTasks?: IntWithAggregatesFilter<"AgentSwarm"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgentSwarm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentSwarm"> | Date | string
  }

  export type SwarmTaskWhereInput = {
    AND?: SwarmTaskWhereInput | SwarmTaskWhereInput[]
    OR?: SwarmTaskWhereInput[]
    NOT?: SwarmTaskWhereInput | SwarmTaskWhereInput[]
    id?: StringFilter<"SwarmTask"> | string
    swarmId?: StringFilter<"SwarmTask"> | string
    input?: JsonFilter<"SwarmTask">
    status?: EnumSwarmTaskStatusFilter<"SwarmTask"> | $Enums.SwarmTaskStatus
    output?: StringNullableFilter<"SwarmTask"> | string | null
    error?: StringNullableFilter<"SwarmTask"> | string | null
    startedAt?: DateTimeNullableFilter<"SwarmTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SwarmTask"> | Date | string | null
    createdAt?: DateTimeFilter<"SwarmTask"> | Date | string
    swarm?: XOR<AgentSwarmScalarRelationFilter, AgentSwarmWhereInput>
  }

  export type SwarmTaskOrderByWithRelationInput = {
    id?: SortOrder
    swarmId?: SortOrder
    input?: SortOrder
    status?: SortOrder
    output?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    swarm?: AgentSwarmOrderByWithRelationInput
  }

  export type SwarmTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SwarmTaskWhereInput | SwarmTaskWhereInput[]
    OR?: SwarmTaskWhereInput[]
    NOT?: SwarmTaskWhereInput | SwarmTaskWhereInput[]
    swarmId?: StringFilter<"SwarmTask"> | string
    input?: JsonFilter<"SwarmTask">
    status?: EnumSwarmTaskStatusFilter<"SwarmTask"> | $Enums.SwarmTaskStatus
    output?: StringNullableFilter<"SwarmTask"> | string | null
    error?: StringNullableFilter<"SwarmTask"> | string | null
    startedAt?: DateTimeNullableFilter<"SwarmTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SwarmTask"> | Date | string | null
    createdAt?: DateTimeFilter<"SwarmTask"> | Date | string
    swarm?: XOR<AgentSwarmScalarRelationFilter, AgentSwarmWhereInput>
  }, "id">

  export type SwarmTaskOrderByWithAggregationInput = {
    id?: SortOrder
    swarmId?: SortOrder
    input?: SortOrder
    status?: SortOrder
    output?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SwarmTaskCountOrderByAggregateInput
    _max?: SwarmTaskMaxOrderByAggregateInput
    _min?: SwarmTaskMinOrderByAggregateInput
  }

  export type SwarmTaskScalarWhereWithAggregatesInput = {
    AND?: SwarmTaskScalarWhereWithAggregatesInput | SwarmTaskScalarWhereWithAggregatesInput[]
    OR?: SwarmTaskScalarWhereWithAggregatesInput[]
    NOT?: SwarmTaskScalarWhereWithAggregatesInput | SwarmTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SwarmTask"> | string
    swarmId?: StringWithAggregatesFilter<"SwarmTask"> | string
    input?: JsonWithAggregatesFilter<"SwarmTask">
    status?: EnumSwarmTaskStatusWithAggregatesFilter<"SwarmTask"> | $Enums.SwarmTaskStatus
    output?: StringNullableWithAggregatesFilter<"SwarmTask"> | string | null
    error?: StringNullableWithAggregatesFilter<"SwarmTask"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"SwarmTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"SwarmTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SwarmTask"> | Date | string
  }

  export type MeetingRecordingWhereInput = {
    AND?: MeetingRecordingWhereInput | MeetingRecordingWhereInput[]
    OR?: MeetingRecordingWhereInput[]
    NOT?: MeetingRecordingWhereInput | MeetingRecordingWhereInput[]
    id?: StringFilter<"MeetingRecording"> | string
    agentId?: StringFilter<"MeetingRecording"> | string
    title?: StringFilter<"MeetingRecording"> | string
    meetingUrl?: StringNullableFilter<"MeetingRecording"> | string | null
    meetingPlatform?: EnumMeetingPlatformFilter<"MeetingRecording"> | $Enums.MeetingPlatform
    calendarEventId?: StringNullableFilter<"MeetingRecording"> | string | null
    status?: EnumRecordingStatusFilter<"MeetingRecording"> | $Enums.RecordingStatus
    recordingUrl?: StringNullableFilter<"MeetingRecording"> | string | null
    transcript?: StringNullableFilter<"MeetingRecording"> | string | null
    summary?: StringNullableFilter<"MeetingRecording"> | string | null
    actionItems?: JsonFilter<"MeetingRecording">
    participants?: JsonFilter<"MeetingRecording">
    scheduledAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    startedAt?: DateTimeNullableFilter<"MeetingRecording"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MeetingRecording"> | Date | string | null
    duration?: IntNullableFilter<"MeetingRecording"> | number | null
    createdAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type MeetingRecordingOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    meetingPlatform?: SortOrder
    calendarEventId?: SortOrderInput | SortOrder
    status?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    actionItems?: SortOrder
    participants?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type MeetingRecordingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeetingRecordingWhereInput | MeetingRecordingWhereInput[]
    OR?: MeetingRecordingWhereInput[]
    NOT?: MeetingRecordingWhereInput | MeetingRecordingWhereInput[]
    agentId?: StringFilter<"MeetingRecording"> | string
    title?: StringFilter<"MeetingRecording"> | string
    meetingUrl?: StringNullableFilter<"MeetingRecording"> | string | null
    meetingPlatform?: EnumMeetingPlatformFilter<"MeetingRecording"> | $Enums.MeetingPlatform
    calendarEventId?: StringNullableFilter<"MeetingRecording"> | string | null
    status?: EnumRecordingStatusFilter<"MeetingRecording"> | $Enums.RecordingStatus
    recordingUrl?: StringNullableFilter<"MeetingRecording"> | string | null
    transcript?: StringNullableFilter<"MeetingRecording"> | string | null
    summary?: StringNullableFilter<"MeetingRecording"> | string | null
    actionItems?: JsonFilter<"MeetingRecording">
    participants?: JsonFilter<"MeetingRecording">
    scheduledAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    startedAt?: DateTimeNullableFilter<"MeetingRecording"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MeetingRecording"> | Date | string | null
    duration?: IntNullableFilter<"MeetingRecording"> | number | null
    createdAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type MeetingRecordingOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    meetingPlatform?: SortOrder
    calendarEventId?: SortOrderInput | SortOrder
    status?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    actionItems?: SortOrder
    participants?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingRecordingCountOrderByAggregateInput
    _avg?: MeetingRecordingAvgOrderByAggregateInput
    _max?: MeetingRecordingMaxOrderByAggregateInput
    _min?: MeetingRecordingMinOrderByAggregateInput
    _sum?: MeetingRecordingSumOrderByAggregateInput
  }

  export type MeetingRecordingScalarWhereWithAggregatesInput = {
    AND?: MeetingRecordingScalarWhereWithAggregatesInput | MeetingRecordingScalarWhereWithAggregatesInput[]
    OR?: MeetingRecordingScalarWhereWithAggregatesInput[]
    NOT?: MeetingRecordingScalarWhereWithAggregatesInput | MeetingRecordingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeetingRecording"> | string
    agentId?: StringWithAggregatesFilter<"MeetingRecording"> | string
    title?: StringWithAggregatesFilter<"MeetingRecording"> | string
    meetingUrl?: StringNullableWithAggregatesFilter<"MeetingRecording"> | string | null
    meetingPlatform?: EnumMeetingPlatformWithAggregatesFilter<"MeetingRecording"> | $Enums.MeetingPlatform
    calendarEventId?: StringNullableWithAggregatesFilter<"MeetingRecording"> | string | null
    status?: EnumRecordingStatusWithAggregatesFilter<"MeetingRecording"> | $Enums.RecordingStatus
    recordingUrl?: StringNullableWithAggregatesFilter<"MeetingRecording"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"MeetingRecording"> | string | null
    summary?: StringNullableWithAggregatesFilter<"MeetingRecording"> | string | null
    actionItems?: JsonWithAggregatesFilter<"MeetingRecording">
    participants?: JsonWithAggregatesFilter<"MeetingRecording">
    scheduledAt?: DateTimeWithAggregatesFilter<"MeetingRecording"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"MeetingRecording"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"MeetingRecording"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"MeetingRecording"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MeetingRecording"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MeetingRecording"> | Date | string
  }

  export type AgentPhoneNumberWhereInput = {
    AND?: AgentPhoneNumberWhereInput | AgentPhoneNumberWhereInput[]
    OR?: AgentPhoneNumberWhereInput[]
    NOT?: AgentPhoneNumberWhereInput | AgentPhoneNumberWhereInput[]
    id?: StringFilter<"AgentPhoneNumber"> | string
    agentId?: StringFilter<"AgentPhoneNumber"> | string
    phoneNumber?: StringFilter<"AgentPhoneNumber"> | string
    twilioSid?: StringFilter<"AgentPhoneNumber"> | string
    voiceEnabled?: BoolFilter<"AgentPhoneNumber"> | boolean
    voiceGreeting?: StringNullableFilter<"AgentPhoneNumber"> | string | null
    createdAt?: DateTimeFilter<"AgentPhoneNumber"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    calls?: PhoneCallListRelationFilter
  }

  export type AgentPhoneNumberOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumber?: SortOrder
    twilioSid?: SortOrder
    voiceEnabled?: SortOrder
    voiceGreeting?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    calls?: PhoneCallOrderByRelationAggregateInput
  }

  export type AgentPhoneNumberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId?: string
    phoneNumber?: string
    twilioSid?: string
    AND?: AgentPhoneNumberWhereInput | AgentPhoneNumberWhereInput[]
    OR?: AgentPhoneNumberWhereInput[]
    NOT?: AgentPhoneNumberWhereInput | AgentPhoneNumberWhereInput[]
    voiceEnabled?: BoolFilter<"AgentPhoneNumber"> | boolean
    voiceGreeting?: StringNullableFilter<"AgentPhoneNumber"> | string | null
    createdAt?: DateTimeFilter<"AgentPhoneNumber"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    calls?: PhoneCallListRelationFilter
  }, "id" | "agentId" | "phoneNumber" | "twilioSid">

  export type AgentPhoneNumberOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumber?: SortOrder
    twilioSid?: SortOrder
    voiceEnabled?: SortOrder
    voiceGreeting?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AgentPhoneNumberCountOrderByAggregateInput
    _max?: AgentPhoneNumberMaxOrderByAggregateInput
    _min?: AgentPhoneNumberMinOrderByAggregateInput
  }

  export type AgentPhoneNumberScalarWhereWithAggregatesInput = {
    AND?: AgentPhoneNumberScalarWhereWithAggregatesInput | AgentPhoneNumberScalarWhereWithAggregatesInput[]
    OR?: AgentPhoneNumberScalarWhereWithAggregatesInput[]
    NOT?: AgentPhoneNumberScalarWhereWithAggregatesInput | AgentPhoneNumberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentPhoneNumber"> | string
    agentId?: StringWithAggregatesFilter<"AgentPhoneNumber"> | string
    phoneNumber?: StringWithAggregatesFilter<"AgentPhoneNumber"> | string
    twilioSid?: StringWithAggregatesFilter<"AgentPhoneNumber"> | string
    voiceEnabled?: BoolWithAggregatesFilter<"AgentPhoneNumber"> | boolean
    voiceGreeting?: StringNullableWithAggregatesFilter<"AgentPhoneNumber"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentPhoneNumber"> | Date | string
  }

  export type PhoneCallWhereInput = {
    AND?: PhoneCallWhereInput | PhoneCallWhereInput[]
    OR?: PhoneCallWhereInput[]
    NOT?: PhoneCallWhereInput | PhoneCallWhereInput[]
    id?: StringFilter<"PhoneCall"> | string
    phoneNumberId?: StringFilter<"PhoneCall"> | string
    direction?: EnumCallDirectionFilter<"PhoneCall"> | $Enums.CallDirection
    fromNumber?: StringFilter<"PhoneCall"> | string
    toNumber?: StringFilter<"PhoneCall"> | string
    status?: EnumCallStatusFilter<"PhoneCall"> | $Enums.CallStatus
    twilioCallSid?: StringNullableFilter<"PhoneCall"> | string | null
    recordingUrl?: StringNullableFilter<"PhoneCall"> | string | null
    transcript?: StringNullableFilter<"PhoneCall"> | string | null
    conversationId?: StringNullableFilter<"PhoneCall"> | string | null
    duration?: IntNullableFilter<"PhoneCall"> | number | null
    startedAt?: DateTimeFilter<"PhoneCall"> | Date | string
    endedAt?: DateTimeNullableFilter<"PhoneCall"> | Date | string | null
    phoneNumber?: XOR<AgentPhoneNumberScalarRelationFilter, AgentPhoneNumberWhereInput>
  }

  export type PhoneCallOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumberId?: SortOrder
    direction?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    status?: SortOrder
    twilioCallSid?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    conversationId?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    phoneNumber?: AgentPhoneNumberOrderByWithRelationInput
  }

  export type PhoneCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    twilioCallSid?: string
    AND?: PhoneCallWhereInput | PhoneCallWhereInput[]
    OR?: PhoneCallWhereInput[]
    NOT?: PhoneCallWhereInput | PhoneCallWhereInput[]
    phoneNumberId?: StringFilter<"PhoneCall"> | string
    direction?: EnumCallDirectionFilter<"PhoneCall"> | $Enums.CallDirection
    fromNumber?: StringFilter<"PhoneCall"> | string
    toNumber?: StringFilter<"PhoneCall"> | string
    status?: EnumCallStatusFilter<"PhoneCall"> | $Enums.CallStatus
    recordingUrl?: StringNullableFilter<"PhoneCall"> | string | null
    transcript?: StringNullableFilter<"PhoneCall"> | string | null
    conversationId?: StringNullableFilter<"PhoneCall"> | string | null
    duration?: IntNullableFilter<"PhoneCall"> | number | null
    startedAt?: DateTimeFilter<"PhoneCall"> | Date | string
    endedAt?: DateTimeNullableFilter<"PhoneCall"> | Date | string | null
    phoneNumber?: XOR<AgentPhoneNumberScalarRelationFilter, AgentPhoneNumberWhereInput>
  }, "id" | "twilioCallSid">

  export type PhoneCallOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumberId?: SortOrder
    direction?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    status?: SortOrder
    twilioCallSid?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    conversationId?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: PhoneCallCountOrderByAggregateInput
    _avg?: PhoneCallAvgOrderByAggregateInput
    _max?: PhoneCallMaxOrderByAggregateInput
    _min?: PhoneCallMinOrderByAggregateInput
    _sum?: PhoneCallSumOrderByAggregateInput
  }

  export type PhoneCallScalarWhereWithAggregatesInput = {
    AND?: PhoneCallScalarWhereWithAggregatesInput | PhoneCallScalarWhereWithAggregatesInput[]
    OR?: PhoneCallScalarWhereWithAggregatesInput[]
    NOT?: PhoneCallScalarWhereWithAggregatesInput | PhoneCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhoneCall"> | string
    phoneNumberId?: StringWithAggregatesFilter<"PhoneCall"> | string
    direction?: EnumCallDirectionWithAggregatesFilter<"PhoneCall"> | $Enums.CallDirection
    fromNumber?: StringWithAggregatesFilter<"PhoneCall"> | string
    toNumber?: StringWithAggregatesFilter<"PhoneCall"> | string
    status?: EnumCallStatusWithAggregatesFilter<"PhoneCall"> | $Enums.CallStatus
    twilioCallSid?: StringNullableWithAggregatesFilter<"PhoneCall"> | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"PhoneCall"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"PhoneCall"> | string | null
    conversationId?: StringNullableWithAggregatesFilter<"PhoneCall"> | string | null
    duration?: IntNullableWithAggregatesFilter<"PhoneCall"> | number | null
    startedAt?: DateTimeWithAggregatesFilter<"PhoneCall"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"PhoneCall"> | Date | string | null
  }

  export type AgentMetricWhereInput = {
    AND?: AgentMetricWhereInput | AgentMetricWhereInput[]
    OR?: AgentMetricWhereInput[]
    NOT?: AgentMetricWhereInput | AgentMetricWhereInput[]
    id?: StringFilter<"AgentMetric"> | string
    agentId?: StringFilter<"AgentMetric"> | string
    date?: DateTimeFilter<"AgentMetric"> | Date | string
    totalConversations?: IntFilter<"AgentMetric"> | number
    totalMessages?: IntFilter<"AgentMetric"> | number
    avgMessagesPerConvo?: FloatFilter<"AgentMetric"> | number
    avgResponseTimeMs?: IntFilter<"AgentMetric"> | number
    totalTokensUsed?: IntFilter<"AgentMetric"> | number
    toolCallsCount?: IntFilter<"AgentMetric"> | number
    toolSuccessRate?: FloatFilter<"AgentMetric"> | number
    feedbackPositive?: IntFilter<"AgentMetric"> | number
    feedbackNegative?: IntFilter<"AgentMetric"> | number
    createdAt?: DateTimeFilter<"AgentMetric"> | Date | string
    updatedAt?: DateTimeFilter<"AgentMetric"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentMetricOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_date?: AgentMetricAgentIdDateCompoundUniqueInput
    AND?: AgentMetricWhereInput | AgentMetricWhereInput[]
    OR?: AgentMetricWhereInput[]
    NOT?: AgentMetricWhereInput | AgentMetricWhereInput[]
    agentId?: StringFilter<"AgentMetric"> | string
    date?: DateTimeFilter<"AgentMetric"> | Date | string
    totalConversations?: IntFilter<"AgentMetric"> | number
    totalMessages?: IntFilter<"AgentMetric"> | number
    avgMessagesPerConvo?: FloatFilter<"AgentMetric"> | number
    avgResponseTimeMs?: IntFilter<"AgentMetric"> | number
    totalTokensUsed?: IntFilter<"AgentMetric"> | number
    toolCallsCount?: IntFilter<"AgentMetric"> | number
    toolSuccessRate?: FloatFilter<"AgentMetric"> | number
    feedbackPositive?: IntFilter<"AgentMetric"> | number
    feedbackNegative?: IntFilter<"AgentMetric"> | number
    createdAt?: DateTimeFilter<"AgentMetric"> | Date | string
    updatedAt?: DateTimeFilter<"AgentMetric"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId_date">

  export type AgentMetricOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentMetricCountOrderByAggregateInput
    _avg?: AgentMetricAvgOrderByAggregateInput
    _max?: AgentMetricMaxOrderByAggregateInput
    _min?: AgentMetricMinOrderByAggregateInput
    _sum?: AgentMetricSumOrderByAggregateInput
  }

  export type AgentMetricScalarWhereWithAggregatesInput = {
    AND?: AgentMetricScalarWhereWithAggregatesInput | AgentMetricScalarWhereWithAggregatesInput[]
    OR?: AgentMetricScalarWhereWithAggregatesInput[]
    NOT?: AgentMetricScalarWhereWithAggregatesInput | AgentMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentMetric"> | string
    agentId?: StringWithAggregatesFilter<"AgentMetric"> | string
    date?: DateTimeWithAggregatesFilter<"AgentMetric"> | Date | string
    totalConversations?: IntWithAggregatesFilter<"AgentMetric"> | number
    totalMessages?: IntWithAggregatesFilter<"AgentMetric"> | number
    avgMessagesPerConvo?: FloatWithAggregatesFilter<"AgentMetric"> | number
    avgResponseTimeMs?: IntWithAggregatesFilter<"AgentMetric"> | number
    totalTokensUsed?: IntWithAggregatesFilter<"AgentMetric"> | number
    toolCallsCount?: IntWithAggregatesFilter<"AgentMetric"> | number
    toolSuccessRate?: FloatWithAggregatesFilter<"AgentMetric"> | number
    feedbackPositive?: IntWithAggregatesFilter<"AgentMetric"> | number
    feedbackNegative?: IntWithAggregatesFilter<"AgentMetric"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgentMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentMetric"> | Date | string
  }

  export type ScanResultWhereInput = {
    AND?: ScanResultWhereInput | ScanResultWhereInput[]
    OR?: ScanResultWhereInput[]
    NOT?: ScanResultWhereInput | ScanResultWhereInput[]
    id?: StringFilter<"ScanResult"> | string
    userId?: StringFilter<"ScanResult"> | string
    workspaceId?: StringNullableFilter<"ScanResult"> | string | null
    category?: EnumScanCategoryFilter<"ScanResult"> | $Enums.ScanCategory
    signals?: JsonFilter<"ScanResult">
    totalSignals?: IntFilter<"ScanResult"> | number
    criticalCount?: IntFilter<"ScanResult"> | number
    highCount?: IntFilter<"ScanResult"> | number
    mediumCount?: IntFilter<"ScanResult"> | number
    lowCount?: IntFilter<"ScanResult"> | number
    scannedAt?: DateTimeFilter<"ScanResult"> | Date | string
  }

  export type ScanResultOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    category?: SortOrder
    signals?: SortOrder
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
    scannedAt?: SortOrder
  }

  export type ScanResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScanResultWhereInput | ScanResultWhereInput[]
    OR?: ScanResultWhereInput[]
    NOT?: ScanResultWhereInput | ScanResultWhereInput[]
    userId?: StringFilter<"ScanResult"> | string
    workspaceId?: StringNullableFilter<"ScanResult"> | string | null
    category?: EnumScanCategoryFilter<"ScanResult"> | $Enums.ScanCategory
    signals?: JsonFilter<"ScanResult">
    totalSignals?: IntFilter<"ScanResult"> | number
    criticalCount?: IntFilter<"ScanResult"> | number
    highCount?: IntFilter<"ScanResult"> | number
    mediumCount?: IntFilter<"ScanResult"> | number
    lowCount?: IntFilter<"ScanResult"> | number
    scannedAt?: DateTimeFilter<"ScanResult"> | Date | string
  }, "id">

  export type ScanResultOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    category?: SortOrder
    signals?: SortOrder
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
    scannedAt?: SortOrder
    _count?: ScanResultCountOrderByAggregateInput
    _avg?: ScanResultAvgOrderByAggregateInput
    _max?: ScanResultMaxOrderByAggregateInput
    _min?: ScanResultMinOrderByAggregateInput
    _sum?: ScanResultSumOrderByAggregateInput
  }

  export type ScanResultScalarWhereWithAggregatesInput = {
    AND?: ScanResultScalarWhereWithAggregatesInput | ScanResultScalarWhereWithAggregatesInput[]
    OR?: ScanResultScalarWhereWithAggregatesInput[]
    NOT?: ScanResultScalarWhereWithAggregatesInput | ScanResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScanResult"> | string
    userId?: StringWithAggregatesFilter<"ScanResult"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"ScanResult"> | string | null
    category?: EnumScanCategoryWithAggregatesFilter<"ScanResult"> | $Enums.ScanCategory
    signals?: JsonWithAggregatesFilter<"ScanResult">
    totalSignals?: IntWithAggregatesFilter<"ScanResult"> | number
    criticalCount?: IntWithAggregatesFilter<"ScanResult"> | number
    highCount?: IntWithAggregatesFilter<"ScanResult"> | number
    mediumCount?: IntWithAggregatesFilter<"ScanResult"> | number
    lowCount?: IntWithAggregatesFilter<"ScanResult"> | number
    scannedAt?: DateTimeWithAggregatesFilter<"ScanResult"> | Date | string
  }

  export type SignalWhereInput = {
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    id?: StringFilter<"Signal"> | string
    scanResultId?: StringFilter<"Signal"> | string
    type?: StringFilter<"Signal"> | string
    category?: EnumScanCategoryFilter<"Signal"> | $Enums.ScanCategory
    severity?: EnumSignalSeverityFilter<"Signal"> | $Enums.SignalSeverity
    source?: StringFilter<"Signal"> | string
    title?: StringFilter<"Signal"> | string
    description?: StringFilter<"Signal"> | string
    metadata?: JsonFilter<"Signal">
    suggestedTemplateId?: StringNullableFilter<"Signal"> | string | null
    snoozedUntil?: DateTimeNullableFilter<"Signal"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"Signal"> | Date | string | null
    actedOnAt?: DateTimeNullableFilter<"Signal"> | Date | string | null
    detectedAt?: DateTimeFilter<"Signal"> | Date | string
  }

  export type SignalOrderByWithRelationInput = {
    id?: SortOrder
    scanResultId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    source?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    suggestedTemplateId?: SortOrderInput | SortOrder
    snoozedUntil?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    actedOnAt?: SortOrderInput | SortOrder
    detectedAt?: SortOrder
  }

  export type SignalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    scanResultId?: StringFilter<"Signal"> | string
    type?: StringFilter<"Signal"> | string
    category?: EnumScanCategoryFilter<"Signal"> | $Enums.ScanCategory
    severity?: EnumSignalSeverityFilter<"Signal"> | $Enums.SignalSeverity
    source?: StringFilter<"Signal"> | string
    title?: StringFilter<"Signal"> | string
    description?: StringFilter<"Signal"> | string
    metadata?: JsonFilter<"Signal">
    suggestedTemplateId?: StringNullableFilter<"Signal"> | string | null
    snoozedUntil?: DateTimeNullableFilter<"Signal"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"Signal"> | Date | string | null
    actedOnAt?: DateTimeNullableFilter<"Signal"> | Date | string | null
    detectedAt?: DateTimeFilter<"Signal"> | Date | string
  }, "id">

  export type SignalOrderByWithAggregationInput = {
    id?: SortOrder
    scanResultId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    source?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    suggestedTemplateId?: SortOrderInput | SortOrder
    snoozedUntil?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    actedOnAt?: SortOrderInput | SortOrder
    detectedAt?: SortOrder
    _count?: SignalCountOrderByAggregateInput
    _max?: SignalMaxOrderByAggregateInput
    _min?: SignalMinOrderByAggregateInput
  }

  export type SignalScalarWhereWithAggregatesInput = {
    AND?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    OR?: SignalScalarWhereWithAggregatesInput[]
    NOT?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Signal"> | string
    scanResultId?: StringWithAggregatesFilter<"Signal"> | string
    type?: StringWithAggregatesFilter<"Signal"> | string
    category?: EnumScanCategoryWithAggregatesFilter<"Signal"> | $Enums.ScanCategory
    severity?: EnumSignalSeverityWithAggregatesFilter<"Signal"> | $Enums.SignalSeverity
    source?: StringWithAggregatesFilter<"Signal"> | string
    title?: StringWithAggregatesFilter<"Signal"> | string
    description?: StringWithAggregatesFilter<"Signal"> | string
    metadata?: JsonWithAggregatesFilter<"Signal">
    suggestedTemplateId?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    snoozedUntil?: DateTimeNullableWithAggregatesFilter<"Signal"> | Date | string | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"Signal"> | Date | string | null
    actedOnAt?: DateTimeNullableWithAggregatesFilter<"Signal"> | Date | string | null
    detectedAt?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
  }

  export type AgentRunWhereInput = {
    AND?: AgentRunWhereInput | AgentRunWhereInput[]
    OR?: AgentRunWhereInput[]
    NOT?: AgentRunWhereInput | AgentRunWhereInput[]
    id?: StringFilter<"AgentRun"> | string
    agentId?: StringFilter<"AgentRun"> | string
    userId?: StringFilter<"AgentRun"> | string
    workspaceId?: StringFilter<"AgentRun"> | string
    triggeredAt?: DateTimeFilter<"AgentRun"> | Date | string
    triggeredBy?: StringFilter<"AgentRun"> | string
    dataSources?: JsonFilter<"AgentRun">
    outputType?: StringNullableFilter<"AgentRun"> | string | null
    outputContent?: StringNullableFilter<"AgentRun"> | string | null
    llmModel?: StringFilter<"AgentRun"> | string
    llmTokensUsed?: IntFilter<"AgentRun"> | number
    llmCost?: FloatFilter<"AgentRun"> | number
    l1Assertions?: JsonFilter<"AgentRun">
    l1Passed?: BoolFilter<"AgentRun"> | boolean
    l2Score?: IntFilter<"AgentRun"> | number
    l2Breakdown?: JsonFilter<"AgentRun">
    l3Triggered?: BoolFilter<"AgentRun"> | boolean
    l3Blocked?: BoolNullableFilter<"AgentRun"> | boolean | null
    l3Reason?: StringNullableFilter<"AgentRun"> | string | null
    userAction?: StringNullableFilter<"AgentRun"> | string | null
    draftDiff?: StringNullableFilter<"AgentRun"> | string | null
    finalAction?: StringNullableFilter<"AgentRun"> | string | null
    finalAt?: DateTimeNullableFilter<"AgentRun"> | Date | string | null
    status?: StringFilter<"AgentRun"> | string
    createdAt?: DateTimeFilter<"AgentRun"> | Date | string
    updatedAt?: DateTimeFilter<"AgentRun"> | Date | string
  }

  export type AgentRunOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    dataSources?: SortOrder
    outputType?: SortOrderInput | SortOrder
    outputContent?: SortOrderInput | SortOrder
    llmModel?: SortOrder
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l1Assertions?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l2Breakdown?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrderInput | SortOrder
    l3Reason?: SortOrderInput | SortOrder
    userAction?: SortOrderInput | SortOrder
    draftDiff?: SortOrderInput | SortOrder
    finalAction?: SortOrderInput | SortOrder
    finalAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentRunWhereInput | AgentRunWhereInput[]
    OR?: AgentRunWhereInput[]
    NOT?: AgentRunWhereInput | AgentRunWhereInput[]
    agentId?: StringFilter<"AgentRun"> | string
    userId?: StringFilter<"AgentRun"> | string
    workspaceId?: StringFilter<"AgentRun"> | string
    triggeredAt?: DateTimeFilter<"AgentRun"> | Date | string
    triggeredBy?: StringFilter<"AgentRun"> | string
    dataSources?: JsonFilter<"AgentRun">
    outputType?: StringNullableFilter<"AgentRun"> | string | null
    outputContent?: StringNullableFilter<"AgentRun"> | string | null
    llmModel?: StringFilter<"AgentRun"> | string
    llmTokensUsed?: IntFilter<"AgentRun"> | number
    llmCost?: FloatFilter<"AgentRun"> | number
    l1Assertions?: JsonFilter<"AgentRun">
    l1Passed?: BoolFilter<"AgentRun"> | boolean
    l2Score?: IntFilter<"AgentRun"> | number
    l2Breakdown?: JsonFilter<"AgentRun">
    l3Triggered?: BoolFilter<"AgentRun"> | boolean
    l3Blocked?: BoolNullableFilter<"AgentRun"> | boolean | null
    l3Reason?: StringNullableFilter<"AgentRun"> | string | null
    userAction?: StringNullableFilter<"AgentRun"> | string | null
    draftDiff?: StringNullableFilter<"AgentRun"> | string | null
    finalAction?: StringNullableFilter<"AgentRun"> | string | null
    finalAt?: DateTimeNullableFilter<"AgentRun"> | Date | string | null
    status?: StringFilter<"AgentRun"> | string
    createdAt?: DateTimeFilter<"AgentRun"> | Date | string
    updatedAt?: DateTimeFilter<"AgentRun"> | Date | string
  }, "id">

  export type AgentRunOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    dataSources?: SortOrder
    outputType?: SortOrderInput | SortOrder
    outputContent?: SortOrderInput | SortOrder
    llmModel?: SortOrder
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l1Assertions?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l2Breakdown?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrderInput | SortOrder
    l3Reason?: SortOrderInput | SortOrder
    userAction?: SortOrderInput | SortOrder
    draftDiff?: SortOrderInput | SortOrder
    finalAction?: SortOrderInput | SortOrder
    finalAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentRunCountOrderByAggregateInput
    _avg?: AgentRunAvgOrderByAggregateInput
    _max?: AgentRunMaxOrderByAggregateInput
    _min?: AgentRunMinOrderByAggregateInput
    _sum?: AgentRunSumOrderByAggregateInput
  }

  export type AgentRunScalarWhereWithAggregatesInput = {
    AND?: AgentRunScalarWhereWithAggregatesInput | AgentRunScalarWhereWithAggregatesInput[]
    OR?: AgentRunScalarWhereWithAggregatesInput[]
    NOT?: AgentRunScalarWhereWithAggregatesInput | AgentRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentRun"> | string
    agentId?: StringWithAggregatesFilter<"AgentRun"> | string
    userId?: StringWithAggregatesFilter<"AgentRun"> | string
    workspaceId?: StringWithAggregatesFilter<"AgentRun"> | string
    triggeredAt?: DateTimeWithAggregatesFilter<"AgentRun"> | Date | string
    triggeredBy?: StringWithAggregatesFilter<"AgentRun"> | string
    dataSources?: JsonWithAggregatesFilter<"AgentRun">
    outputType?: StringNullableWithAggregatesFilter<"AgentRun"> | string | null
    outputContent?: StringNullableWithAggregatesFilter<"AgentRun"> | string | null
    llmModel?: StringWithAggregatesFilter<"AgentRun"> | string
    llmTokensUsed?: IntWithAggregatesFilter<"AgentRun"> | number
    llmCost?: FloatWithAggregatesFilter<"AgentRun"> | number
    l1Assertions?: JsonWithAggregatesFilter<"AgentRun">
    l1Passed?: BoolWithAggregatesFilter<"AgentRun"> | boolean
    l2Score?: IntWithAggregatesFilter<"AgentRun"> | number
    l2Breakdown?: JsonWithAggregatesFilter<"AgentRun">
    l3Triggered?: BoolWithAggregatesFilter<"AgentRun"> | boolean
    l3Blocked?: BoolNullableWithAggregatesFilter<"AgentRun"> | boolean | null
    l3Reason?: StringNullableWithAggregatesFilter<"AgentRun"> | string | null
    userAction?: StringNullableWithAggregatesFilter<"AgentRun"> | string | null
    draftDiff?: StringNullableWithAggregatesFilter<"AgentRun"> | string | null
    finalAction?: StringNullableWithAggregatesFilter<"AgentRun"> | string | null
    finalAt?: DateTimeNullableWithAggregatesFilter<"AgentRun"> | Date | string | null
    status?: StringWithAggregatesFilter<"AgentRun"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgentRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentRun"> | Date | string
  }

  export type AiEventWhereInput = {
    AND?: AiEventWhereInput | AiEventWhereInput[]
    OR?: AiEventWhereInput[]
    NOT?: AiEventWhereInput | AiEventWhereInput[]
    id?: StringFilter<"AiEvent"> | string
    traceId?: StringNullableFilter<"AiEvent"> | string | null
    agentId?: StringNullableFilter<"AiEvent"> | string | null
    conversationId?: StringNullableFilter<"AiEvent"> | string | null
    userId?: StringFilter<"AiEvent"> | string
    workspaceId?: StringNullableFilter<"AiEvent"> | string | null
    model?: StringFilter<"AiEvent"> | string
    tier?: StringFilter<"AiEvent"> | string
    tokensIn?: IntFilter<"AiEvent"> | number
    tokensOut?: IntFilter<"AiEvent"> | number
    cost?: FloatFilter<"AiEvent"> | number
    latencyMs?: IntFilter<"AiEvent"> | number
    stepNumber?: IntFilter<"AiEvent"> | number
    action?: StringFilter<"AiEvent"> | string
    toolName?: StringNullableFilter<"AiEvent"> | string | null
    toolInput?: JsonNullableFilter<"AiEvent">
    toolOutput?: JsonNullableFilter<"AiEvent">
    stepsUsed?: IntFilter<"AiEvent"> | number
    evalResult?: StringFilter<"AiEvent"> | string
    timestamp?: DateTimeFilter<"AiEvent"> | Date | string
    trace?: XOR<AgentTraceNullableScalarRelationFilter, AgentTraceWhereInput> | null
  }

  export type AiEventOrderByWithRelationInput = {
    id?: SortOrder
    traceId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    conversationId?: SortOrderInput | SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    model?: SortOrder
    tier?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    action?: SortOrder
    toolName?: SortOrderInput | SortOrder
    toolInput?: SortOrderInput | SortOrder
    toolOutput?: SortOrderInput | SortOrder
    stepsUsed?: SortOrder
    evalResult?: SortOrder
    timestamp?: SortOrder
    trace?: AgentTraceOrderByWithRelationInput
  }

  export type AiEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiEventWhereInput | AiEventWhereInput[]
    OR?: AiEventWhereInput[]
    NOT?: AiEventWhereInput | AiEventWhereInput[]
    traceId?: StringNullableFilter<"AiEvent"> | string | null
    agentId?: StringNullableFilter<"AiEvent"> | string | null
    conversationId?: StringNullableFilter<"AiEvent"> | string | null
    userId?: StringFilter<"AiEvent"> | string
    workspaceId?: StringNullableFilter<"AiEvent"> | string | null
    model?: StringFilter<"AiEvent"> | string
    tier?: StringFilter<"AiEvent"> | string
    tokensIn?: IntFilter<"AiEvent"> | number
    tokensOut?: IntFilter<"AiEvent"> | number
    cost?: FloatFilter<"AiEvent"> | number
    latencyMs?: IntFilter<"AiEvent"> | number
    stepNumber?: IntFilter<"AiEvent"> | number
    action?: StringFilter<"AiEvent"> | string
    toolName?: StringNullableFilter<"AiEvent"> | string | null
    toolInput?: JsonNullableFilter<"AiEvent">
    toolOutput?: JsonNullableFilter<"AiEvent">
    stepsUsed?: IntFilter<"AiEvent"> | number
    evalResult?: StringFilter<"AiEvent"> | string
    timestamp?: DateTimeFilter<"AiEvent"> | Date | string
    trace?: XOR<AgentTraceNullableScalarRelationFilter, AgentTraceWhereInput> | null
  }, "id">

  export type AiEventOrderByWithAggregationInput = {
    id?: SortOrder
    traceId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    conversationId?: SortOrderInput | SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    model?: SortOrder
    tier?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    action?: SortOrder
    toolName?: SortOrderInput | SortOrder
    toolInput?: SortOrderInput | SortOrder
    toolOutput?: SortOrderInput | SortOrder
    stepsUsed?: SortOrder
    evalResult?: SortOrder
    timestamp?: SortOrder
    _count?: AiEventCountOrderByAggregateInput
    _avg?: AiEventAvgOrderByAggregateInput
    _max?: AiEventMaxOrderByAggregateInput
    _min?: AiEventMinOrderByAggregateInput
    _sum?: AiEventSumOrderByAggregateInput
  }

  export type AiEventScalarWhereWithAggregatesInput = {
    AND?: AiEventScalarWhereWithAggregatesInput | AiEventScalarWhereWithAggregatesInput[]
    OR?: AiEventScalarWhereWithAggregatesInput[]
    NOT?: AiEventScalarWhereWithAggregatesInput | AiEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiEvent"> | string
    traceId?: StringNullableWithAggregatesFilter<"AiEvent"> | string | null
    agentId?: StringNullableWithAggregatesFilter<"AiEvent"> | string | null
    conversationId?: StringNullableWithAggregatesFilter<"AiEvent"> | string | null
    userId?: StringWithAggregatesFilter<"AiEvent"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"AiEvent"> | string | null
    model?: StringWithAggregatesFilter<"AiEvent"> | string
    tier?: StringWithAggregatesFilter<"AiEvent"> | string
    tokensIn?: IntWithAggregatesFilter<"AiEvent"> | number
    tokensOut?: IntWithAggregatesFilter<"AiEvent"> | number
    cost?: FloatWithAggregatesFilter<"AiEvent"> | number
    latencyMs?: IntWithAggregatesFilter<"AiEvent"> | number
    stepNumber?: IntWithAggregatesFilter<"AiEvent"> | number
    action?: StringWithAggregatesFilter<"AiEvent"> | string
    toolName?: StringNullableWithAggregatesFilter<"AiEvent"> | string | null
    toolInput?: JsonNullableWithAggregatesFilter<"AiEvent">
    toolOutput?: JsonNullableWithAggregatesFilter<"AiEvent">
    stepsUsed?: IntWithAggregatesFilter<"AiEvent"> | number
    evalResult?: StringWithAggregatesFilter<"AiEvent"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AiEvent"> | Date | string
  }

  export type AgentTraceWhereInput = {
    AND?: AgentTraceWhereInput | AgentTraceWhereInput[]
    OR?: AgentTraceWhereInput[]
    NOT?: AgentTraceWhereInput | AgentTraceWhereInput[]
    id?: StringFilter<"AgentTrace"> | string
    agentId?: StringFilter<"AgentTrace"> | string
    conversationId?: StringFilter<"AgentTrace"> | string
    userId?: StringFilter<"AgentTrace"> | string
    workspaceId?: StringFilter<"AgentTrace"> | string
    startedAt?: DateTimeFilter<"AgentTrace"> | Date | string
    completedAt?: DateTimeNullableFilter<"AgentTrace"> | Date | string | null
    status?: EnumTraceStatusFilter<"AgentTrace"> | $Enums.TraceStatus
    steps?: JsonFilter<"AgentTrace">
    totalSteps?: IntFilter<"AgentTrace"> | number
    maxSteps?: IntFilter<"AgentTrace"> | number
    totalTokensIn?: IntFilter<"AgentTrace"> | number
    totalTokensOut?: IntFilter<"AgentTrace"> | number
    totalCost?: FloatFilter<"AgentTrace"> | number
    latencyMs?: IntNullableFilter<"AgentTrace"> | number | null
    toolCalls?: JsonFilter<"AgentTrace">
    toolSuccesses?: IntFilter<"AgentTrace"> | number
    toolFailures?: IntFilter<"AgentTrace"> | number
    l1Passed?: BoolNullableFilter<"AgentTrace"> | boolean | null
    l1Failures?: JsonNullableFilter<"AgentTrace">
    l2Score?: FloatNullableFilter<"AgentTrace"> | number | null
    l2Breakdown?: JsonNullableFilter<"AgentTrace">
    l3Triggered?: BoolFilter<"AgentTrace"> | boolean
    l3Blocked?: BoolNullableFilter<"AgentTrace"> | boolean | null
    feedbackScore?: IntNullableFilter<"AgentTrace"> | number | null
    feedbackComment?: StringNullableFilter<"AgentTrace"> | string | null
    userEdited?: BoolFilter<"AgentTrace"> | boolean
    editDiff?: StringNullableFilter<"AgentTrace"> | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    aiEvents?: AiEventListRelationFilter
    feedbacks?: AgentFeedbackListRelationFilter
  }

  export type AgentTraceOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    steps?: SortOrder
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrderInput | SortOrder
    toolCalls?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l1Passed?: SortOrderInput | SortOrder
    l1Failures?: SortOrderInput | SortOrder
    l2Score?: SortOrderInput | SortOrder
    l2Breakdown?: SortOrderInput | SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    feedbackComment?: SortOrderInput | SortOrder
    userEdited?: SortOrder
    editDiff?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
    aiEvents?: AiEventOrderByRelationAggregateInput
    feedbacks?: AgentFeedbackOrderByRelationAggregateInput
  }

  export type AgentTraceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentTraceWhereInput | AgentTraceWhereInput[]
    OR?: AgentTraceWhereInput[]
    NOT?: AgentTraceWhereInput | AgentTraceWhereInput[]
    agentId?: StringFilter<"AgentTrace"> | string
    conversationId?: StringFilter<"AgentTrace"> | string
    userId?: StringFilter<"AgentTrace"> | string
    workspaceId?: StringFilter<"AgentTrace"> | string
    startedAt?: DateTimeFilter<"AgentTrace"> | Date | string
    completedAt?: DateTimeNullableFilter<"AgentTrace"> | Date | string | null
    status?: EnumTraceStatusFilter<"AgentTrace"> | $Enums.TraceStatus
    steps?: JsonFilter<"AgentTrace">
    totalSteps?: IntFilter<"AgentTrace"> | number
    maxSteps?: IntFilter<"AgentTrace"> | number
    totalTokensIn?: IntFilter<"AgentTrace"> | number
    totalTokensOut?: IntFilter<"AgentTrace"> | number
    totalCost?: FloatFilter<"AgentTrace"> | number
    latencyMs?: IntNullableFilter<"AgentTrace"> | number | null
    toolCalls?: JsonFilter<"AgentTrace">
    toolSuccesses?: IntFilter<"AgentTrace"> | number
    toolFailures?: IntFilter<"AgentTrace"> | number
    l1Passed?: BoolNullableFilter<"AgentTrace"> | boolean | null
    l1Failures?: JsonNullableFilter<"AgentTrace">
    l2Score?: FloatNullableFilter<"AgentTrace"> | number | null
    l2Breakdown?: JsonNullableFilter<"AgentTrace">
    l3Triggered?: BoolFilter<"AgentTrace"> | boolean
    l3Blocked?: BoolNullableFilter<"AgentTrace"> | boolean | null
    feedbackScore?: IntNullableFilter<"AgentTrace"> | number | null
    feedbackComment?: StringNullableFilter<"AgentTrace"> | string | null
    userEdited?: BoolFilter<"AgentTrace"> | boolean
    editDiff?: StringNullableFilter<"AgentTrace"> | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    aiEvents?: AiEventListRelationFilter
    feedbacks?: AgentFeedbackListRelationFilter
  }, "id">

  export type AgentTraceOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    steps?: SortOrder
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrderInput | SortOrder
    toolCalls?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l1Passed?: SortOrderInput | SortOrder
    l1Failures?: SortOrderInput | SortOrder
    l2Score?: SortOrderInput | SortOrder
    l2Breakdown?: SortOrderInput | SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    feedbackComment?: SortOrderInput | SortOrder
    userEdited?: SortOrder
    editDiff?: SortOrderInput | SortOrder
    _count?: AgentTraceCountOrderByAggregateInput
    _avg?: AgentTraceAvgOrderByAggregateInput
    _max?: AgentTraceMaxOrderByAggregateInput
    _min?: AgentTraceMinOrderByAggregateInput
    _sum?: AgentTraceSumOrderByAggregateInput
  }

  export type AgentTraceScalarWhereWithAggregatesInput = {
    AND?: AgentTraceScalarWhereWithAggregatesInput | AgentTraceScalarWhereWithAggregatesInput[]
    OR?: AgentTraceScalarWhereWithAggregatesInput[]
    NOT?: AgentTraceScalarWhereWithAggregatesInput | AgentTraceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentTrace"> | string
    agentId?: StringWithAggregatesFilter<"AgentTrace"> | string
    conversationId?: StringWithAggregatesFilter<"AgentTrace"> | string
    userId?: StringWithAggregatesFilter<"AgentTrace"> | string
    workspaceId?: StringWithAggregatesFilter<"AgentTrace"> | string
    startedAt?: DateTimeWithAggregatesFilter<"AgentTrace"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"AgentTrace"> | Date | string | null
    status?: EnumTraceStatusWithAggregatesFilter<"AgentTrace"> | $Enums.TraceStatus
    steps?: JsonWithAggregatesFilter<"AgentTrace">
    totalSteps?: IntWithAggregatesFilter<"AgentTrace"> | number
    maxSteps?: IntWithAggregatesFilter<"AgentTrace"> | number
    totalTokensIn?: IntWithAggregatesFilter<"AgentTrace"> | number
    totalTokensOut?: IntWithAggregatesFilter<"AgentTrace"> | number
    totalCost?: FloatWithAggregatesFilter<"AgentTrace"> | number
    latencyMs?: IntNullableWithAggregatesFilter<"AgentTrace"> | number | null
    toolCalls?: JsonWithAggregatesFilter<"AgentTrace">
    toolSuccesses?: IntWithAggregatesFilter<"AgentTrace"> | number
    toolFailures?: IntWithAggregatesFilter<"AgentTrace"> | number
    l1Passed?: BoolNullableWithAggregatesFilter<"AgentTrace"> | boolean | null
    l1Failures?: JsonNullableWithAggregatesFilter<"AgentTrace">
    l2Score?: FloatNullableWithAggregatesFilter<"AgentTrace"> | number | null
    l2Breakdown?: JsonNullableWithAggregatesFilter<"AgentTrace">
    l3Triggered?: BoolWithAggregatesFilter<"AgentTrace"> | boolean
    l3Blocked?: BoolNullableWithAggregatesFilter<"AgentTrace"> | boolean | null
    feedbackScore?: IntNullableWithAggregatesFilter<"AgentTrace"> | number | null
    feedbackComment?: StringNullableWithAggregatesFilter<"AgentTrace"> | string | null
    userEdited?: BoolWithAggregatesFilter<"AgentTrace"> | boolean
    editDiff?: StringNullableWithAggregatesFilter<"AgentTrace"> | string | null
  }

  export type ConversationEvaluationWhereInput = {
    AND?: ConversationEvaluationWhereInput | ConversationEvaluationWhereInput[]
    OR?: ConversationEvaluationWhereInput[]
    NOT?: ConversationEvaluationWhereInput | ConversationEvaluationWhereInput[]
    id?: StringFilter<"ConversationEvaluation"> | string
    conversationId?: StringFilter<"ConversationEvaluation"> | string
    evaluatedAt?: DateTimeFilter<"ConversationEvaluation"> | Date | string
    goalCompleted?: BoolFilter<"ConversationEvaluation"> | boolean
    goalCompletionConfidence?: FloatFilter<"ConversationEvaluation"> | number
    userSatisfactionScore?: FloatFilter<"ConversationEvaluation"> | number
    categories?: StringNullableListFilter<"ConversationEvaluation">
    failureModes?: StringNullableListFilter<"ConversationEvaluation">
    improvementSuggestions?: StringNullableListFilter<"ConversationEvaluation">
    metadata?: JsonFilter<"ConversationEvaluation">
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type ConversationEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    evaluatedAt?: SortOrder
    goalCompleted?: SortOrder
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
    categories?: SortOrder
    failureModes?: SortOrder
    improvementSuggestions?: SortOrder
    metadata?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId?: string
    AND?: ConversationEvaluationWhereInput | ConversationEvaluationWhereInput[]
    OR?: ConversationEvaluationWhereInput[]
    NOT?: ConversationEvaluationWhereInput | ConversationEvaluationWhereInput[]
    evaluatedAt?: DateTimeFilter<"ConversationEvaluation"> | Date | string
    goalCompleted?: BoolFilter<"ConversationEvaluation"> | boolean
    goalCompletionConfidence?: FloatFilter<"ConversationEvaluation"> | number
    userSatisfactionScore?: FloatFilter<"ConversationEvaluation"> | number
    categories?: StringNullableListFilter<"ConversationEvaluation">
    failureModes?: StringNullableListFilter<"ConversationEvaluation">
    improvementSuggestions?: StringNullableListFilter<"ConversationEvaluation">
    metadata?: JsonFilter<"ConversationEvaluation">
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id" | "conversationId">

  export type ConversationEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    evaluatedAt?: SortOrder
    goalCompleted?: SortOrder
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
    categories?: SortOrder
    failureModes?: SortOrder
    improvementSuggestions?: SortOrder
    metadata?: SortOrder
    _count?: ConversationEvaluationCountOrderByAggregateInput
    _avg?: ConversationEvaluationAvgOrderByAggregateInput
    _max?: ConversationEvaluationMaxOrderByAggregateInput
    _min?: ConversationEvaluationMinOrderByAggregateInput
    _sum?: ConversationEvaluationSumOrderByAggregateInput
  }

  export type ConversationEvaluationScalarWhereWithAggregatesInput = {
    AND?: ConversationEvaluationScalarWhereWithAggregatesInput | ConversationEvaluationScalarWhereWithAggregatesInput[]
    OR?: ConversationEvaluationScalarWhereWithAggregatesInput[]
    NOT?: ConversationEvaluationScalarWhereWithAggregatesInput | ConversationEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationEvaluation"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationEvaluation"> | string
    evaluatedAt?: DateTimeWithAggregatesFilter<"ConversationEvaluation"> | Date | string
    goalCompleted?: BoolWithAggregatesFilter<"ConversationEvaluation"> | boolean
    goalCompletionConfidence?: FloatWithAggregatesFilter<"ConversationEvaluation"> | number
    userSatisfactionScore?: FloatWithAggregatesFilter<"ConversationEvaluation"> | number
    categories?: StringNullableListFilter<"ConversationEvaluation">
    failureModes?: StringNullableListFilter<"ConversationEvaluation">
    improvementSuggestions?: StringNullableListFilter<"ConversationEvaluation">
    metadata?: JsonWithAggregatesFilter<"ConversationEvaluation">
  }

  export type AgentInsightWhereInput = {
    AND?: AgentInsightWhereInput | AgentInsightWhereInput[]
    OR?: AgentInsightWhereInput[]
    NOT?: AgentInsightWhereInput | AgentInsightWhereInput[]
    id?: StringFilter<"AgentInsight"> | string
    agentId?: StringFilter<"AgentInsight"> | string
    generatedAt?: DateTimeFilter<"AgentInsight"> | Date | string
    timeframeStart?: DateTimeFilter<"AgentInsight"> | Date | string
    timeframeEnd?: DateTimeFilter<"AgentInsight"> | Date | string
    clusters?: JsonFilter<"AgentInsight">
    patterns?: JsonFilter<"AgentInsight">
    anomalies?: JsonFilter<"AgentInsight">
    opportunities?: JsonFilter<"AgentInsight">
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentInsightOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    generatedAt?: SortOrder
    timeframeStart?: SortOrder
    timeframeEnd?: SortOrder
    clusters?: SortOrder
    patterns?: SortOrder
    anomalies?: SortOrder
    opportunities?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentInsightWhereInput | AgentInsightWhereInput[]
    OR?: AgentInsightWhereInput[]
    NOT?: AgentInsightWhereInput | AgentInsightWhereInput[]
    agentId?: StringFilter<"AgentInsight"> | string
    generatedAt?: DateTimeFilter<"AgentInsight"> | Date | string
    timeframeStart?: DateTimeFilter<"AgentInsight"> | Date | string
    timeframeEnd?: DateTimeFilter<"AgentInsight"> | Date | string
    clusters?: JsonFilter<"AgentInsight">
    patterns?: JsonFilter<"AgentInsight">
    anomalies?: JsonFilter<"AgentInsight">
    opportunities?: JsonFilter<"AgentInsight">
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentInsightOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    generatedAt?: SortOrder
    timeframeStart?: SortOrder
    timeframeEnd?: SortOrder
    clusters?: SortOrder
    patterns?: SortOrder
    anomalies?: SortOrder
    opportunities?: SortOrder
    _count?: AgentInsightCountOrderByAggregateInput
    _max?: AgentInsightMaxOrderByAggregateInput
    _min?: AgentInsightMinOrderByAggregateInput
  }

  export type AgentInsightScalarWhereWithAggregatesInput = {
    AND?: AgentInsightScalarWhereWithAggregatesInput | AgentInsightScalarWhereWithAggregatesInput[]
    OR?: AgentInsightScalarWhereWithAggregatesInput[]
    NOT?: AgentInsightScalarWhereWithAggregatesInput | AgentInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentInsight"> | string
    agentId?: StringWithAggregatesFilter<"AgentInsight"> | string
    generatedAt?: DateTimeWithAggregatesFilter<"AgentInsight"> | Date | string
    timeframeStart?: DateTimeWithAggregatesFilter<"AgentInsight"> | Date | string
    timeframeEnd?: DateTimeWithAggregatesFilter<"AgentInsight"> | Date | string
    clusters?: JsonWithAggregatesFilter<"AgentInsight">
    patterns?: JsonWithAggregatesFilter<"AgentInsight">
    anomalies?: JsonWithAggregatesFilter<"AgentInsight">
    opportunities?: JsonWithAggregatesFilter<"AgentInsight">
  }

  export type AgentFeedbackWhereInput = {
    AND?: AgentFeedbackWhereInput | AgentFeedbackWhereInput[]
    OR?: AgentFeedbackWhereInput[]
    NOT?: AgentFeedbackWhereInput | AgentFeedbackWhereInput[]
    id?: StringFilter<"AgentFeedback"> | string
    traceId?: StringFilter<"AgentFeedback"> | string
    conversationId?: StringFilter<"AgentFeedback"> | string
    userId?: StringFilter<"AgentFeedback"> | string
    agentId?: StringFilter<"AgentFeedback"> | string
    type?: EnumFeedbackTypeFilter<"AgentFeedback"> | $Enums.FeedbackType
    timestamp?: DateTimeFilter<"AgentFeedback"> | Date | string
    originalOutput?: StringFilter<"AgentFeedback"> | string
    userEdit?: StringNullableFilter<"AgentFeedback"> | string | null
    correctionText?: StringNullableFilter<"AgentFeedback"> | string | null
    stepNumber?: IntFilter<"AgentFeedback"> | number
    metadata?: JsonNullableFilter<"AgentFeedback">
    trace?: XOR<AgentTraceScalarRelationFilter, AgentTraceWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    traceId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    originalOutput?: SortOrder
    userEdit?: SortOrderInput | SortOrder
    correctionText?: SortOrderInput | SortOrder
    stepNumber?: SortOrder
    metadata?: SortOrderInput | SortOrder
    trace?: AgentTraceOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentFeedbackWhereInput | AgentFeedbackWhereInput[]
    OR?: AgentFeedbackWhereInput[]
    NOT?: AgentFeedbackWhereInput | AgentFeedbackWhereInput[]
    traceId?: StringFilter<"AgentFeedback"> | string
    conversationId?: StringFilter<"AgentFeedback"> | string
    userId?: StringFilter<"AgentFeedback"> | string
    agentId?: StringFilter<"AgentFeedback"> | string
    type?: EnumFeedbackTypeFilter<"AgentFeedback"> | $Enums.FeedbackType
    timestamp?: DateTimeFilter<"AgentFeedback"> | Date | string
    originalOutput?: StringFilter<"AgentFeedback"> | string
    userEdit?: StringNullableFilter<"AgentFeedback"> | string | null
    correctionText?: StringNullableFilter<"AgentFeedback"> | string | null
    stepNumber?: IntFilter<"AgentFeedback"> | number
    metadata?: JsonNullableFilter<"AgentFeedback">
    trace?: XOR<AgentTraceScalarRelationFilter, AgentTraceWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    traceId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    originalOutput?: SortOrder
    userEdit?: SortOrderInput | SortOrder
    correctionText?: SortOrderInput | SortOrder
    stepNumber?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: AgentFeedbackCountOrderByAggregateInput
    _avg?: AgentFeedbackAvgOrderByAggregateInput
    _max?: AgentFeedbackMaxOrderByAggregateInput
    _min?: AgentFeedbackMinOrderByAggregateInput
    _sum?: AgentFeedbackSumOrderByAggregateInput
  }

  export type AgentFeedbackScalarWhereWithAggregatesInput = {
    AND?: AgentFeedbackScalarWhereWithAggregatesInput | AgentFeedbackScalarWhereWithAggregatesInput[]
    OR?: AgentFeedbackScalarWhereWithAggregatesInput[]
    NOT?: AgentFeedbackScalarWhereWithAggregatesInput | AgentFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentFeedback"> | string
    traceId?: StringWithAggregatesFilter<"AgentFeedback"> | string
    conversationId?: StringWithAggregatesFilter<"AgentFeedback"> | string
    userId?: StringWithAggregatesFilter<"AgentFeedback"> | string
    agentId?: StringWithAggregatesFilter<"AgentFeedback"> | string
    type?: EnumFeedbackTypeWithAggregatesFilter<"AgentFeedback"> | $Enums.FeedbackType
    timestamp?: DateTimeWithAggregatesFilter<"AgentFeedback"> | Date | string
    originalOutput?: StringWithAggregatesFilter<"AgentFeedback"> | string
    userEdit?: StringNullableWithAggregatesFilter<"AgentFeedback"> | string | null
    correctionText?: StringNullableWithAggregatesFilter<"AgentFeedback"> | string | null
    stepNumber?: IntWithAggregatesFilter<"AgentFeedback"> | number
    metadata?: JsonNullableWithAggregatesFilter<"AgentFeedback">
  }

  export type AgentABTestWhereInput = {
    AND?: AgentABTestWhereInput | AgentABTestWhereInput[]
    OR?: AgentABTestWhereInput[]
    NOT?: AgentABTestWhereInput | AgentABTestWhereInput[]
    id?: StringFilter<"AgentABTest"> | string
    agentId?: StringFilter<"AgentABTest"> | string
    variantAPrompt?: StringFilter<"AgentABTest"> | string
    variantBPrompt?: StringFilter<"AgentABTest"> | string
    trafficSplit?: FloatFilter<"AgentABTest"> | number
    status?: EnumABTestStatusFilter<"AgentABTest"> | $Enums.ABTestStatus
    startedAt?: DateTimeFilter<"AgentABTest"> | Date | string
    endedAt?: DateTimeNullableFilter<"AgentABTest"> | Date | string | null
    variantATraces?: IntFilter<"AgentABTest"> | number
    variantBTraces?: IntFilter<"AgentABTest"> | number
    variantAScore?: FloatNullableFilter<"AgentABTest"> | number | null
    variantBScore?: FloatNullableFilter<"AgentABTest"> | number | null
    winningVariant?: StringNullableFilter<"AgentABTest"> | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentABTestOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    variantAPrompt?: SortOrder
    variantBPrompt?: SortOrder
    trafficSplit?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrderInput | SortOrder
    variantBScore?: SortOrderInput | SortOrder
    winningVariant?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentABTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentABTestWhereInput | AgentABTestWhereInput[]
    OR?: AgentABTestWhereInput[]
    NOT?: AgentABTestWhereInput | AgentABTestWhereInput[]
    agentId?: StringFilter<"AgentABTest"> | string
    variantAPrompt?: StringFilter<"AgentABTest"> | string
    variantBPrompt?: StringFilter<"AgentABTest"> | string
    trafficSplit?: FloatFilter<"AgentABTest"> | number
    status?: EnumABTestStatusFilter<"AgentABTest"> | $Enums.ABTestStatus
    startedAt?: DateTimeFilter<"AgentABTest"> | Date | string
    endedAt?: DateTimeNullableFilter<"AgentABTest"> | Date | string | null
    variantATraces?: IntFilter<"AgentABTest"> | number
    variantBTraces?: IntFilter<"AgentABTest"> | number
    variantAScore?: FloatNullableFilter<"AgentABTest"> | number | null
    variantBScore?: FloatNullableFilter<"AgentABTest"> | number | null
    winningVariant?: StringNullableFilter<"AgentABTest"> | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentABTestOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    variantAPrompt?: SortOrder
    variantBPrompt?: SortOrder
    trafficSplit?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrderInput | SortOrder
    variantBScore?: SortOrderInput | SortOrder
    winningVariant?: SortOrderInput | SortOrder
    _count?: AgentABTestCountOrderByAggregateInput
    _avg?: AgentABTestAvgOrderByAggregateInput
    _max?: AgentABTestMaxOrderByAggregateInput
    _min?: AgentABTestMinOrderByAggregateInput
    _sum?: AgentABTestSumOrderByAggregateInput
  }

  export type AgentABTestScalarWhereWithAggregatesInput = {
    AND?: AgentABTestScalarWhereWithAggregatesInput | AgentABTestScalarWhereWithAggregatesInput[]
    OR?: AgentABTestScalarWhereWithAggregatesInput[]
    NOT?: AgentABTestScalarWhereWithAggregatesInput | AgentABTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentABTest"> | string
    agentId?: StringWithAggregatesFilter<"AgentABTest"> | string
    variantAPrompt?: StringWithAggregatesFilter<"AgentABTest"> | string
    variantBPrompt?: StringWithAggregatesFilter<"AgentABTest"> | string
    trafficSplit?: FloatWithAggregatesFilter<"AgentABTest"> | number
    status?: EnumABTestStatusWithAggregatesFilter<"AgentABTest"> | $Enums.ABTestStatus
    startedAt?: DateTimeWithAggregatesFilter<"AgentABTest"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"AgentABTest"> | Date | string | null
    variantATraces?: IntWithAggregatesFilter<"AgentABTest"> | number
    variantBTraces?: IntWithAggregatesFilter<"AgentABTest"> | number
    variantAScore?: FloatNullableWithAggregatesFilter<"AgentABTest"> | number | null
    variantBScore?: FloatNullableWithAggregatesFilter<"AgentABTest"> | number | null
    winningVariant?: StringNullableWithAggregatesFilter<"AgentABTest"> | string | null
  }

  export type OptimizationRunWhereInput = {
    AND?: OptimizationRunWhereInput | OptimizationRunWhereInput[]
    OR?: OptimizationRunWhereInput[]
    NOT?: OptimizationRunWhereInput | OptimizationRunWhereInput[]
    id?: StringFilter<"OptimizationRun"> | string
    agentId?: StringFilter<"OptimizationRun"> | string
    triggeredAt?: DateTimeFilter<"OptimizationRun"> | Date | string
    triggeredBy?: StringFilter<"OptimizationRun"> | string
    editPatterns?: JsonFilter<"OptimizationRun">
    promptVariations?: JsonFilter<"OptimizationRun">
    testResults?: JsonFilter<"OptimizationRun">
    recommendation?: StringFilter<"OptimizationRun"> | string
    abTestId?: StringNullableFilter<"OptimizationRun"> | string | null
    status?: StringFilter<"OptimizationRun"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type OptimizationRunOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    editPatterns?: SortOrder
    promptVariations?: SortOrder
    testResults?: SortOrder
    recommendation?: SortOrder
    abTestId?: SortOrderInput | SortOrder
    status?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type OptimizationRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OptimizationRunWhereInput | OptimizationRunWhereInput[]
    OR?: OptimizationRunWhereInput[]
    NOT?: OptimizationRunWhereInput | OptimizationRunWhereInput[]
    agentId?: StringFilter<"OptimizationRun"> | string
    triggeredAt?: DateTimeFilter<"OptimizationRun"> | Date | string
    triggeredBy?: StringFilter<"OptimizationRun"> | string
    editPatterns?: JsonFilter<"OptimizationRun">
    promptVariations?: JsonFilter<"OptimizationRun">
    testResults?: JsonFilter<"OptimizationRun">
    recommendation?: StringFilter<"OptimizationRun"> | string
    abTestId?: StringNullableFilter<"OptimizationRun"> | string | null
    status?: StringFilter<"OptimizationRun"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type OptimizationRunOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    editPatterns?: SortOrder
    promptVariations?: SortOrder
    testResults?: SortOrder
    recommendation?: SortOrder
    abTestId?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: OptimizationRunCountOrderByAggregateInput
    _max?: OptimizationRunMaxOrderByAggregateInput
    _min?: OptimizationRunMinOrderByAggregateInput
  }

  export type OptimizationRunScalarWhereWithAggregatesInput = {
    AND?: OptimizationRunScalarWhereWithAggregatesInput | OptimizationRunScalarWhereWithAggregatesInput[]
    OR?: OptimizationRunScalarWhereWithAggregatesInput[]
    NOT?: OptimizationRunScalarWhereWithAggregatesInput | OptimizationRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptimizationRun"> | string
    agentId?: StringWithAggregatesFilter<"OptimizationRun"> | string
    triggeredAt?: DateTimeWithAggregatesFilter<"OptimizationRun"> | Date | string
    triggeredBy?: StringWithAggregatesFilter<"OptimizationRun"> | string
    editPatterns?: JsonWithAggregatesFilter<"OptimizationRun">
    promptVariations?: JsonWithAggregatesFilter<"OptimizationRun">
    testResults?: JsonWithAggregatesFilter<"OptimizationRun">
    recommendation?: StringWithAggregatesFilter<"OptimizationRun"> | string
    abTestId?: StringNullableWithAggregatesFilter<"OptimizationRun"> | string | null
    status?: StringWithAggregatesFilter<"OptimizationRun"> | string
  }

  export type ModificationProposalWhereInput = {
    AND?: ModificationProposalWhereInput | ModificationProposalWhereInput[]
    OR?: ModificationProposalWhereInput[]
    NOT?: ModificationProposalWhereInput | ModificationProposalWhereInput[]
    id?: StringFilter<"ModificationProposal"> | string
    agentId?: StringFilter<"ModificationProposal"> | string
    proposedAt?: DateTimeFilter<"ModificationProposal"> | Date | string
    type?: EnumModificationTypeFilter<"ModificationProposal"> | $Enums.ModificationType
    current?: StringFilter<"ModificationProposal"> | string
    proposed?: StringFilter<"ModificationProposal"> | string
    rationale?: StringFilter<"ModificationProposal"> | string
    impact?: StringFilter<"ModificationProposal"> | string
    status?: EnumProposalStatusFilter<"ModificationProposal"> | $Enums.ProposalStatus
    reviewedAt?: DateTimeNullableFilter<"ModificationProposal"> | Date | string | null
    reviewedBy?: StringNullableFilter<"ModificationProposal"> | string | null
    appliedAt?: DateTimeNullableFilter<"ModificationProposal"> | Date | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type ModificationProposalOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    proposedAt?: SortOrder
    type?: SortOrder
    current?: SortOrder
    proposed?: SortOrder
    rationale?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type ModificationProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModificationProposalWhereInput | ModificationProposalWhereInput[]
    OR?: ModificationProposalWhereInput[]
    NOT?: ModificationProposalWhereInput | ModificationProposalWhereInput[]
    agentId?: StringFilter<"ModificationProposal"> | string
    proposedAt?: DateTimeFilter<"ModificationProposal"> | Date | string
    type?: EnumModificationTypeFilter<"ModificationProposal"> | $Enums.ModificationType
    current?: StringFilter<"ModificationProposal"> | string
    proposed?: StringFilter<"ModificationProposal"> | string
    rationale?: StringFilter<"ModificationProposal"> | string
    impact?: StringFilter<"ModificationProposal"> | string
    status?: EnumProposalStatusFilter<"ModificationProposal"> | $Enums.ProposalStatus
    reviewedAt?: DateTimeNullableFilter<"ModificationProposal"> | Date | string | null
    reviewedBy?: StringNullableFilter<"ModificationProposal"> | string | null
    appliedAt?: DateTimeNullableFilter<"ModificationProposal"> | Date | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type ModificationProposalOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    proposedAt?: SortOrder
    type?: SortOrder
    current?: SortOrder
    proposed?: SortOrder
    rationale?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    _count?: ModificationProposalCountOrderByAggregateInput
    _max?: ModificationProposalMaxOrderByAggregateInput
    _min?: ModificationProposalMinOrderByAggregateInput
  }

  export type ModificationProposalScalarWhereWithAggregatesInput = {
    AND?: ModificationProposalScalarWhereWithAggregatesInput | ModificationProposalScalarWhereWithAggregatesInput[]
    OR?: ModificationProposalScalarWhereWithAggregatesInput[]
    NOT?: ModificationProposalScalarWhereWithAggregatesInput | ModificationProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModificationProposal"> | string
    agentId?: StringWithAggregatesFilter<"ModificationProposal"> | string
    proposedAt?: DateTimeWithAggregatesFilter<"ModificationProposal"> | Date | string
    type?: EnumModificationTypeWithAggregatesFilter<"ModificationProposal"> | $Enums.ModificationType
    current?: StringWithAggregatesFilter<"ModificationProposal"> | string
    proposed?: StringWithAggregatesFilter<"ModificationProposal"> | string
    rationale?: StringWithAggregatesFilter<"ModificationProposal"> | string
    impact?: StringWithAggregatesFilter<"ModificationProposal"> | string
    status?: EnumProposalStatusWithAggregatesFilter<"ModificationProposal"> | $Enums.ProposalStatus
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ModificationProposal"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"ModificationProposal"> | string | null
    appliedAt?: DateTimeNullableWithAggregatesFilter<"ModificationProposal"> | Date | string | null
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialsInput
    Node?: NodeCreateNestedManyWithoutCredentialInput
    agents?: AgentCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    Node?: NodeUncheckedCreateNestedManyWithoutCredentialInput
    agents?: AgentUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialsNestedInput
    Node?: NodeUpdateManyWithoutCredentialNestedInput
    agents?: AgentUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    Node?: NodeUncheckedUpdateManyWithoutCredentialNestedInput
    agents?: AgentUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialCreateManyInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: NodeCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolCreateNestedManyWithoutWorkflowInput
    user: UserCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionUncheckedCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: NodeUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUpdateManyWithoutWorkflowNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUncheckedUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NodeCreateInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    credential?: CredentialCreateNestedOneWithoutNodeInput
    outputConnections?: ConnectionCreateNestedManyWithoutFromNodeInput
    inputConnections?: ConnectionCreateNestedManyWithoutToNodeInput
  }

  export type NodeUncheckedCreateInput = {
    id?: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outputConnections?: ConnectionUncheckedCreateNestedManyWithoutFromNodeInput
    inputConnections?: ConnectionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type NodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    credential?: CredentialUpdateOneWithoutNodeNestedInput
    outputConnections?: ConnectionUpdateManyWithoutFromNodeNestedInput
    inputConnections?: ConnectionUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputConnections?: ConnectionUncheckedUpdateManyWithoutFromNodeNestedInput
    inputConnections?: ConnectionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type NodeCreateManyInput = {
    id?: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionCreateInput = {
    id?: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutConnectionsInput
    fromNode: NodeCreateNestedOneWithoutOutputConnectionsInput
    toNode: NodeCreateNestedOneWithoutInputConnectionsInput
  }

  export type ConnectionUncheckedCreateInput = {
    id?: string
    workflowId: string
    fromNodeId: string
    toNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutConnectionsNestedInput
    fromNode?: NodeUpdateOneRequiredWithoutOutputConnectionsNestedInput
    toNode?: NodeUpdateOneRequiredWithoutInputConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    toNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionCreateManyInput = {
    id?: string
    workflowId: string
    fromNodeId: string
    toNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    toNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutionCreateInput = {
    id?: string
    status?: $Enums.ExecutionStatus
    error?: string | null
    errorStack?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    inngestEventId: string
    output?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput
  }

  export type ExecutionUncheckedCreateInput = {
    id?: string
    workflowId: string
    status?: $Enums.ExecutionStatus
    error?: string | null
    errorStack?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    inngestEventId: string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type ExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionCreateManyInput = {
    id?: string
    workflowId: string
    status?: $Enums.ExecutionStatus
    error?: string | null
    errorStack?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    inngestEventId: string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentConnectionCreateInput = {
    id?: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceAgent: AgentCreateNestedOneWithoutConnectedToInput
    targetAgent: AgentCreateNestedOneWithoutConnectedFromInput
  }

  export type AgentConnectionUncheckedCreateInput = {
    id?: string
    sourceAgentId: string
    targetAgentId: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceAgent?: AgentUpdateOneRequiredWithoutConnectedToNestedInput
    targetAgent?: AgentUpdateOneRequiredWithoutConnectedFromNestedInput
  }

  export type AgentConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAgentId?: StringFieldUpdateOperationsInput | string
    targetAgentId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionCreateManyInput = {
    id?: string
    sourceAgentId: string
    targetAgentId: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAgentId?: StringFieldUpdateOperationsInput | string
    targetAgentId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentToolCreateInput = {
    id?: string
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAgentToolsInput
    workflow?: WorkflowCreateNestedOneWithoutAgentToolsInput
  }

  export type AgentToolUncheckedCreateInput = {
    id?: string
    agentId: string
    workflowId?: string | null
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentToolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAgentToolsNestedInput
    workflow?: WorkflowUpdateOneWithoutAgentToolsNestedInput
  }

  export type AgentToolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentToolCreateManyInput = {
    id?: string
    agentId: string
    workflowId?: string | null
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentToolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentToolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityCreateNestedManyWithoutConversationInput
    traces?: AgentTraceCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityUncheckedCreateNestedManyWithoutConversationInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: boolean
    confirmedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutActivitiesInput
  }

  export type ConversationActivityUncheckedCreateInput = {
    id?: string
    conversationId: string
    type: $Enums.ActivityType
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: boolean
    confirmedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConversationActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ConversationActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationActivityCreateManyInput = {
    id?: string
    conversationId: string
    type: $Enums.ActivityType
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: boolean
    confirmedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConversationActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMemoryCreateInput = {
    id?: string
    key: string
    value: string
    category?: $Enums.MemoryCategory
    embedding?: AgentMemoryCreateembeddingInput | number[]
    source?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutMemoriesInput
  }

  export type AgentMemoryUncheckedCreateInput = {
    id?: string
    agentId: string
    key: string
    value: string
    category?: $Enums.MemoryCategory
    embedding?: AgentMemoryCreateembeddingInput | number[]
    source?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMemoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutMemoriesNestedInput
  }

  export type AgentMemoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMemoryCreateManyInput = {
    id?: string
    agentId: string
    key: string
    value: string
    category?: $Enums.MemoryCategory
    embedding?: AgentMemoryCreateembeddingInput | number[]
    source?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMemoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMemoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeDocumentCreateInput = {
    id?: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutKnowledgeDocumentsInput
    chunks?: KnowledgeChunkCreateNestedManyWithoutDocumentInput
  }

  export type KnowledgeDocumentUncheckedCreateInput = {
    id?: string
    agentId: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: KnowledgeChunkUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type KnowledgeDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutKnowledgeDocumentsNestedInput
    chunks?: KnowledgeChunkUpdateManyWithoutDocumentNestedInput
  }

  export type KnowledgeDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: KnowledgeChunkUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type KnowledgeDocumentCreateManyInput = {
    id?: string
    agentId: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkCreateInput = {
    id?: string
    content: string
    embedding?: KnowledgeChunkCreateembeddingInput | number[]
    position: number
    pageNumber?: number | null
    heading?: string | null
    createdAt?: Date | string
    document: KnowledgeDocumentCreateNestedOneWithoutChunksInput
  }

  export type KnowledgeChunkUncheckedCreateInput = {
    id?: string
    documentId: string
    content: string
    embedding?: KnowledgeChunkCreateembeddingInput | number[]
    position: number
    pageNumber?: number | null
    heading?: string | null
    createdAt?: Date | string
  }

  export type KnowledgeChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: KnowledgeDocumentUpdateOneRequiredWithoutChunksNestedInput
  }

  export type KnowledgeChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkCreateManyInput = {
    id?: string
    documentId: string
    content: string
    embedding?: KnowledgeChunkCreateembeddingInput | number[]
    position: number
    pageNumber?: number | null
    heading?: string | null
    createdAt?: Date | string
  }

  export type KnowledgeChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeSettingsCreateInput = {
    id?: string
    searchFuzziness?: number
    maxResults?: number
    autoRefresh?: boolean
    refreshInterval?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutKnowledgeSettingsInput
  }

  export type KnowledgeSettingsUncheckedCreateInput = {
    id?: string
    agentId: string
    searchFuzziness?: number
    maxResults?: number
    autoRefresh?: boolean
    refreshInterval?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    searchFuzziness?: IntFieldUpdateOperationsInput | number
    maxResults?: IntFieldUpdateOperationsInput | number
    autoRefresh?: BoolFieldUpdateOperationsInput | boolean
    refreshInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutKnowledgeSettingsNestedInput
  }

  export type KnowledgeSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    searchFuzziness?: IntFieldUpdateOperationsInput | number
    maxResults?: IntFieldUpdateOperationsInput | number
    autoRefresh?: BoolFieldUpdateOperationsInput | boolean
    refreshInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeSettingsCreateManyInput = {
    id?: string
    agentId: string
    searchFuzziness?: number
    maxResults?: number
    autoRefresh?: boolean
    refreshInterval?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    searchFuzziness?: IntFieldUpdateOperationsInput | number
    maxResults?: IntFieldUpdateOperationsInput | number
    autoRefresh?: BoolFieldUpdateOperationsInput | boolean
    refreshInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    searchFuzziness?: IntFieldUpdateOperationsInput | number
    maxResults?: IntFieldUpdateOperationsInput | number
    autoRefresh?: BoolFieldUpdateOperationsInput | boolean
    refreshInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerCreateInput = {
    id?: string
    name: string
    type: $Enums.TriggerType
    enabled?: boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: string | null
    nextRunAt?: Date | string | null
    lastRunAt?: Date | string | null
    webhookSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutTriggersInput
  }

  export type AgentTriggerUncheckedCreateInput = {
    id?: string
    agentId: string
    name: string
    type: $Enums.TriggerType
    enabled?: boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: string | null
    nextRunAt?: Date | string | null
    lastRunAt?: Date | string | null
    webhookSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTriggerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutTriggersNestedInput
  }

  export type AgentTriggerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerCreateManyInput = {
    id?: string
    agentId: string
    name: string
    type: $Enums.TriggerType
    enabled?: boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: string | null
    nextRunAt?: Date | string | null
    lastRunAt?: Date | string | null
    webhookSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTriggerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTemplateCreateInput = {
    id?: string
    slug?: string | null
    name: string
    subtitle?: string | null
    description: string
    category: $Enums.TemplateCategory
    role?: $Enums.TemplateRole | null
    useCase?: $Enums.TemplateUseCase | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: string
    maxStepsPerRun?: number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateCreatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    color?: string | null
    coverImage?: string | null
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: string | null
    createdByName?: string | null
    usageCount?: number
    rating?: number
    reviewCount?: number
    tags?: AgentTemplateCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutTemplateInput
  }

  export type AgentTemplateUncheckedCreateInput = {
    id?: string
    slug?: string | null
    name: string
    subtitle?: string | null
    description: string
    category: $Enums.TemplateCategory
    role?: $Enums.TemplateRole | null
    useCase?: $Enums.TemplateUseCase | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: string
    maxStepsPerRun?: number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateCreatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    color?: string | null
    coverImage?: string | null
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: string | null
    createdByName?: string | null
    usageCount?: number
    rating?: number
    reviewCount?: number
    tags?: AgentTemplateCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type AgentTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTemplateCategoryFieldUpdateOperationsInput | $Enums.TemplateCategory
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    useCase?: NullableEnumTemplateUseCaseFieldUpdateOperationsInput | $Enums.TemplateUseCase | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: StringFieldUpdateOperationsInput | string
    maxStepsPerRun?: IntFieldUpdateOperationsInput | number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateUpdatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    tags?: AgentTemplateUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutTemplateNestedInput
  }

  export type AgentTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTemplateCategoryFieldUpdateOperationsInput | $Enums.TemplateCategory
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    useCase?: NullableEnumTemplateUseCaseFieldUpdateOperationsInput | $Enums.TemplateUseCase | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: StringFieldUpdateOperationsInput | string
    maxStepsPerRun?: IntFieldUpdateOperationsInput | number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateUpdatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    tags?: AgentTemplateUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type AgentTemplateCreateManyInput = {
    id?: string
    slug?: string | null
    name: string
    subtitle?: string | null
    description: string
    category: $Enums.TemplateCategory
    role?: $Enums.TemplateRole | null
    useCase?: $Enums.TemplateUseCase | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: string
    maxStepsPerRun?: number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateCreatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    color?: string | null
    coverImage?: string | null
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: string | null
    createdByName?: string | null
    usageCount?: number
    rating?: number
    reviewCount?: number
    tags?: AgentTemplateCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTemplateCategoryFieldUpdateOperationsInput | $Enums.TemplateCategory
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    useCase?: NullableEnumTemplateUseCaseFieldUpdateOperationsInput | $Enums.TemplateUseCase | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: StringFieldUpdateOperationsInput | string
    maxStepsPerRun?: IntFieldUpdateOperationsInput | number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateUpdatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    tags?: AgentTemplateUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTemplateCategoryFieldUpdateOperationsInput | $Enums.TemplateCategory
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    useCase?: NullableEnumTemplateUseCaseFieldUpdateOperationsInput | $Enums.TemplateUseCase | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: StringFieldUpdateOperationsInput | string
    maxStepsPerRun?: IntFieldUpdateOperationsInput | number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateUpdatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    tags?: AgentTemplateUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmbedCreateInput = {
    id?: string
    enabled?: boolean
    allowedDomains?: AgentEmbedCreateallowedDomainsInput | string[]
    displayName?: string | null
    welcomeMessage?: string | null
    logo?: string | null
    accentColor?: string
    backgroundColor?: string
    textColor?: string
    userBubbleColor?: string
    botBubbleColor?: string
    position?: $Enums.EmbedPosition
    buttonSize?: number
    windowWidth?: number
    windowHeight?: number
    autoOpen?: boolean
    autoOpenDelay?: number
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: string | null
    totalConversations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutEmbedInput
  }

  export type AgentEmbedUncheckedCreateInput = {
    id?: string
    agentId: string
    enabled?: boolean
    allowedDomains?: AgentEmbedCreateallowedDomainsInput | string[]
    displayName?: string | null
    welcomeMessage?: string | null
    logo?: string | null
    accentColor?: string
    backgroundColor?: string
    textColor?: string
    userBubbleColor?: string
    botBubbleColor?: string
    position?: $Enums.EmbedPosition
    buttonSize?: number
    windowWidth?: number
    windowHeight?: number
    autoOpen?: boolean
    autoOpenDelay?: number
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: string | null
    totalConversations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentEmbedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    allowedDomains?: AgentEmbedUpdateallowedDomainsInput | string[]
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    userBubbleColor?: StringFieldUpdateOperationsInput | string
    botBubbleColor?: StringFieldUpdateOperationsInput | string
    position?: EnumEmbedPositionFieldUpdateOperationsInput | $Enums.EmbedPosition
    buttonSize?: IntFieldUpdateOperationsInput | number
    windowWidth?: IntFieldUpdateOperationsInput | number
    windowHeight?: IntFieldUpdateOperationsInput | number
    autoOpen?: BoolFieldUpdateOperationsInput | boolean
    autoOpenDelay?: IntFieldUpdateOperationsInput | number
    showBranding?: BoolFieldUpdateOperationsInput | boolean
    collectEmail?: BoolFieldUpdateOperationsInput | boolean
    requireEmail?: BoolFieldUpdateOperationsInput | boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    totalConversations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutEmbedNestedInput
  }

  export type AgentEmbedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    allowedDomains?: AgentEmbedUpdateallowedDomainsInput | string[]
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    userBubbleColor?: StringFieldUpdateOperationsInput | string
    botBubbleColor?: StringFieldUpdateOperationsInput | string
    position?: EnumEmbedPositionFieldUpdateOperationsInput | $Enums.EmbedPosition
    buttonSize?: IntFieldUpdateOperationsInput | number
    windowWidth?: IntFieldUpdateOperationsInput | number
    windowHeight?: IntFieldUpdateOperationsInput | number
    autoOpen?: BoolFieldUpdateOperationsInput | boolean
    autoOpenDelay?: IntFieldUpdateOperationsInput | number
    showBranding?: BoolFieldUpdateOperationsInput | boolean
    collectEmail?: BoolFieldUpdateOperationsInput | boolean
    requireEmail?: BoolFieldUpdateOperationsInput | boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    totalConversations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmbedCreateManyInput = {
    id?: string
    agentId: string
    enabled?: boolean
    allowedDomains?: AgentEmbedCreateallowedDomainsInput | string[]
    displayName?: string | null
    welcomeMessage?: string | null
    logo?: string | null
    accentColor?: string
    backgroundColor?: string
    textColor?: string
    userBubbleColor?: string
    botBubbleColor?: string
    position?: $Enums.EmbedPosition
    buttonSize?: number
    windowWidth?: number
    windowHeight?: number
    autoOpen?: boolean
    autoOpenDelay?: number
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: string | null
    totalConversations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentEmbedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    allowedDomains?: AgentEmbedUpdateallowedDomainsInput | string[]
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    userBubbleColor?: StringFieldUpdateOperationsInput | string
    botBubbleColor?: StringFieldUpdateOperationsInput | string
    position?: EnumEmbedPositionFieldUpdateOperationsInput | $Enums.EmbedPosition
    buttonSize?: IntFieldUpdateOperationsInput | number
    windowWidth?: IntFieldUpdateOperationsInput | number
    windowHeight?: IntFieldUpdateOperationsInput | number
    autoOpen?: BoolFieldUpdateOperationsInput | boolean
    autoOpenDelay?: IntFieldUpdateOperationsInput | number
    showBranding?: BoolFieldUpdateOperationsInput | boolean
    collectEmail?: BoolFieldUpdateOperationsInput | boolean
    requireEmail?: BoolFieldUpdateOperationsInput | boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    totalConversations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmbedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    allowedDomains?: AgentEmbedUpdateallowedDomainsInput | string[]
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    userBubbleColor?: StringFieldUpdateOperationsInput | string
    botBubbleColor?: StringFieldUpdateOperationsInput | string
    position?: EnumEmbedPositionFieldUpdateOperationsInput | $Enums.EmbedPosition
    buttonSize?: IntFieldUpdateOperationsInput | number
    windowWidth?: IntFieldUpdateOperationsInput | number
    windowHeight?: IntFieldUpdateOperationsInput | number
    autoOpen?: BoolFieldUpdateOperationsInput | boolean
    autoOpenDelay?: IntFieldUpdateOperationsInput | number
    showBranding?: BoolFieldUpdateOperationsInput | boolean
    collectEmail?: BoolFieldUpdateOperationsInput | boolean
    requireEmail?: BoolFieldUpdateOperationsInput | boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    totalConversations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmailAddressCreateInput = {
    id?: string
    localPart: string
    domain?: string
    autoReply?: boolean
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutEmailAddressInput
  }

  export type AgentEmailAddressUncheckedCreateInput = {
    id?: string
    agentId: string
    localPart: string
    domain?: string
    autoReply?: boolean
    createdAt?: Date | string
  }

  export type AgentEmailAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutEmailAddressNestedInput
  }

  export type AgentEmailAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmailAddressCreateManyInput = {
    id?: string
    agentId: string
    localPart: string
    domain?: string
    autoReply?: boolean
    createdAt?: Date | string
  }

  export type AgentEmailAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmailAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    accountEmail?: string | null
    accountName?: string | null
    scopes?: IntegrationCreatescopesInput | string[]
    teamId?: string | null
    teamName?: string | null
    botUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    accountEmail?: string | null
    accountName?: string | null
    scopes?: IntegrationCreatescopesInput | string[]
    teamId?: string | null
    teamName?: string | null
    botUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    accountEmail?: string | null
    accountName?: string | null
    scopes?: IntegrationCreatescopesInput | string[]
    teamId?: string | null
    teamName?: string | null
    botUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentSwarmCreateInput = {
    id?: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutSwarmsInput
    tasks?: SwarmTaskCreateNestedManyWithoutSwarmInput
  }

  export type AgentSwarmUncheckedCreateInput = {
    id?: string
    agentId: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: SwarmTaskUncheckedCreateNestedManyWithoutSwarmInput
  }

  export type AgentSwarmUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutSwarmsNestedInput
    tasks?: SwarmTaskUpdateManyWithoutSwarmNestedInput
  }

  export type AgentSwarmUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: SwarmTaskUncheckedUpdateManyWithoutSwarmNestedInput
  }

  export type AgentSwarmCreateManyInput = {
    id?: string
    agentId: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentSwarmUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentSwarmUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwarmTaskCreateInput = {
    id?: string
    input: JsonNullValueInput | InputJsonValue
    status?: $Enums.SwarmTaskStatus
    output?: string | null
    error?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    swarm: AgentSwarmCreateNestedOneWithoutTasksInput
  }

  export type SwarmTaskUncheckedCreateInput = {
    id?: string
    swarmId: string
    input: JsonNullValueInput | InputJsonValue
    status?: $Enums.SwarmTaskStatus
    output?: string | null
    error?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SwarmTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    swarm?: AgentSwarmUpdateOneRequiredWithoutTasksNestedInput
  }

  export type SwarmTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    swarmId?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwarmTaskCreateManyInput = {
    id?: string
    swarmId: string
    input: JsonNullValueInput | InputJsonValue
    status?: $Enums.SwarmTaskStatus
    output?: string | null
    error?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SwarmTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwarmTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    swarmId?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingCreateInput = {
    id?: string
    title: string
    meetingUrl?: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId?: string | null
    status?: $Enums.RecordingStatus
    recordingUrl?: string | null
    transcript?: string | null
    summary?: string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutMeetingRecordingsInput
  }

  export type MeetingRecordingUncheckedCreateInput = {
    id?: string
    agentId: string
    title: string
    meetingUrl?: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId?: string | null
    status?: $Enums.RecordingStatus
    recordingUrl?: string | null
    transcript?: string | null
    summary?: string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingRecordingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutMeetingRecordingsNestedInput
  }

  export type MeetingRecordingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingCreateManyInput = {
    id?: string
    agentId: string
    title: string
    meetingUrl?: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId?: string | null
    status?: $Enums.RecordingStatus
    recordingUrl?: string | null
    transcript?: string | null
    summary?: string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingRecordingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentPhoneNumberCreateInput = {
    id?: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutPhoneNumberInput
    calls?: PhoneCallCreateNestedManyWithoutPhoneNumberInput
  }

  export type AgentPhoneNumberUncheckedCreateInput = {
    id?: string
    agentId: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
    calls?: PhoneCallUncheckedCreateNestedManyWithoutPhoneNumberInput
  }

  export type AgentPhoneNumberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutPhoneNumberNestedInput
    calls?: PhoneCallUpdateManyWithoutPhoneNumberNestedInput
  }

  export type AgentPhoneNumberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calls?: PhoneCallUncheckedUpdateManyWithoutPhoneNumberNestedInput
  }

  export type AgentPhoneNumberCreateManyInput = {
    id?: string
    agentId: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
  }

  export type AgentPhoneNumberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentPhoneNumberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCallCreateInput = {
    id?: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status?: $Enums.CallStatus
    twilioCallSid?: string | null
    recordingUrl?: string | null
    transcript?: string | null
    conversationId?: string | null
    duration?: number | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    phoneNumber: AgentPhoneNumberCreateNestedOneWithoutCallsInput
  }

  export type PhoneCallUncheckedCreateInput = {
    id?: string
    phoneNumberId: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status?: $Enums.CallStatus
    twilioCallSid?: string | null
    recordingUrl?: string | null
    transcript?: string | null
    conversationId?: string | null
    duration?: number | null
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type PhoneCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: AgentPhoneNumberUpdateOneRequiredWithoutCallsNestedInput
  }

  export type PhoneCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PhoneCallCreateManyInput = {
    id?: string
    phoneNumberId: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status?: $Enums.CallStatus
    twilioCallSid?: string | null
    recordingUrl?: string | null
    transcript?: string | null
    conversationId?: string | null
    duration?: number | null
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type PhoneCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PhoneCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentMetricCreateInput = {
    id?: string
    date: Date | string
    totalConversations?: number
    totalMessages?: number
    avgMessagesPerConvo?: number
    avgResponseTimeMs?: number
    totalTokensUsed?: number
    toolCallsCount?: number
    toolSuccessRate?: number
    feedbackPositive?: number
    feedbackNegative?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutMetricsInput
  }

  export type AgentMetricUncheckedCreateInput = {
    id?: string
    agentId: string
    date: Date | string
    totalConversations?: number
    totalMessages?: number
    avgMessagesPerConvo?: number
    avgResponseTimeMs?: number
    totalTokensUsed?: number
    toolCallsCount?: number
    toolSuccessRate?: number
    feedbackPositive?: number
    feedbackNegative?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type AgentMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMetricCreateManyInput = {
    id?: string
    agentId: string
    date: Date | string
    totalConversations?: number
    totalMessages?: number
    avgMessagesPerConvo?: number
    avgResponseTimeMs?: number
    totalTokensUsed?: number
    toolCallsCount?: number
    toolSuccessRate?: number
    feedbackPositive?: number
    feedbackNegative?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScanResultCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    category: $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: number
    criticalCount?: number
    highCount?: number
    mediumCount?: number
    lowCount?: number
    scannedAt?: Date | string
  }

  export type ScanResultUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    category: $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: number
    criticalCount?: number
    highCount?: number
    mediumCount?: number
    lowCount?: number
    scannedAt?: Date | string
  }

  export type ScanResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: IntFieldUpdateOperationsInput | number
    criticalCount?: IntFieldUpdateOperationsInput | number
    highCount?: IntFieldUpdateOperationsInput | number
    mediumCount?: IntFieldUpdateOperationsInput | number
    lowCount?: IntFieldUpdateOperationsInput | number
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScanResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: IntFieldUpdateOperationsInput | number
    criticalCount?: IntFieldUpdateOperationsInput | number
    highCount?: IntFieldUpdateOperationsInput | number
    mediumCount?: IntFieldUpdateOperationsInput | number
    lowCount?: IntFieldUpdateOperationsInput | number
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScanResultCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    category: $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: number
    criticalCount?: number
    highCount?: number
    mediumCount?: number
    lowCount?: number
    scannedAt?: Date | string
  }

  export type ScanResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: IntFieldUpdateOperationsInput | number
    criticalCount?: IntFieldUpdateOperationsInput | number
    highCount?: IntFieldUpdateOperationsInput | number
    mediumCount?: IntFieldUpdateOperationsInput | number
    lowCount?: IntFieldUpdateOperationsInput | number
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScanResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    signals?: JsonNullValueInput | InputJsonValue
    totalSignals?: IntFieldUpdateOperationsInput | number
    criticalCount?: IntFieldUpdateOperationsInput | number
    highCount?: IntFieldUpdateOperationsInput | number
    mediumCount?: IntFieldUpdateOperationsInput | number
    lowCount?: IntFieldUpdateOperationsInput | number
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalCreateInput = {
    id?: string
    scanResultId: string
    type: string
    category: $Enums.ScanCategory
    severity: $Enums.SignalSeverity
    source: string
    title: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: string | null
    snoozedUntil?: Date | string | null
    dismissedAt?: Date | string | null
    actedOnAt?: Date | string | null
    detectedAt?: Date | string
  }

  export type SignalUncheckedCreateInput = {
    id?: string
    scanResultId: string
    type: string
    category: $Enums.ScanCategory
    severity: $Enums.SignalSeverity
    source: string
    title: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: string | null
    snoozedUntil?: Date | string | null
    dismissedAt?: Date | string | null
    actedOnAt?: Date | string | null
    detectedAt?: Date | string
  }

  export type SignalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanResultId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    severity?: EnumSignalSeverityFieldUpdateOperationsInput | $Enums.SignalSeverity
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actedOnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanResultId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    severity?: EnumSignalSeverityFieldUpdateOperationsInput | $Enums.SignalSeverity
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actedOnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalCreateManyInput = {
    id?: string
    scanResultId: string
    type: string
    category: $Enums.ScanCategory
    severity: $Enums.SignalSeverity
    source: string
    title: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: string | null
    snoozedUntil?: Date | string | null
    dismissedAt?: Date | string | null
    actedOnAt?: Date | string | null
    detectedAt?: Date | string
  }

  export type SignalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanResultId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    severity?: EnumSignalSeverityFieldUpdateOperationsInput | $Enums.SignalSeverity
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actedOnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanResultId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: EnumScanCategoryFieldUpdateOperationsInput | $Enums.ScanCategory
    severity?: EnumSignalSeverityFieldUpdateOperationsInput | $Enums.SignalSeverity
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    suggestedTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actedOnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRunCreateInput = {
    id?: string
    agentId: string
    userId: string
    workspaceId: string
    triggeredAt?: Date | string
    triggeredBy: string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: string | null
    outputContent?: string | null
    llmModel: string
    llmTokensUsed?: number
    llmCost?: number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: boolean
    l2Score?: number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    l3Reason?: string | null
    userAction?: string | null
    draftDiff?: string | null
    finalAction?: string | null
    finalAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRunUncheckedCreateInput = {
    id?: string
    agentId: string
    userId: string
    workspaceId: string
    triggeredAt?: Date | string
    triggeredBy: string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: string | null
    outputContent?: string | null
    llmModel: string
    llmTokensUsed?: number
    llmCost?: number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: boolean
    l2Score?: number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    l3Reason?: string | null
    userAction?: string | null
    draftDiff?: string | null
    finalAction?: string | null
    finalAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: NullableStringFieldUpdateOperationsInput | string | null
    outputContent?: NullableStringFieldUpdateOperationsInput | string | null
    llmModel?: StringFieldUpdateOperationsInput | string
    llmTokensUsed?: IntFieldUpdateOperationsInput | number
    llmCost?: FloatFieldUpdateOperationsInput | number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: BoolFieldUpdateOperationsInput | boolean
    l2Score?: IntFieldUpdateOperationsInput | number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l3Reason?: NullableStringFieldUpdateOperationsInput | string | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    draftDiff?: NullableStringFieldUpdateOperationsInput | string | null
    finalAction?: NullableStringFieldUpdateOperationsInput | string | null
    finalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: NullableStringFieldUpdateOperationsInput | string | null
    outputContent?: NullableStringFieldUpdateOperationsInput | string | null
    llmModel?: StringFieldUpdateOperationsInput | string
    llmTokensUsed?: IntFieldUpdateOperationsInput | number
    llmCost?: FloatFieldUpdateOperationsInput | number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: BoolFieldUpdateOperationsInput | boolean
    l2Score?: IntFieldUpdateOperationsInput | number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l3Reason?: NullableStringFieldUpdateOperationsInput | string | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    draftDiff?: NullableStringFieldUpdateOperationsInput | string | null
    finalAction?: NullableStringFieldUpdateOperationsInput | string | null
    finalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRunCreateManyInput = {
    id?: string
    agentId: string
    userId: string
    workspaceId: string
    triggeredAt?: Date | string
    triggeredBy: string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: string | null
    outputContent?: string | null
    llmModel: string
    llmTokensUsed?: number
    llmCost?: number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: boolean
    l2Score?: number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    l3Reason?: string | null
    userAction?: string | null
    draftDiff?: string | null
    finalAction?: string | null
    finalAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: NullableStringFieldUpdateOperationsInput | string | null
    outputContent?: NullableStringFieldUpdateOperationsInput | string | null
    llmModel?: StringFieldUpdateOperationsInput | string
    llmTokensUsed?: IntFieldUpdateOperationsInput | number
    llmCost?: FloatFieldUpdateOperationsInput | number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: BoolFieldUpdateOperationsInput | boolean
    l2Score?: IntFieldUpdateOperationsInput | number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l3Reason?: NullableStringFieldUpdateOperationsInput | string | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    draftDiff?: NullableStringFieldUpdateOperationsInput | string | null
    finalAction?: NullableStringFieldUpdateOperationsInput | string | null
    finalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    dataSources?: JsonNullValueInput | InputJsonValue
    outputType?: NullableStringFieldUpdateOperationsInput | string | null
    outputContent?: NullableStringFieldUpdateOperationsInput | string | null
    llmModel?: StringFieldUpdateOperationsInput | string
    llmTokensUsed?: IntFieldUpdateOperationsInput | number
    llmCost?: FloatFieldUpdateOperationsInput | number
    l1Assertions?: JsonNullValueInput | InputJsonValue
    l1Passed?: BoolFieldUpdateOperationsInput | boolean
    l2Score?: IntFieldUpdateOperationsInput | number
    l2Breakdown?: JsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l3Reason?: NullableStringFieldUpdateOperationsInput | string | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    draftDiff?: NullableStringFieldUpdateOperationsInput | string | null
    finalAction?: NullableStringFieldUpdateOperationsInput | string | null
    finalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiEventCreateInput = {
    id?: string
    agentId?: string | null
    conversationId?: string | null
    userId: string
    workspaceId?: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber?: number
    action: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: number
    evalResult?: string
    timestamp?: Date | string
    trace?: AgentTraceCreateNestedOneWithoutAiEventsInput
  }

  export type AiEventUncheckedCreateInput = {
    id?: string
    traceId?: string | null
    agentId?: string | null
    conversationId?: string | null
    userId: string
    workspaceId?: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber?: number
    action: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: number
    evalResult?: string
    timestamp?: Date | string
  }

  export type AiEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    trace?: AgentTraceUpdateOneWithoutAiEventsNestedInput
  }

  export type AiEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiEventCreateManyInput = {
    id?: string
    traceId?: string | null
    agentId?: string | null
    conversationId?: string | null
    userId: string
    workspaceId?: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber?: number
    action: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: number
    evalResult?: string
    timestamp?: Date | string
  }

  export type AiEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTraceCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    agent: AgentCreateNestedOneWithoutTracesInput
    conversation: ConversationCreateNestedOneWithoutTracesInput
    aiEvents?: AiEventCreateNestedManyWithoutTraceInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceUncheckedCreateInput = {
    id?: string
    agentId: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    aiEvents?: AiEventUncheckedCreateNestedManyWithoutTraceInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutTracesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutTracesNestedInput
    aiEvents?: AiEventUpdateManyWithoutTraceNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    aiEvents?: AiEventUncheckedUpdateManyWithoutTraceNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceCreateManyInput = {
    id?: string
    agentId: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
  }

  export type AgentTraceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentTraceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationEvaluationCreateInput = {
    id?: string
    evaluatedAt?: Date | string
    goalCompleted: boolean
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories?: ConversationEvaluationCreatecategoriesInput | string[]
    failureModes?: ConversationEvaluationCreatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationCreateimprovementSuggestionsInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutEvaluationInput
  }

  export type ConversationEvaluationUncheckedCreateInput = {
    id?: string
    conversationId: string
    evaluatedAt?: Date | string
    goalCompleted: boolean
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories?: ConversationEvaluationCreatecategoriesInput | string[]
    failureModes?: ConversationEvaluationCreatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationCreateimprovementSuggestionsInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalCompleted?: BoolFieldUpdateOperationsInput | boolean
    goalCompletionConfidence?: FloatFieldUpdateOperationsInput | number
    userSatisfactionScore?: FloatFieldUpdateOperationsInput | number
    categories?: ConversationEvaluationUpdatecategoriesInput | string[]
    failureModes?: ConversationEvaluationUpdatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationUpdateimprovementSuggestionsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutEvaluationNestedInput
  }

  export type ConversationEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    evaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalCompleted?: BoolFieldUpdateOperationsInput | boolean
    goalCompletionConfidence?: FloatFieldUpdateOperationsInput | number
    userSatisfactionScore?: FloatFieldUpdateOperationsInput | number
    categories?: ConversationEvaluationUpdatecategoriesInput | string[]
    failureModes?: ConversationEvaluationUpdatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationUpdateimprovementSuggestionsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationCreateManyInput = {
    id?: string
    conversationId: string
    evaluatedAt?: Date | string
    goalCompleted: boolean
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories?: ConversationEvaluationCreatecategoriesInput | string[]
    failureModes?: ConversationEvaluationCreatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationCreateimprovementSuggestionsInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalCompleted?: BoolFieldUpdateOperationsInput | boolean
    goalCompletionConfidence?: FloatFieldUpdateOperationsInput | number
    userSatisfactionScore?: FloatFieldUpdateOperationsInput | number
    categories?: ConversationEvaluationUpdatecategoriesInput | string[]
    failureModes?: ConversationEvaluationUpdatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationUpdateimprovementSuggestionsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    evaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalCompleted?: BoolFieldUpdateOperationsInput | boolean
    goalCompletionConfidence?: FloatFieldUpdateOperationsInput | number
    userSatisfactionScore?: FloatFieldUpdateOperationsInput | number
    categories?: ConversationEvaluationUpdatecategoriesInput | string[]
    failureModes?: ConversationEvaluationUpdatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationUpdateimprovementSuggestionsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightCreateInput = {
    id?: string
    generatedAt?: Date | string
    timeframeStart: Date | string
    timeframeEnd: Date | string
    clusters: JsonNullValueInput | InputJsonValue
    patterns: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    opportunities: JsonNullValueInput | InputJsonValue
    agent: AgentCreateNestedOneWithoutInsightsInput
  }

  export type AgentInsightUncheckedCreateInput = {
    id?: string
    agentId: string
    generatedAt?: Date | string
    timeframeStart: Date | string
    timeframeEnd: Date | string
    clusters: JsonNullValueInput | InputJsonValue
    patterns: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    opportunities: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
    agent?: AgentUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type AgentInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightCreateManyInput = {
    id?: string
    agentId: string
    generatedAt?: Date | string
    timeframeStart: Date | string
    timeframeEnd: Date | string
    clusters: JsonNullValueInput | InputJsonValue
    patterns: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    opportunities: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackCreateInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    trace: AgentTraceCreateNestedOneWithoutFeedbacksInput
    conversation: ConversationCreateNestedOneWithoutFeedbacksInput
    agent: AgentCreateNestedOneWithoutFeedbacksInput
  }

  export type AgentFeedbackUncheckedCreateInput = {
    id?: string
    traceId: string
    conversationId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    trace?: AgentTraceUpdateOneRequiredWithoutFeedbacksNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutFeedbacksNestedInput
    agent?: AgentUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type AgentFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackCreateManyInput = {
    id?: string
    traceId: string
    conversationId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentABTestCreateInput = {
    id?: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit?: number
    status: $Enums.ABTestStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    variantATraces?: number
    variantBTraces?: number
    variantAScore?: number | null
    variantBScore?: number | null
    winningVariant?: string | null
    agent: AgentCreateNestedOneWithoutAbTestsInput
  }

  export type AgentABTestUncheckedCreateInput = {
    id?: string
    agentId: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit?: number
    status: $Enums.ABTestStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    variantATraces?: number
    variantBTraces?: number
    variantAScore?: number | null
    variantBScore?: number | null
    winningVariant?: string | null
  }

  export type AgentABTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutAbTestsNestedInput
  }

  export type AgentABTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentABTestCreateManyInput = {
    id?: string
    agentId: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit?: number
    status: $Enums.ABTestStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    variantATraces?: number
    variantBTraces?: number
    variantAScore?: number | null
    variantBScore?: number | null
    winningVariant?: string | null
  }

  export type AgentABTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentABTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OptimizationRunCreateInput = {
    id?: string
    triggeredAt?: Date | string
    triggeredBy: string
    editPatterns: JsonNullValueInput | InputJsonValue
    promptVariations: JsonNullValueInput | InputJsonValue
    testResults: JsonNullValueInput | InputJsonValue
    recommendation: string
    abTestId?: string | null
    status: string
    agent: AgentCreateNestedOneWithoutOptimizationRunsInput
  }

  export type OptimizationRunUncheckedCreateInput = {
    id?: string
    agentId: string
    triggeredAt?: Date | string
    triggeredBy: string
    editPatterns: JsonNullValueInput | InputJsonValue
    promptVariations: JsonNullValueInput | InputJsonValue
    testResults: JsonNullValueInput | InputJsonValue
    recommendation: string
    abTestId?: string | null
    status: string
  }

  export type OptimizationRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    agent?: AgentUpdateOneRequiredWithoutOptimizationRunsNestedInput
  }

  export type OptimizationRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OptimizationRunCreateManyInput = {
    id?: string
    agentId: string
    triggeredAt?: Date | string
    triggeredBy: string
    editPatterns: JsonNullValueInput | InputJsonValue
    promptVariations: JsonNullValueInput | InputJsonValue
    testResults: JsonNullValueInput | InputJsonValue
    recommendation: string
    abTestId?: string | null
    status: string
  }

  export type OptimizationRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OptimizationRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ModificationProposalCreateInput = {
    id?: string
    proposedAt?: Date | string
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status?: $Enums.ProposalStatus
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    appliedAt?: Date | string | null
    agent: AgentCreateNestedOneWithoutModificationProposalsInput
  }

  export type ModificationProposalUncheckedCreateInput = {
    id?: string
    agentId: string
    proposedAt?: Date | string
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status?: $Enums.ProposalStatus
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    appliedAt?: Date | string | null
  }

  export type ModificationProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: AgentUpdateOneRequiredWithoutModificationProposalsNestedInput
  }

  export type ModificationProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModificationProposalCreateManyInput = {
    id?: string
    agentId: string
    proposedAt?: Date | string
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status?: $Enums.ProposalStatus
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    appliedAt?: Date | string | null
  }

  export type ModificationProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModificationProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type CredentialListRelationFilter = {
    every?: CredentialWhereInput
    some?: CredentialWhereInput
    none?: CredentialWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCredentialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeFilter<$PrismaModel> | $Enums.CredentialType
  }

  export type NodeListRelationFilter = {
    every?: NodeWhereInput
    some?: NodeWhereInput
    none?: NodeWhereInput
  }

  export type NodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CredentialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CredentialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumCredentialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel> | $Enums.CredentialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialTypeFilter<$PrismaModel>
    _max?: NestedEnumCredentialTypeFilter<$PrismaModel>
  }

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput
    some?: ConnectionWhereInput
    none?: ConnectionWhereInput
  }

  export type ExecutionListRelationFilter = {
    every?: ExecutionWhereInput
    some?: ExecutionWhereInput
    none?: ExecutionWhereInput
  }

  export type AgentToolListRelationFilter = {
    every?: AgentToolWhereInput
    some?: AgentToolWhereInput
    none?: AgentToolWhereInput
  }

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentToolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeFilter<$PrismaModel> | $Enums.NodeType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorkflowScalarRelationFilter = {
    is?: WorkflowWhereInput
    isNot?: WorkflowWhereInput
  }

  export type CredentialNullableScalarRelationFilter = {
    is?: CredentialWhereInput | null
    isNot?: CredentialWhereInput | null
  }

  export type NodeCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    data?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.NodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type NodeScalarRelationFilter = {
    is?: NodeWhereInput
    isNot?: NodeWhereInput
  }

  export type ConnectionFromNodeIdToNodeIdFromOutputToInputCompoundUniqueInput = {
    fromNodeId: string
    toNodeId: string
    fromOutput: string
    toInput: string
  }

  export type ConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    fromOutput?: SortOrder
    toInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    fromOutput?: SortOrder
    toInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    fromOutput?: SortOrder
    toInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExecutionStatusFilter<$PrismaModel> | $Enums.ExecutionStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    errorStack?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    inngestEventId?: SortOrder
    output?: SortOrder
  }

  export type ExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    errorStack?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    inngestEventId?: SortOrder
  }

  export type ExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    errorStack?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    inngestEventId?: SortOrder
  }

  export type EnumExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumExecutionStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAgentModelFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentModel | EnumAgentModelFieldRefInput<$PrismaModel>
    in?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentModelFilter<$PrismaModel> | $Enums.AgentModel
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AgentTemplateNullableScalarRelationFilter = {
    is?: AgentTemplateWhereInput | null
    isNot?: AgentTemplateWhereInput | null
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type AgentMemoryListRelationFilter = {
    every?: AgentMemoryWhereInput
    some?: AgentMemoryWhereInput
    none?: AgentMemoryWhereInput
  }

  export type KnowledgeDocumentListRelationFilter = {
    every?: KnowledgeDocumentWhereInput
    some?: KnowledgeDocumentWhereInput
    none?: KnowledgeDocumentWhereInput
  }

  export type KnowledgeSettingsNullableScalarRelationFilter = {
    is?: KnowledgeSettingsWhereInput | null
    isNot?: KnowledgeSettingsWhereInput | null
  }

  export type AgentTriggerListRelationFilter = {
    every?: AgentTriggerWhereInput
    some?: AgentTriggerWhereInput
    none?: AgentTriggerWhereInput
  }

  export type AgentEmbedNullableScalarRelationFilter = {
    is?: AgentEmbedWhereInput | null
    isNot?: AgentEmbedWhereInput | null
  }

  export type AgentConnectionListRelationFilter = {
    every?: AgentConnectionWhereInput
    some?: AgentConnectionWhereInput
    none?: AgentConnectionWhereInput
  }

  export type AgentSwarmListRelationFilter = {
    every?: AgentSwarmWhereInput
    some?: AgentSwarmWhereInput
    none?: AgentSwarmWhereInput
  }

  export type AgentEmailAddressNullableScalarRelationFilter = {
    is?: AgentEmailAddressWhereInput | null
    isNot?: AgentEmailAddressWhereInput | null
  }

  export type MeetingRecordingListRelationFilter = {
    every?: MeetingRecordingWhereInput
    some?: MeetingRecordingWhereInput
    none?: MeetingRecordingWhereInput
  }

  export type AgentPhoneNumberNullableScalarRelationFilter = {
    is?: AgentPhoneNumberWhereInput | null
    isNot?: AgentPhoneNumberWhereInput | null
  }

  export type AgentMetricListRelationFilter = {
    every?: AgentMetricWhereInput
    some?: AgentMetricWhereInput
    none?: AgentMetricWhereInput
  }

  export type AgentTraceListRelationFilter = {
    every?: AgentTraceWhereInput
    some?: AgentTraceWhereInput
    none?: AgentTraceWhereInput
  }

  export type AgentInsightListRelationFilter = {
    every?: AgentInsightWhereInput
    some?: AgentInsightWhereInput
    none?: AgentInsightWhereInput
  }

  export type AgentFeedbackListRelationFilter = {
    every?: AgentFeedbackWhereInput
    some?: AgentFeedbackWhereInput
    none?: AgentFeedbackWhereInput
  }

  export type AgentABTestListRelationFilter = {
    every?: AgentABTestWhereInput
    some?: AgentABTestWhereInput
    none?: AgentABTestWhereInput
  }

  export type OptimizationRunListRelationFilter = {
    every?: OptimizationRunWhereInput
    some?: OptimizationRunWhereInput
    none?: OptimizationRunWhereInput
  }

  export type ModificationProposalListRelationFilter = {
    every?: ModificationProposalWhereInput
    some?: ModificationProposalWhereInput
    none?: ModificationProposalWhereInput
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentMemoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentTriggerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentSwarmOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingRecordingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentTraceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentABTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptimizationRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModificationProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    safeMode?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    evalRules?: SortOrder
    workspaceId?: SortOrder
    avatar?: SortOrder
    tags?: SortOrder
    isFavorite?: SortOrder
    isEnabled?: SortOrder
    templateId?: SortOrder
    flowData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    temperature?: SortOrder
    maxStepsPerRun?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    safeMode?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    workspaceId?: SortOrder
    avatar?: SortOrder
    isFavorite?: SortOrder
    isEnabled?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    safeMode?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    workspaceId?: SortOrder
    avatar?: SortOrder
    isFavorite?: SortOrder
    isEnabled?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    temperature?: SortOrder
    maxStepsPerRun?: SortOrder
  }

  export type EnumAgentModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentModel | EnumAgentModelFieldRefInput<$PrismaModel>
    in?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentModelWithAggregatesFilter<$PrismaModel> | $Enums.AgentModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentModelFilter<$PrismaModel>
    _max?: NestedEnumAgentModelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type AgentConnectionSourceAgentIdTargetAgentIdCompoundUniqueInput = {
    sourceAgentId: string
    targetAgentId: string
  }

  export type AgentConnectionSourceAgentIdAliasCompoundUniqueInput = {
    sourceAgentId: string
    alias: string
  }

  export type AgentConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    sourceAgentId?: SortOrder
    targetAgentId?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceAgentId?: SortOrder
    targetAgentId?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    sourceAgentId?: SortOrder
    targetAgentId?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowNullableScalarRelationFilter = {
    is?: WorkflowWhereInput | null
    isNot?: WorkflowWhereInput | null
  }

  export type AgentToolAgentIdWorkflowIdCompoundUniqueInput = {
    agentId: string
    workflowId: string
  }

  export type AgentToolCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    workflowId?: SortOrder
    composioAppKey?: SortOrder
    composioActionName?: SortOrder
    composioConfig?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentToolMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    workflowId?: SortOrder
    composioAppKey?: SortOrder
    composioActionName?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentToolMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    workflowId?: SortOrder
    composioAppKey?: SortOrder
    composioActionName?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConversationSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationSource | EnumConversationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationSourceFilter<$PrismaModel> | $Enums.ConversationSource
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationActivityListRelationFilter = {
    every?: ConversationActivityWhereInput
    some?: ConversationActivityWhereInput
    none?: ConversationActivityWhereInput
  }

  export type ConversationEvaluationNullableScalarRelationFilter = {
    is?: ConversationEvaluationWhereInput | null
    isNot?: ConversationEvaluationWhereInput | null
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    agentId?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    shareToken?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    agentId?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    shareToken?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    agentId?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    shareToken?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConversationSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationSource | EnumConversationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationSourceWithAggregatesFilter<$PrismaModel> | $Enums.ConversationSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationSourceFilter<$PrismaModel>
    _max?: NestedEnumConversationSourceFilter<$PrismaModel>
  }

  export type EnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type ConversationActivityCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    details?: SortOrder
    requiresConfirmation?: SortOrder
    confirmedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    requiresConfirmation?: SortOrder
    confirmedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationActivityMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    requiresConfirmation?: SortOrder
    confirmedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumMemoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MemoryCategory | EnumMemoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMemoryCategoryFilter<$PrismaModel> | $Enums.MemoryCategory
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AgentMemoryAgentIdKeyCompoundUniqueInput = {
    agentId: string
    key: string
  }

  export type AgentMemoryCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    embedding?: SortOrder
    source?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMemoryAvgOrderByAggregateInput = {
    embedding?: SortOrder
  }

  export type AgentMemoryMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    source?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMemoryMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    source?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMemorySumOrderByAggregateInput = {
    embedding?: SortOrder
  }

  export type EnumMemoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemoryCategory | EnumMemoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMemoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MemoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumMemoryCategoryFilter<$PrismaModel>
  }

  export type EnumKnowledgeSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSourceType | EnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSourceTypeFilter<$PrismaModel> | $Enums.KnowledgeSourceType
  }

  export type EnumKnowledgeSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSyncStatus | EnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSyncStatusFilter<$PrismaModel> | $Enums.KnowledgeSyncStatus
  }

  export type KnowledgeChunkListRelationFilter = {
    every?: KnowledgeChunkWhereInput
    some?: KnowledgeChunkWhereInput
    none?: KnowledgeChunkWhereInput
  }

  export type KnowledgeChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    sourceType?: SortOrder
    externalId?: SortOrder
    externalUrl?: SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrder
    syncError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type KnowledgeDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    sourceType?: SortOrder
    externalId?: SortOrder
    externalUrl?: SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrder
    syncError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    sourceType?: SortOrder
    externalId?: SortOrder
    externalUrl?: SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrder
    syncError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumKnowledgeSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSourceType | EnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeSourceTypeFilter<$PrismaModel>
  }

  export type EnumKnowledgeSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSyncStatus | EnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeSyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeSyncStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type KnowledgeDocumentScalarRelationFilter = {
    is?: KnowledgeDocumentWhereInput
    isNot?: KnowledgeDocumentWhereInput
  }

  export type KnowledgeChunkCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    content?: SortOrder
    embedding?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrder
    heading?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeChunkAvgOrderByAggregateInput = {
    embedding?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrder
  }

  export type KnowledgeChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    content?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrder
    heading?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeChunkMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    content?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrder
    heading?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeChunkSumOrderByAggregateInput = {
    embedding?: SortOrder
    position?: SortOrder
    pageNumber?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type KnowledgeSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    autoRefresh?: SortOrder
    refreshInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeSettingsAvgOrderByAggregateInput = {
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    refreshInterval?: SortOrder
  }

  export type KnowledgeSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    autoRefresh?: SortOrder
    refreshInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    autoRefresh?: SortOrder
    refreshInterval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeSettingsSumOrderByAggregateInput = {
    searchFuzziness?: SortOrder
    maxResults?: SortOrder
    refreshInterval?: SortOrder
  }

  export type EnumTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeFilter<$PrismaModel> | $Enums.TriggerType
  }

  export type AgentTriggerCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    config?: SortOrder
    cronExpression?: SortOrder
    nextRunAt?: SortOrder
    lastRunAt?: SortOrder
    webhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTriggerMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    cronExpression?: SortOrder
    nextRunAt?: SortOrder
    lastRunAt?: SortOrder
    webhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTriggerMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    cronExpression?: SortOrder
    nextRunAt?: SortOrder
    lastRunAt?: SortOrder
    webhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeFilter<$PrismaModel>
  }

  export type EnumTemplateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateCategory | EnumTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTemplateCategoryFilter<$PrismaModel> | $Enums.TemplateCategory
  }

  export type EnumTemplateRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableFilter<$PrismaModel> | $Enums.TemplateRole | null
  }

  export type EnumTemplateUseCaseNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateUseCase | EnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateUseCaseNullableFilter<$PrismaModel> | $Enums.TemplateUseCase | null
  }

  export type AgentTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    category?: SortOrder
    role?: SortOrder
    useCase?: SortOrder
    systemPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    trigger?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    fetchSources?: SortOrder
    actions?: SortOrder
    evalRules?: SortOrder
    suggestedTools?: SortOrder
    suggestedTriggers?: SortOrder
    suggestedIntegrations?: SortOrder
    flowData?: SortOrder
    defaultTriggers?: SortOrder
    defaultTools?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    coverImage?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    createdById?: SortOrder
    createdByName?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTemplateAvgOrderByAggregateInput = {
    temperature?: SortOrder
    maxStepsPerRun?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type AgentTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    category?: SortOrder
    role?: SortOrder
    useCase?: SortOrder
    systemPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    coverImage?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    createdById?: SortOrder
    createdByName?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    category?: SortOrder
    role?: SortOrder
    useCase?: SortOrder
    systemPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    llmTier?: SortOrder
    maxStepsPerRun?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    coverImage?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    createdById?: SortOrder
    createdByName?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTemplateSumOrderByAggregateInput = {
    temperature?: SortOrder
    maxStepsPerRun?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type EnumTemplateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateCategory | EnumTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTemplateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TemplateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTemplateCategoryFilter<$PrismaModel>
    _max?: NestedEnumTemplateCategoryFilter<$PrismaModel>
  }

  export type EnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemplateRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
  }

  export type EnumTemplateUseCaseNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateUseCase | EnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateUseCaseNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemplateUseCase | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemplateUseCaseNullableFilter<$PrismaModel>
    _max?: NestedEnumTemplateUseCaseNullableFilter<$PrismaModel>
  }

  export type EnumEmbedPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbedPosition | EnumEmbedPositionFieldRefInput<$PrismaModel>
    in?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbedPositionFilter<$PrismaModel> | $Enums.EmbedPosition
  }

  export type AgentEmbedCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    enabled?: SortOrder
    allowedDomains?: SortOrder
    displayName?: SortOrder
    welcomeMessage?: SortOrder
    logo?: SortOrder
    accentColor?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    userBubbleColor?: SortOrder
    botBubbleColor?: SortOrder
    position?: SortOrder
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpen?: SortOrder
    autoOpenDelay?: SortOrder
    showBranding?: SortOrder
    collectEmail?: SortOrder
    requireEmail?: SortOrder
    conversationStarters?: SortOrder
    customCss?: SortOrder
    totalConversations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentEmbedAvgOrderByAggregateInput = {
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpenDelay?: SortOrder
    totalConversations?: SortOrder
  }

  export type AgentEmbedMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    enabled?: SortOrder
    displayName?: SortOrder
    welcomeMessage?: SortOrder
    logo?: SortOrder
    accentColor?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    userBubbleColor?: SortOrder
    botBubbleColor?: SortOrder
    position?: SortOrder
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpen?: SortOrder
    autoOpenDelay?: SortOrder
    showBranding?: SortOrder
    collectEmail?: SortOrder
    requireEmail?: SortOrder
    customCss?: SortOrder
    totalConversations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentEmbedMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    enabled?: SortOrder
    displayName?: SortOrder
    welcomeMessage?: SortOrder
    logo?: SortOrder
    accentColor?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    userBubbleColor?: SortOrder
    botBubbleColor?: SortOrder
    position?: SortOrder
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpen?: SortOrder
    autoOpenDelay?: SortOrder
    showBranding?: SortOrder
    collectEmail?: SortOrder
    requireEmail?: SortOrder
    customCss?: SortOrder
    totalConversations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentEmbedSumOrderByAggregateInput = {
    buttonSize?: SortOrder
    windowWidth?: SortOrder
    windowHeight?: SortOrder
    autoOpenDelay?: SortOrder
    totalConversations?: SortOrder
  }

  export type EnumEmbedPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbedPosition | EnumEmbedPositionFieldRefInput<$PrismaModel>
    in?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbedPositionWithAggregatesFilter<$PrismaModel> | $Enums.EmbedPosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmbedPositionFilter<$PrismaModel>
    _max?: NestedEnumEmbedPositionFilter<$PrismaModel>
  }

  export type AgentEmailAddressLocalPartDomainCompoundUniqueInput = {
    localPart: string
    domain: string
  }

  export type AgentEmailAddressCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    localPart?: SortOrder
    domain?: SortOrder
    autoReply?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentEmailAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    localPart?: SortOrder
    domain?: SortOrder
    autoReply?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentEmailAddressMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    localPart?: SortOrder
    domain?: SortOrder
    autoReply?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type IntegrationUserIdTypeCompoundUniqueInput = {
    userId: string
    type: $Enums.IntegrationType
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    accountEmail?: SortOrder
    accountName?: SortOrder
    scopes?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    botUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    accountEmail?: SortOrder
    accountName?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    botUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    accountEmail?: SortOrder
    accountName?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    botUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type EnumSwarmStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmStatus | EnumSwarmStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmStatusFilter<$PrismaModel> | $Enums.SwarmStatus
  }

  export type SwarmTaskListRelationFilter = {
    every?: SwarmTaskWhereInput
    some?: SwarmTaskWhereInput
    none?: SwarmTaskWhereInput
  }

  export type SwarmTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentSwarmCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    taskTemplate?: SortOrder
    status?: SortOrder
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSwarmAvgOrderByAggregateInput = {
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
  }

  export type AgentSwarmMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    taskTemplate?: SortOrder
    status?: SortOrder
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSwarmMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    taskTemplate?: SortOrder
    status?: SortOrder
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSwarmSumOrderByAggregateInput = {
    totalTasks?: SortOrder
    completedTasks?: SortOrder
    failedTasks?: SortOrder
  }

  export type EnumSwarmStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmStatus | EnumSwarmStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmStatusWithAggregatesFilter<$PrismaModel> | $Enums.SwarmStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSwarmStatusFilter<$PrismaModel>
    _max?: NestedEnumSwarmStatusFilter<$PrismaModel>
  }

  export type EnumSwarmTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmTaskStatus | EnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmTaskStatusFilter<$PrismaModel> | $Enums.SwarmTaskStatus
  }

  export type AgentSwarmScalarRelationFilter = {
    is?: AgentSwarmWhereInput
    isNot?: AgentSwarmWhereInput
  }

  export type SwarmTaskCountOrderByAggregateInput = {
    id?: SortOrder
    swarmId?: SortOrder
    input?: SortOrder
    status?: SortOrder
    output?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SwarmTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    swarmId?: SortOrder
    status?: SortOrder
    output?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SwarmTaskMinOrderByAggregateInput = {
    id?: SortOrder
    swarmId?: SortOrder
    status?: SortOrder
    output?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSwarmTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmTaskStatus | EnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.SwarmTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSwarmTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumSwarmTaskStatusFilter<$PrismaModel>
  }

  export type EnumMeetingPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingPlatform | EnumMeetingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingPlatformFilter<$PrismaModel> | $Enums.MeetingPlatform
  }

  export type EnumRecordingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusFilter<$PrismaModel> | $Enums.RecordingStatus
  }

  export type MeetingRecordingCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    meetingUrl?: SortOrder
    meetingPlatform?: SortOrder
    calendarEventId?: SortOrder
    status?: SortOrder
    recordingUrl?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    actionItems?: SortOrder
    participants?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingRecordingAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type MeetingRecordingMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    meetingUrl?: SortOrder
    meetingPlatform?: SortOrder
    calendarEventId?: SortOrder
    status?: SortOrder
    recordingUrl?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingRecordingMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    meetingUrl?: SortOrder
    meetingPlatform?: SortOrder
    calendarEventId?: SortOrder
    status?: SortOrder
    recordingUrl?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingRecordingSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumMeetingPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingPlatform | EnumMeetingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingPlatformWithAggregatesFilter<$PrismaModel> | $Enums.MeetingPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingPlatformFilter<$PrismaModel>
    _max?: NestedEnumMeetingPlatformFilter<$PrismaModel>
  }

  export type EnumRecordingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecordingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingStatusFilter<$PrismaModel>
    _max?: NestedEnumRecordingStatusFilter<$PrismaModel>
  }

  export type PhoneCallListRelationFilter = {
    every?: PhoneCallWhereInput
    some?: PhoneCallWhereInput
    none?: PhoneCallWhereInput
  }

  export type PhoneCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentPhoneNumberCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumber?: SortOrder
    twilioSid?: SortOrder
    voiceEnabled?: SortOrder
    voiceGreeting?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentPhoneNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumber?: SortOrder
    twilioSid?: SortOrder
    voiceEnabled?: SortOrder
    voiceGreeting?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentPhoneNumberMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumber?: SortOrder
    twilioSid?: SortOrder
    voiceEnabled?: SortOrder
    voiceGreeting?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCallDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionFilter<$PrismaModel> | $Enums.CallDirection
  }

  export type EnumCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusFilter<$PrismaModel> | $Enums.CallStatus
  }

  export type AgentPhoneNumberScalarRelationFilter = {
    is?: AgentPhoneNumberWhereInput
    isNot?: AgentPhoneNumberWhereInput
  }

  export type PhoneCallCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumberId?: SortOrder
    direction?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    status?: SortOrder
    twilioCallSid?: SortOrder
    recordingUrl?: SortOrder
    transcript?: SortOrder
    conversationId?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type PhoneCallAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type PhoneCallMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumberId?: SortOrder
    direction?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    status?: SortOrder
    twilioCallSid?: SortOrder
    recordingUrl?: SortOrder
    transcript?: SortOrder
    conversationId?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type PhoneCallMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumberId?: SortOrder
    direction?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    status?: SortOrder
    twilioCallSid?: SortOrder
    recordingUrl?: SortOrder
    transcript?: SortOrder
    conversationId?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type PhoneCallSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumCallDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CallDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallDirectionFilter<$PrismaModel>
    _max?: NestedEnumCallDirectionFilter<$PrismaModel>
  }

  export type EnumCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallStatusFilter<$PrismaModel>
    _max?: NestedEnumCallStatusFilter<$PrismaModel>
  }

  export type AgentMetricAgentIdDateCompoundUniqueInput = {
    agentId: string
    date: Date | string
  }

  export type AgentMetricCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMetricAvgOrderByAggregateInput = {
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
  }

  export type AgentMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMetricMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMetricSumOrderByAggregateInput = {
    totalConversations?: SortOrder
    totalMessages?: SortOrder
    avgMessagesPerConvo?: SortOrder
    avgResponseTimeMs?: SortOrder
    totalTokensUsed?: SortOrder
    toolCallsCount?: SortOrder
    toolSuccessRate?: SortOrder
    feedbackPositive?: SortOrder
    feedbackNegative?: SortOrder
  }

  export type EnumScanCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanCategory | EnumScanCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumScanCategoryFilter<$PrismaModel> | $Enums.ScanCategory
  }

  export type ScanResultCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    signals?: SortOrder
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
    scannedAt?: SortOrder
  }

  export type ScanResultAvgOrderByAggregateInput = {
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
  }

  export type ScanResultMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
    scannedAt?: SortOrder
  }

  export type ScanResultMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
    scannedAt?: SortOrder
  }

  export type ScanResultSumOrderByAggregateInput = {
    totalSignals?: SortOrder
    criticalCount?: SortOrder
    highCount?: SortOrder
    mediumCount?: SortOrder
    lowCount?: SortOrder
  }

  export type EnumScanCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanCategory | EnumScanCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumScanCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ScanCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScanCategoryFilter<$PrismaModel>
    _max?: NestedEnumScanCategoryFilter<$PrismaModel>
  }

  export type EnumSignalSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SignalSeverity | EnumSignalSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSignalSeverityFilter<$PrismaModel> | $Enums.SignalSeverity
  }

  export type SignalCountOrderByAggregateInput = {
    id?: SortOrder
    scanResultId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    source?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    suggestedTemplateId?: SortOrder
    snoozedUntil?: SortOrder
    dismissedAt?: SortOrder
    actedOnAt?: SortOrder
    detectedAt?: SortOrder
  }

  export type SignalMaxOrderByAggregateInput = {
    id?: SortOrder
    scanResultId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    source?: SortOrder
    title?: SortOrder
    description?: SortOrder
    suggestedTemplateId?: SortOrder
    snoozedUntil?: SortOrder
    dismissedAt?: SortOrder
    actedOnAt?: SortOrder
    detectedAt?: SortOrder
  }

  export type SignalMinOrderByAggregateInput = {
    id?: SortOrder
    scanResultId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    source?: SortOrder
    title?: SortOrder
    description?: SortOrder
    suggestedTemplateId?: SortOrder
    snoozedUntil?: SortOrder
    dismissedAt?: SortOrder
    actedOnAt?: SortOrder
    detectedAt?: SortOrder
  }

  export type EnumSignalSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignalSeverity | EnumSignalSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSignalSeverityWithAggregatesFilter<$PrismaModel> | $Enums.SignalSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignalSeverityFilter<$PrismaModel>
    _max?: NestedEnumSignalSeverityFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AgentRunCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    dataSources?: SortOrder
    outputType?: SortOrder
    outputContent?: SortOrder
    llmModel?: SortOrder
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l1Assertions?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l2Breakdown?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrder
    l3Reason?: SortOrder
    userAction?: SortOrder
    draftDiff?: SortOrder
    finalAction?: SortOrder
    finalAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRunAvgOrderByAggregateInput = {
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l2Score?: SortOrder
  }

  export type AgentRunMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    outputType?: SortOrder
    outputContent?: SortOrder
    llmModel?: SortOrder
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrder
    l3Reason?: SortOrder
    userAction?: SortOrder
    draftDiff?: SortOrder
    finalAction?: SortOrder
    finalAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRunMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    outputType?: SortOrder
    outputContent?: SortOrder
    llmModel?: SortOrder
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrder
    l3Reason?: SortOrder
    userAction?: SortOrder
    draftDiff?: SortOrder
    finalAction?: SortOrder
    finalAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRunSumOrderByAggregateInput = {
    llmTokensUsed?: SortOrder
    llmCost?: SortOrder
    l2Score?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AgentTraceNullableScalarRelationFilter = {
    is?: AgentTraceWhereInput | null
    isNot?: AgentTraceWhereInput | null
  }

  export type AiEventCountOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    model?: SortOrder
    tier?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    action?: SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrder
    stepsUsed?: SortOrder
    evalResult?: SortOrder
    timestamp?: SortOrder
  }

  export type AiEventAvgOrderByAggregateInput = {
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    stepsUsed?: SortOrder
  }

  export type AiEventMaxOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    model?: SortOrder
    tier?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    action?: SortOrder
    toolName?: SortOrder
    stepsUsed?: SortOrder
    evalResult?: SortOrder
    timestamp?: SortOrder
  }

  export type AiEventMinOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    model?: SortOrder
    tier?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    action?: SortOrder
    toolName?: SortOrder
    stepsUsed?: SortOrder
    evalResult?: SortOrder
    timestamp?: SortOrder
  }

  export type AiEventSumOrderByAggregateInput = {
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    cost?: SortOrder
    latencyMs?: SortOrder
    stepNumber?: SortOrder
    stepsUsed?: SortOrder
  }

  export type EnumTraceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TraceStatus | EnumTraceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTraceStatusFilter<$PrismaModel> | $Enums.TraceStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AiEventListRelationFilter = {
    every?: AiEventWhereInput
    some?: AiEventWhereInput
    none?: AiEventWhereInput
  }

  export type AiEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentTraceCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    steps?: SortOrder
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrder
    toolCalls?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l1Passed?: SortOrder
    l1Failures?: SortOrder
    l2Score?: SortOrder
    l2Breakdown?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrder
    feedbackScore?: SortOrder
    feedbackComment?: SortOrder
    userEdited?: SortOrder
    editDiff?: SortOrder
  }

  export type AgentTraceAvgOrderByAggregateInput = {
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l2Score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type AgentTraceMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrder
    feedbackScore?: SortOrder
    feedbackComment?: SortOrder
    userEdited?: SortOrder
    editDiff?: SortOrder
  }

  export type AgentTraceMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l1Passed?: SortOrder
    l2Score?: SortOrder
    l3Triggered?: SortOrder
    l3Blocked?: SortOrder
    feedbackScore?: SortOrder
    feedbackComment?: SortOrder
    userEdited?: SortOrder
    editDiff?: SortOrder
  }

  export type AgentTraceSumOrderByAggregateInput = {
    totalSteps?: SortOrder
    maxSteps?: SortOrder
    totalTokensIn?: SortOrder
    totalTokensOut?: SortOrder
    totalCost?: SortOrder
    latencyMs?: SortOrder
    toolSuccesses?: SortOrder
    toolFailures?: SortOrder
    l2Score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type EnumTraceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TraceStatus | EnumTraceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTraceStatusWithAggregatesFilter<$PrismaModel> | $Enums.TraceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTraceStatusFilter<$PrismaModel>
    _max?: NestedEnumTraceStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ConversationEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    evaluatedAt?: SortOrder
    goalCompleted?: SortOrder
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
    categories?: SortOrder
    failureModes?: SortOrder
    improvementSuggestions?: SortOrder
    metadata?: SortOrder
  }

  export type ConversationEvaluationAvgOrderByAggregateInput = {
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
  }

  export type ConversationEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    evaluatedAt?: SortOrder
    goalCompleted?: SortOrder
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
  }

  export type ConversationEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    evaluatedAt?: SortOrder
    goalCompleted?: SortOrder
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
  }

  export type ConversationEvaluationSumOrderByAggregateInput = {
    goalCompletionConfidence?: SortOrder
    userSatisfactionScore?: SortOrder
  }

  export type AgentInsightCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    generatedAt?: SortOrder
    timeframeStart?: SortOrder
    timeframeEnd?: SortOrder
    clusters?: SortOrder
    patterns?: SortOrder
    anomalies?: SortOrder
    opportunities?: SortOrder
  }

  export type AgentInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    generatedAt?: SortOrder
    timeframeStart?: SortOrder
    timeframeEnd?: SortOrder
  }

  export type AgentInsightMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    generatedAt?: SortOrder
    timeframeStart?: SortOrder
    timeframeEnd?: SortOrder
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type AgentTraceScalarRelationFilter = {
    is?: AgentTraceWhereInput
    isNot?: AgentTraceWhereInput
  }

  export type AgentFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    originalOutput?: SortOrder
    userEdit?: SortOrder
    correctionText?: SortOrder
    stepNumber?: SortOrder
    metadata?: SortOrder
  }

  export type AgentFeedbackAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type AgentFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    originalOutput?: SortOrder
    userEdit?: SortOrder
    correctionText?: SortOrder
    stepNumber?: SortOrder
  }

  export type AgentFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    traceId?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    originalOutput?: SortOrder
    userEdit?: SortOrder
    correctionText?: SortOrder
    stepNumber?: SortOrder
  }

  export type AgentFeedbackSumOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumABTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ABTestStatus | EnumABTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumABTestStatusFilter<$PrismaModel> | $Enums.ABTestStatus
  }

  export type AgentABTestCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    variantAPrompt?: SortOrder
    variantBPrompt?: SortOrder
    trafficSplit?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrder
    variantBScore?: SortOrder
    winningVariant?: SortOrder
  }

  export type AgentABTestAvgOrderByAggregateInput = {
    trafficSplit?: SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrder
    variantBScore?: SortOrder
  }

  export type AgentABTestMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    variantAPrompt?: SortOrder
    variantBPrompt?: SortOrder
    trafficSplit?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrder
    variantBScore?: SortOrder
    winningVariant?: SortOrder
  }

  export type AgentABTestMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    variantAPrompt?: SortOrder
    variantBPrompt?: SortOrder
    trafficSplit?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrder
    variantBScore?: SortOrder
    winningVariant?: SortOrder
  }

  export type AgentABTestSumOrderByAggregateInput = {
    trafficSplit?: SortOrder
    variantATraces?: SortOrder
    variantBTraces?: SortOrder
    variantAScore?: SortOrder
    variantBScore?: SortOrder
  }

  export type EnumABTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ABTestStatus | EnumABTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumABTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ABTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumABTestStatusFilter<$PrismaModel>
    _max?: NestedEnumABTestStatusFilter<$PrismaModel>
  }

  export type OptimizationRunCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    editPatterns?: SortOrder
    promptVariations?: SortOrder
    testResults?: SortOrder
    recommendation?: SortOrder
    abTestId?: SortOrder
    status?: SortOrder
  }

  export type OptimizationRunMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    recommendation?: SortOrder
    abTestId?: SortOrder
    status?: SortOrder
  }

  export type OptimizationRunMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    triggeredAt?: SortOrder
    triggeredBy?: SortOrder
    recommendation?: SortOrder
    abTestId?: SortOrder
    status?: SortOrder
  }

  export type EnumModificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModificationTypeFilter<$PrismaModel> | $Enums.ModificationType
  }

  export type EnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type ModificationProposalCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    proposedAt?: SortOrder
    type?: SortOrder
    current?: SortOrder
    proposed?: SortOrder
    rationale?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    appliedAt?: SortOrder
  }

  export type ModificationProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    proposedAt?: SortOrder
    type?: SortOrder
    current?: SortOrder
    proposed?: SortOrder
    rationale?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    appliedAt?: SortOrder
  }

  export type ModificationProposalMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    proposedAt?: SortOrder
    type?: SortOrder
    current?: SortOrder
    proposed?: SortOrder
    rationale?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    appliedAt?: SortOrder
  }

  export type EnumModificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModificationTypeFilter<$PrismaModel>
    _max?: NestedEnumModificationTypeFilter<$PrismaModel>
  }

  export type EnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type CredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutUserInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type CredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutUserInput | WorkflowUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutUserInput | WorkflowUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutUserInput | WorkflowUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type CredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    upsert?: CredentialUpsertWithWhereUniqueWithoutUserInput | CredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    set?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    disconnect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    delete?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    update?: CredentialUpdateWithWhereUniqueWithoutUserInput | CredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CredentialUpdateManyWithWhereWithoutUserInput | CredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutUserInput | AgentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutUserInput | AgentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutUserInput | AgentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutUserInput | IntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutUserInput | IntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutUserInput | IntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutUserInput | WorkflowUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowCreateManyUserInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutUserInput | WorkflowUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutUserInput | WorkflowUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type CredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    upsert?: CredentialUpsertWithWhereUniqueWithoutUserInput | CredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    set?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    disconnect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    delete?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    update?: CredentialUpdateWithWhereUniqueWithoutUserInput | CredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CredentialUpdateManyWithWhereWithoutUserInput | CredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutUserInput | AgentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutUserInput | AgentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutUserInput | AgentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutUserInput | IntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutUserInput | IntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutUserInput | IntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutCredentialsInput = {
    create?: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type NodeCreateNestedManyWithoutCredentialInput = {
    create?: XOR<NodeCreateWithoutCredentialInput, NodeUncheckedCreateWithoutCredentialInput> | NodeCreateWithoutCredentialInput[] | NodeUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutCredentialInput | NodeCreateOrConnectWithoutCredentialInput[]
    createMany?: NodeCreateManyCredentialInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutCredentialInput = {
    create?: XOR<AgentCreateWithoutCredentialInput, AgentUncheckedCreateWithoutCredentialInput> | AgentCreateWithoutCredentialInput[] | AgentUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCredentialInput | AgentCreateOrConnectWithoutCredentialInput[]
    createMany?: AgentCreateManyCredentialInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type NodeUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<NodeCreateWithoutCredentialInput, NodeUncheckedCreateWithoutCredentialInput> | NodeCreateWithoutCredentialInput[] | NodeUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutCredentialInput | NodeCreateOrConnectWithoutCredentialInput[]
    createMany?: NodeCreateManyCredentialInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<AgentCreateWithoutCredentialInput, AgentUncheckedCreateWithoutCredentialInput> | AgentCreateWithoutCredentialInput[] | AgentUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCredentialInput | AgentCreateOrConnectWithoutCredentialInput[]
    createMany?: AgentCreateManyCredentialInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type EnumCredentialTypeFieldUpdateOperationsInput = {
    set?: $Enums.CredentialType
  }

  export type UserUpdateOneRequiredWithoutCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCredentialsInput
    upsert?: UserUpsertWithoutCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCredentialsInput, UserUpdateWithoutCredentialsInput>, UserUncheckedUpdateWithoutCredentialsInput>
  }

  export type NodeUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<NodeCreateWithoutCredentialInput, NodeUncheckedCreateWithoutCredentialInput> | NodeCreateWithoutCredentialInput[] | NodeUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutCredentialInput | NodeCreateOrConnectWithoutCredentialInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutCredentialInput | NodeUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: NodeCreateManyCredentialInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutCredentialInput | NodeUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutCredentialInput | NodeUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<AgentCreateWithoutCredentialInput, AgentUncheckedCreateWithoutCredentialInput> | AgentCreateWithoutCredentialInput[] | AgentUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCredentialInput | AgentCreateOrConnectWithoutCredentialInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutCredentialInput | AgentUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: AgentCreateManyCredentialInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutCredentialInput | AgentUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutCredentialInput | AgentUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type NodeUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<NodeCreateWithoutCredentialInput, NodeUncheckedCreateWithoutCredentialInput> | NodeCreateWithoutCredentialInput[] | NodeUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutCredentialInput | NodeCreateOrConnectWithoutCredentialInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutCredentialInput | NodeUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: NodeCreateManyCredentialInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutCredentialInput | NodeUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutCredentialInput | NodeUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<AgentCreateWithoutCredentialInput, AgentUncheckedCreateWithoutCredentialInput> | AgentCreateWithoutCredentialInput[] | AgentUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCredentialInput | AgentCreateOrConnectWithoutCredentialInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutCredentialInput | AgentUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: AgentCreateManyCredentialInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutCredentialInput | AgentUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutCredentialInput | AgentUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type NodeCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]
    createMany?: NodeCreateManyWorkflowInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ConnectionCreateWithoutWorkflowInput, ConnectionUncheckedCreateWithoutWorkflowInput> | ConnectionCreateWithoutWorkflowInput[] | ConnectionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutWorkflowInput | ConnectionCreateOrConnectWithoutWorkflowInput[]
    createMany?: ConnectionCreateManyWorkflowInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ExecutionCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]
    createMany?: ExecutionCreateManyWorkflowInputEnvelope
    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
  }

  export type AgentToolCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<AgentToolCreateWithoutWorkflowInput, AgentToolUncheckedCreateWithoutWorkflowInput> | AgentToolCreateWithoutWorkflowInput[] | AgentToolUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutWorkflowInput | AgentToolCreateOrConnectWithoutWorkflowInput[]
    createMany?: AgentToolCreateManyWorkflowInputEnvelope
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput
    connect?: UserWhereUniqueInput
  }

  export type NodeUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]
    createMany?: NodeCreateManyWorkflowInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ConnectionCreateWithoutWorkflowInput, ConnectionUncheckedCreateWithoutWorkflowInput> | ConnectionCreateWithoutWorkflowInput[] | ConnectionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutWorkflowInput | ConnectionCreateOrConnectWithoutWorkflowInput[]
    createMany?: ConnectionCreateManyWorkflowInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ExecutionUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]
    createMany?: ExecutionCreateManyWorkflowInputEnvelope
    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
  }

  export type AgentToolUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<AgentToolCreateWithoutWorkflowInput, AgentToolUncheckedCreateWithoutWorkflowInput> | AgentToolCreateWithoutWorkflowInput[] | AgentToolUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutWorkflowInput | AgentToolCreateOrConnectWithoutWorkflowInput[]
    createMany?: AgentToolCreateManyWorkflowInputEnvelope
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
  }

  export type NodeUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutWorkflowInput | NodeUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: NodeCreateManyWorkflowInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutWorkflowInput | NodeUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutWorkflowInput | NodeUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ConnectionCreateWithoutWorkflowInput, ConnectionUncheckedCreateWithoutWorkflowInput> | ConnectionCreateWithoutWorkflowInput[] | ConnectionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutWorkflowInput | ConnectionCreateOrConnectWithoutWorkflowInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutWorkflowInput | ConnectionUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ConnectionCreateManyWorkflowInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutWorkflowInput | ConnectionUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutWorkflowInput | ConnectionUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ExecutionUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]
    upsert?: ExecutionUpsertWithWhereUniqueWithoutWorkflowInput | ExecutionUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ExecutionCreateManyWorkflowInputEnvelope
    set?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    disconnect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    delete?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    update?: ExecutionUpdateWithWhereUniqueWithoutWorkflowInput | ExecutionUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ExecutionUpdateManyWithWhereWithoutWorkflowInput | ExecutionUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]
  }

  export type AgentToolUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<AgentToolCreateWithoutWorkflowInput, AgentToolUncheckedCreateWithoutWorkflowInput> | AgentToolCreateWithoutWorkflowInput[] | AgentToolUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutWorkflowInput | AgentToolCreateOrConnectWithoutWorkflowInput[]
    upsert?: AgentToolUpsertWithWhereUniqueWithoutWorkflowInput | AgentToolUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: AgentToolCreateManyWorkflowInputEnvelope
    set?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    disconnect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    delete?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    update?: AgentToolUpdateWithWhereUniqueWithoutWorkflowInput | AgentToolUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: AgentToolUpdateManyWithWhereWithoutWorkflowInput | AgentToolUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: AgentToolScalarWhereInput | AgentToolScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput
    upsert?: UserUpsertWithoutWorkflowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowsInput, UserUpdateWithoutWorkflowsInput>, UserUncheckedUpdateWithoutWorkflowsInput>
  }

  export type NodeUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutWorkflowInput | NodeUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: NodeCreateManyWorkflowInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutWorkflowInput | NodeUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutWorkflowInput | NodeUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ConnectionCreateWithoutWorkflowInput, ConnectionUncheckedCreateWithoutWorkflowInput> | ConnectionCreateWithoutWorkflowInput[] | ConnectionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutWorkflowInput | ConnectionCreateOrConnectWithoutWorkflowInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutWorkflowInput | ConnectionUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ConnectionCreateManyWorkflowInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutWorkflowInput | ConnectionUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutWorkflowInput | ConnectionUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]
    upsert?: ExecutionUpsertWithWhereUniqueWithoutWorkflowInput | ExecutionUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ExecutionCreateManyWorkflowInputEnvelope
    set?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    disconnect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    delete?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]
    update?: ExecutionUpdateWithWhereUniqueWithoutWorkflowInput | ExecutionUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ExecutionUpdateManyWithWhereWithoutWorkflowInput | ExecutionUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]
  }

  export type AgentToolUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<AgentToolCreateWithoutWorkflowInput, AgentToolUncheckedCreateWithoutWorkflowInput> | AgentToolCreateWithoutWorkflowInput[] | AgentToolUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutWorkflowInput | AgentToolCreateOrConnectWithoutWorkflowInput[]
    upsert?: AgentToolUpsertWithWhereUniqueWithoutWorkflowInput | AgentToolUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: AgentToolCreateManyWorkflowInputEnvelope
    set?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    disconnect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    delete?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    update?: AgentToolUpdateWithWhereUniqueWithoutWorkflowInput | AgentToolUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: AgentToolUpdateManyWithWhereWithoutWorkflowInput | AgentToolUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: AgentToolScalarWhereInput | AgentToolScalarWhereInput[]
  }

  export type WorkflowCreateNestedOneWithoutNodesInput = {
    create?: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutNodesInput
    connect?: WorkflowWhereUniqueInput
  }

  export type CredentialCreateNestedOneWithoutNodeInput = {
    create?: XOR<CredentialCreateWithoutNodeInput, CredentialUncheckedCreateWithoutNodeInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutNodeInput
    connect?: CredentialWhereUniqueInput
  }

  export type ConnectionCreateNestedManyWithoutFromNodeInput = {
    create?: XOR<ConnectionCreateWithoutFromNodeInput, ConnectionUncheckedCreateWithoutFromNodeInput> | ConnectionCreateWithoutFromNodeInput[] | ConnectionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutFromNodeInput | ConnectionCreateOrConnectWithoutFromNodeInput[]
    createMany?: ConnectionCreateManyFromNodeInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutToNodeInput = {
    create?: XOR<ConnectionCreateWithoutToNodeInput, ConnectionUncheckedCreateWithoutToNodeInput> | ConnectionCreateWithoutToNodeInput[] | ConnectionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutToNodeInput | ConnectionCreateOrConnectWithoutToNodeInput[]
    createMany?: ConnectionCreateManyToNodeInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutFromNodeInput = {
    create?: XOR<ConnectionCreateWithoutFromNodeInput, ConnectionUncheckedCreateWithoutFromNodeInput> | ConnectionCreateWithoutFromNodeInput[] | ConnectionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutFromNodeInput | ConnectionCreateOrConnectWithoutFromNodeInput[]
    createMany?: ConnectionCreateManyFromNodeInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutToNodeInput = {
    create?: XOR<ConnectionCreateWithoutToNodeInput, ConnectionUncheckedCreateWithoutToNodeInput> | ConnectionCreateWithoutToNodeInput[] | ConnectionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutToNodeInput | ConnectionCreateOrConnectWithoutToNodeInput[]
    createMany?: ConnectionCreateManyToNodeInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type EnumNodeTypeFieldUpdateOperationsInput = {
    set?: $Enums.NodeType
  }

  export type WorkflowUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutNodesInput
    upsert?: WorkflowUpsertWithoutNodesInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutNodesInput, WorkflowUpdateWithoutNodesInput>, WorkflowUncheckedUpdateWithoutNodesInput>
  }

  export type CredentialUpdateOneWithoutNodeNestedInput = {
    create?: XOR<CredentialCreateWithoutNodeInput, CredentialUncheckedCreateWithoutNodeInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutNodeInput
    upsert?: CredentialUpsertWithoutNodeInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutNodeInput, CredentialUpdateWithoutNodeInput>, CredentialUncheckedUpdateWithoutNodeInput>
  }

  export type ConnectionUpdateManyWithoutFromNodeNestedInput = {
    create?: XOR<ConnectionCreateWithoutFromNodeInput, ConnectionUncheckedCreateWithoutFromNodeInput> | ConnectionCreateWithoutFromNodeInput[] | ConnectionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutFromNodeInput | ConnectionCreateOrConnectWithoutFromNodeInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutFromNodeInput | ConnectionUpsertWithWhereUniqueWithoutFromNodeInput[]
    createMany?: ConnectionCreateManyFromNodeInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutFromNodeInput | ConnectionUpdateWithWhereUniqueWithoutFromNodeInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutFromNodeInput | ConnectionUpdateManyWithWhereWithoutFromNodeInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutToNodeNestedInput = {
    create?: XOR<ConnectionCreateWithoutToNodeInput, ConnectionUncheckedCreateWithoutToNodeInput> | ConnectionCreateWithoutToNodeInput[] | ConnectionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutToNodeInput | ConnectionCreateOrConnectWithoutToNodeInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutToNodeInput | ConnectionUpsertWithWhereUniqueWithoutToNodeInput[]
    createMany?: ConnectionCreateManyToNodeInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutToNodeInput | ConnectionUpdateWithWhereUniqueWithoutToNodeInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutToNodeInput | ConnectionUpdateManyWithWhereWithoutToNodeInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutFromNodeNestedInput = {
    create?: XOR<ConnectionCreateWithoutFromNodeInput, ConnectionUncheckedCreateWithoutFromNodeInput> | ConnectionCreateWithoutFromNodeInput[] | ConnectionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutFromNodeInput | ConnectionCreateOrConnectWithoutFromNodeInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutFromNodeInput | ConnectionUpsertWithWhereUniqueWithoutFromNodeInput[]
    createMany?: ConnectionCreateManyFromNodeInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutFromNodeInput | ConnectionUpdateWithWhereUniqueWithoutFromNodeInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutFromNodeInput | ConnectionUpdateManyWithWhereWithoutFromNodeInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutToNodeNestedInput = {
    create?: XOR<ConnectionCreateWithoutToNodeInput, ConnectionUncheckedCreateWithoutToNodeInput> | ConnectionCreateWithoutToNodeInput[] | ConnectionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutToNodeInput | ConnectionCreateOrConnectWithoutToNodeInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutToNodeInput | ConnectionUpsertWithWhereUniqueWithoutToNodeInput[]
    createMany?: ConnectionCreateManyToNodeInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutToNodeInput | ConnectionUpdateWithWhereUniqueWithoutToNodeInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutToNodeInput | ConnectionUpdateManyWithWhereWithoutToNodeInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type WorkflowCreateNestedOneWithoutConnectionsInput = {
    create?: XOR<WorkflowCreateWithoutConnectionsInput, WorkflowUncheckedCreateWithoutConnectionsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutConnectionsInput
    connect?: WorkflowWhereUniqueInput
  }

  export type NodeCreateNestedOneWithoutOutputConnectionsInput = {
    create?: XOR<NodeCreateWithoutOutputConnectionsInput, NodeUncheckedCreateWithoutOutputConnectionsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutOutputConnectionsInput
    connect?: NodeWhereUniqueInput
  }

  export type NodeCreateNestedOneWithoutInputConnectionsInput = {
    create?: XOR<NodeCreateWithoutInputConnectionsInput, NodeUncheckedCreateWithoutInputConnectionsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutInputConnectionsInput
    connect?: NodeWhereUniqueInput
  }

  export type WorkflowUpdateOneRequiredWithoutConnectionsNestedInput = {
    create?: XOR<WorkflowCreateWithoutConnectionsInput, WorkflowUncheckedCreateWithoutConnectionsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutConnectionsInput
    upsert?: WorkflowUpsertWithoutConnectionsInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutConnectionsInput, WorkflowUpdateWithoutConnectionsInput>, WorkflowUncheckedUpdateWithoutConnectionsInput>
  }

  export type NodeUpdateOneRequiredWithoutOutputConnectionsNestedInput = {
    create?: XOR<NodeCreateWithoutOutputConnectionsInput, NodeUncheckedCreateWithoutOutputConnectionsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutOutputConnectionsInput
    upsert?: NodeUpsertWithoutOutputConnectionsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutOutputConnectionsInput, NodeUpdateWithoutOutputConnectionsInput>, NodeUncheckedUpdateWithoutOutputConnectionsInput>
  }

  export type NodeUpdateOneRequiredWithoutInputConnectionsNestedInput = {
    create?: XOR<NodeCreateWithoutInputConnectionsInput, NodeUncheckedCreateWithoutInputConnectionsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutInputConnectionsInput
    upsert?: NodeUpsertWithoutInputConnectionsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutInputConnectionsInput, NodeUpdateWithoutInputConnectionsInput>, NodeUncheckedUpdateWithoutInputConnectionsInput>
  }

  export type WorkflowCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput
    connect?: WorkflowWhereUniqueInput
  }

  export type EnumExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExecutionStatus
  }

  export type WorkflowUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput
    upsert?: WorkflowUpsertWithoutExecutionsInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutExecutionsInput, WorkflowUpdateWithoutExecutionsInput>, WorkflowUncheckedUpdateWithoutExecutionsInput>
  }

  export type AgentCreatetagsInput = {
    set: string[]
  }

  export type AgentTemplateCreateNestedOneWithoutAgentsInput = {
    create?: XOR<AgentTemplateCreateWithoutAgentsInput, AgentTemplateUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: AgentTemplateCreateOrConnectWithoutAgentsInput
    connect?: AgentTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAgentsInput = {
    create?: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentsInput
    connect?: UserWhereUniqueInput
  }

  export type CredentialCreateNestedOneWithoutAgentsInput = {
    create?: XOR<CredentialCreateWithoutAgentsInput, CredentialUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutAgentsInput
    connect?: CredentialWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutAgentInput = {
    create?: XOR<ConversationCreateWithoutAgentInput, ConversationUncheckedCreateWithoutAgentInput> | ConversationCreateWithoutAgentInput[] | ConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAgentInput | ConversationCreateOrConnectWithoutAgentInput[]
    createMany?: ConversationCreateManyAgentInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type AgentToolCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentToolCreateWithoutAgentInput, AgentToolUncheckedCreateWithoutAgentInput> | AgentToolCreateWithoutAgentInput[] | AgentToolUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutAgentInput | AgentToolCreateOrConnectWithoutAgentInput[]
    createMany?: AgentToolCreateManyAgentInputEnvelope
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
  }

  export type AgentMemoryCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentMemoryCreateWithoutAgentInput, AgentMemoryUncheckedCreateWithoutAgentInput> | AgentMemoryCreateWithoutAgentInput[] | AgentMemoryUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMemoryCreateOrConnectWithoutAgentInput | AgentMemoryCreateOrConnectWithoutAgentInput[]
    createMany?: AgentMemoryCreateManyAgentInputEnvelope
    connect?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
  }

  export type KnowledgeDocumentCreateNestedManyWithoutAgentInput = {
    create?: XOR<KnowledgeDocumentCreateWithoutAgentInput, KnowledgeDocumentUncheckedCreateWithoutAgentInput> | KnowledgeDocumentCreateWithoutAgentInput[] | KnowledgeDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeDocumentCreateOrConnectWithoutAgentInput | KnowledgeDocumentCreateOrConnectWithoutAgentInput[]
    createMany?: KnowledgeDocumentCreateManyAgentInputEnvelope
    connect?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
  }

  export type KnowledgeSettingsCreateNestedOneWithoutAgentInput = {
    create?: XOR<KnowledgeSettingsCreateWithoutAgentInput, KnowledgeSettingsUncheckedCreateWithoutAgentInput>
    connectOrCreate?: KnowledgeSettingsCreateOrConnectWithoutAgentInput
    connect?: KnowledgeSettingsWhereUniqueInput
  }

  export type AgentTriggerCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentTriggerCreateWithoutAgentInput, AgentTriggerUncheckedCreateWithoutAgentInput> | AgentTriggerCreateWithoutAgentInput[] | AgentTriggerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTriggerCreateOrConnectWithoutAgentInput | AgentTriggerCreateOrConnectWithoutAgentInput[]
    createMany?: AgentTriggerCreateManyAgentInputEnvelope
    connect?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
  }

  export type AgentEmbedCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentEmbedCreateWithoutAgentInput, AgentEmbedUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmbedCreateOrConnectWithoutAgentInput
    connect?: AgentEmbedWhereUniqueInput
  }

  export type AgentConnectionCreateNestedManyWithoutSourceAgentInput = {
    create?: XOR<AgentConnectionCreateWithoutSourceAgentInput, AgentConnectionUncheckedCreateWithoutSourceAgentInput> | AgentConnectionCreateWithoutSourceAgentInput[] | AgentConnectionUncheckedCreateWithoutSourceAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutSourceAgentInput | AgentConnectionCreateOrConnectWithoutSourceAgentInput[]
    createMany?: AgentConnectionCreateManySourceAgentInputEnvelope
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
  }

  export type AgentConnectionCreateNestedManyWithoutTargetAgentInput = {
    create?: XOR<AgentConnectionCreateWithoutTargetAgentInput, AgentConnectionUncheckedCreateWithoutTargetAgentInput> | AgentConnectionCreateWithoutTargetAgentInput[] | AgentConnectionUncheckedCreateWithoutTargetAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutTargetAgentInput | AgentConnectionCreateOrConnectWithoutTargetAgentInput[]
    createMany?: AgentConnectionCreateManyTargetAgentInputEnvelope
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
  }

  export type AgentSwarmCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentSwarmCreateWithoutAgentInput, AgentSwarmUncheckedCreateWithoutAgentInput> | AgentSwarmCreateWithoutAgentInput[] | AgentSwarmUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSwarmCreateOrConnectWithoutAgentInput | AgentSwarmCreateOrConnectWithoutAgentInput[]
    createMany?: AgentSwarmCreateManyAgentInputEnvelope
    connect?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
  }

  export type AgentEmailAddressCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentEmailAddressCreateWithoutAgentInput, AgentEmailAddressUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmailAddressCreateOrConnectWithoutAgentInput
    connect?: AgentEmailAddressWhereUniqueInput
  }

  export type MeetingRecordingCreateNestedManyWithoutAgentInput = {
    create?: XOR<MeetingRecordingCreateWithoutAgentInput, MeetingRecordingUncheckedCreateWithoutAgentInput> | MeetingRecordingCreateWithoutAgentInput[] | MeetingRecordingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MeetingRecordingCreateOrConnectWithoutAgentInput | MeetingRecordingCreateOrConnectWithoutAgentInput[]
    createMany?: MeetingRecordingCreateManyAgentInputEnvelope
    connect?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
  }

  export type AgentPhoneNumberCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentPhoneNumberCreateWithoutAgentInput, AgentPhoneNumberUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentPhoneNumberCreateOrConnectWithoutAgentInput
    connect?: AgentPhoneNumberWhereUniqueInput
  }

  export type AgentMetricCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentMetricCreateWithoutAgentInput, AgentMetricUncheckedCreateWithoutAgentInput> | AgentMetricCreateWithoutAgentInput[] | AgentMetricUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMetricCreateOrConnectWithoutAgentInput | AgentMetricCreateOrConnectWithoutAgentInput[]
    createMany?: AgentMetricCreateManyAgentInputEnvelope
    connect?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
  }

  export type AgentTraceCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentTraceCreateWithoutAgentInput, AgentTraceUncheckedCreateWithoutAgentInput> | AgentTraceCreateWithoutAgentInput[] | AgentTraceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutAgentInput | AgentTraceCreateOrConnectWithoutAgentInput[]
    createMany?: AgentTraceCreateManyAgentInputEnvelope
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
  }

  export type AgentInsightCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentInsightCreateWithoutAgentInput, AgentInsightUncheckedCreateWithoutAgentInput> | AgentInsightCreateWithoutAgentInput[] | AgentInsightUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentInsightCreateOrConnectWithoutAgentInput | AgentInsightCreateOrConnectWithoutAgentInput[]
    createMany?: AgentInsightCreateManyAgentInputEnvelope
    connect?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
  }

  export type AgentFeedbackCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentFeedbackCreateWithoutAgentInput, AgentFeedbackUncheckedCreateWithoutAgentInput> | AgentFeedbackCreateWithoutAgentInput[] | AgentFeedbackUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutAgentInput | AgentFeedbackCreateOrConnectWithoutAgentInput[]
    createMany?: AgentFeedbackCreateManyAgentInputEnvelope
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
  }

  export type AgentABTestCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentABTestCreateWithoutAgentInput, AgentABTestUncheckedCreateWithoutAgentInput> | AgentABTestCreateWithoutAgentInput[] | AgentABTestUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentABTestCreateOrConnectWithoutAgentInput | AgentABTestCreateOrConnectWithoutAgentInput[]
    createMany?: AgentABTestCreateManyAgentInputEnvelope
    connect?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
  }

  export type OptimizationRunCreateNestedManyWithoutAgentInput = {
    create?: XOR<OptimizationRunCreateWithoutAgentInput, OptimizationRunUncheckedCreateWithoutAgentInput> | OptimizationRunCreateWithoutAgentInput[] | OptimizationRunUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OptimizationRunCreateOrConnectWithoutAgentInput | OptimizationRunCreateOrConnectWithoutAgentInput[]
    createMany?: OptimizationRunCreateManyAgentInputEnvelope
    connect?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
  }

  export type ModificationProposalCreateNestedManyWithoutAgentInput = {
    create?: XOR<ModificationProposalCreateWithoutAgentInput, ModificationProposalUncheckedCreateWithoutAgentInput> | ModificationProposalCreateWithoutAgentInput[] | ModificationProposalUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ModificationProposalCreateOrConnectWithoutAgentInput | ModificationProposalCreateOrConnectWithoutAgentInput[]
    createMany?: ModificationProposalCreateManyAgentInputEnvelope
    connect?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ConversationCreateWithoutAgentInput, ConversationUncheckedCreateWithoutAgentInput> | ConversationCreateWithoutAgentInput[] | ConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAgentInput | ConversationCreateOrConnectWithoutAgentInput[]
    createMany?: ConversationCreateManyAgentInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type AgentToolUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentToolCreateWithoutAgentInput, AgentToolUncheckedCreateWithoutAgentInput> | AgentToolCreateWithoutAgentInput[] | AgentToolUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutAgentInput | AgentToolCreateOrConnectWithoutAgentInput[]
    createMany?: AgentToolCreateManyAgentInputEnvelope
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
  }

  export type AgentMemoryUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentMemoryCreateWithoutAgentInput, AgentMemoryUncheckedCreateWithoutAgentInput> | AgentMemoryCreateWithoutAgentInput[] | AgentMemoryUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMemoryCreateOrConnectWithoutAgentInput | AgentMemoryCreateOrConnectWithoutAgentInput[]
    createMany?: AgentMemoryCreateManyAgentInputEnvelope
    connect?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
  }

  export type KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<KnowledgeDocumentCreateWithoutAgentInput, KnowledgeDocumentUncheckedCreateWithoutAgentInput> | KnowledgeDocumentCreateWithoutAgentInput[] | KnowledgeDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeDocumentCreateOrConnectWithoutAgentInput | KnowledgeDocumentCreateOrConnectWithoutAgentInput[]
    createMany?: KnowledgeDocumentCreateManyAgentInputEnvelope
    connect?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
  }

  export type KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput = {
    create?: XOR<KnowledgeSettingsCreateWithoutAgentInput, KnowledgeSettingsUncheckedCreateWithoutAgentInput>
    connectOrCreate?: KnowledgeSettingsCreateOrConnectWithoutAgentInput
    connect?: KnowledgeSettingsWhereUniqueInput
  }

  export type AgentTriggerUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentTriggerCreateWithoutAgentInput, AgentTriggerUncheckedCreateWithoutAgentInput> | AgentTriggerCreateWithoutAgentInput[] | AgentTriggerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTriggerCreateOrConnectWithoutAgentInput | AgentTriggerCreateOrConnectWithoutAgentInput[]
    createMany?: AgentTriggerCreateManyAgentInputEnvelope
    connect?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
  }

  export type AgentEmbedUncheckedCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentEmbedCreateWithoutAgentInput, AgentEmbedUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmbedCreateOrConnectWithoutAgentInput
    connect?: AgentEmbedWhereUniqueInput
  }

  export type AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput = {
    create?: XOR<AgentConnectionCreateWithoutSourceAgentInput, AgentConnectionUncheckedCreateWithoutSourceAgentInput> | AgentConnectionCreateWithoutSourceAgentInput[] | AgentConnectionUncheckedCreateWithoutSourceAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutSourceAgentInput | AgentConnectionCreateOrConnectWithoutSourceAgentInput[]
    createMany?: AgentConnectionCreateManySourceAgentInputEnvelope
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
  }

  export type AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput = {
    create?: XOR<AgentConnectionCreateWithoutTargetAgentInput, AgentConnectionUncheckedCreateWithoutTargetAgentInput> | AgentConnectionCreateWithoutTargetAgentInput[] | AgentConnectionUncheckedCreateWithoutTargetAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutTargetAgentInput | AgentConnectionCreateOrConnectWithoutTargetAgentInput[]
    createMany?: AgentConnectionCreateManyTargetAgentInputEnvelope
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
  }

  export type AgentSwarmUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentSwarmCreateWithoutAgentInput, AgentSwarmUncheckedCreateWithoutAgentInput> | AgentSwarmCreateWithoutAgentInput[] | AgentSwarmUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSwarmCreateOrConnectWithoutAgentInput | AgentSwarmCreateOrConnectWithoutAgentInput[]
    createMany?: AgentSwarmCreateManyAgentInputEnvelope
    connect?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
  }

  export type AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentEmailAddressCreateWithoutAgentInput, AgentEmailAddressUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmailAddressCreateOrConnectWithoutAgentInput
    connect?: AgentEmailAddressWhereUniqueInput
  }

  export type MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MeetingRecordingCreateWithoutAgentInput, MeetingRecordingUncheckedCreateWithoutAgentInput> | MeetingRecordingCreateWithoutAgentInput[] | MeetingRecordingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MeetingRecordingCreateOrConnectWithoutAgentInput | MeetingRecordingCreateOrConnectWithoutAgentInput[]
    createMany?: MeetingRecordingCreateManyAgentInputEnvelope
    connect?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
  }

  export type AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentPhoneNumberCreateWithoutAgentInput, AgentPhoneNumberUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentPhoneNumberCreateOrConnectWithoutAgentInput
    connect?: AgentPhoneNumberWhereUniqueInput
  }

  export type AgentMetricUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentMetricCreateWithoutAgentInput, AgentMetricUncheckedCreateWithoutAgentInput> | AgentMetricCreateWithoutAgentInput[] | AgentMetricUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMetricCreateOrConnectWithoutAgentInput | AgentMetricCreateOrConnectWithoutAgentInput[]
    createMany?: AgentMetricCreateManyAgentInputEnvelope
    connect?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
  }

  export type AgentTraceUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentTraceCreateWithoutAgentInput, AgentTraceUncheckedCreateWithoutAgentInput> | AgentTraceCreateWithoutAgentInput[] | AgentTraceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutAgentInput | AgentTraceCreateOrConnectWithoutAgentInput[]
    createMany?: AgentTraceCreateManyAgentInputEnvelope
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
  }

  export type AgentInsightUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentInsightCreateWithoutAgentInput, AgentInsightUncheckedCreateWithoutAgentInput> | AgentInsightCreateWithoutAgentInput[] | AgentInsightUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentInsightCreateOrConnectWithoutAgentInput | AgentInsightCreateOrConnectWithoutAgentInput[]
    createMany?: AgentInsightCreateManyAgentInputEnvelope
    connect?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
  }

  export type AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentFeedbackCreateWithoutAgentInput, AgentFeedbackUncheckedCreateWithoutAgentInput> | AgentFeedbackCreateWithoutAgentInput[] | AgentFeedbackUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutAgentInput | AgentFeedbackCreateOrConnectWithoutAgentInput[]
    createMany?: AgentFeedbackCreateManyAgentInputEnvelope
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
  }

  export type AgentABTestUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentABTestCreateWithoutAgentInput, AgentABTestUncheckedCreateWithoutAgentInput> | AgentABTestCreateWithoutAgentInput[] | AgentABTestUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentABTestCreateOrConnectWithoutAgentInput | AgentABTestCreateOrConnectWithoutAgentInput[]
    createMany?: AgentABTestCreateManyAgentInputEnvelope
    connect?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
  }

  export type OptimizationRunUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<OptimizationRunCreateWithoutAgentInput, OptimizationRunUncheckedCreateWithoutAgentInput> | OptimizationRunCreateWithoutAgentInput[] | OptimizationRunUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OptimizationRunCreateOrConnectWithoutAgentInput | OptimizationRunCreateOrConnectWithoutAgentInput[]
    createMany?: OptimizationRunCreateManyAgentInputEnvelope
    connect?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
  }

  export type ModificationProposalUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ModificationProposalCreateWithoutAgentInput, ModificationProposalUncheckedCreateWithoutAgentInput> | ModificationProposalCreateWithoutAgentInput[] | ModificationProposalUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ModificationProposalCreateOrConnectWithoutAgentInput | ModificationProposalCreateOrConnectWithoutAgentInput[]
    createMany?: ModificationProposalCreateManyAgentInputEnvelope
    connect?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
  }

  export type EnumAgentModelFieldUpdateOperationsInput = {
    set?: $Enums.AgentModel
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentTemplateUpdateOneWithoutAgentsNestedInput = {
    create?: XOR<AgentTemplateCreateWithoutAgentsInput, AgentTemplateUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: AgentTemplateCreateOrConnectWithoutAgentsInput
    upsert?: AgentTemplateUpsertWithoutAgentsInput
    disconnect?: AgentTemplateWhereInput | boolean
    delete?: AgentTemplateWhereInput | boolean
    connect?: AgentTemplateWhereUniqueInput
    update?: XOR<XOR<AgentTemplateUpdateToOneWithWhereWithoutAgentsInput, AgentTemplateUpdateWithoutAgentsInput>, AgentTemplateUncheckedUpdateWithoutAgentsInput>
  }

  export type UserUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentsInput
    upsert?: UserUpsertWithoutAgentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentsInput, UserUpdateWithoutAgentsInput>, UserUncheckedUpdateWithoutAgentsInput>
  }

  export type CredentialUpdateOneWithoutAgentsNestedInput = {
    create?: XOR<CredentialCreateWithoutAgentsInput, CredentialUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutAgentsInput
    upsert?: CredentialUpsertWithoutAgentsInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutAgentsInput, CredentialUpdateWithoutAgentsInput>, CredentialUncheckedUpdateWithoutAgentsInput>
  }

  export type ConversationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ConversationCreateWithoutAgentInput, ConversationUncheckedCreateWithoutAgentInput> | ConversationCreateWithoutAgentInput[] | ConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAgentInput | ConversationCreateOrConnectWithoutAgentInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutAgentInput | ConversationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ConversationCreateManyAgentInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutAgentInput | ConversationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutAgentInput | ConversationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type AgentToolUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentToolCreateWithoutAgentInput, AgentToolUncheckedCreateWithoutAgentInput> | AgentToolCreateWithoutAgentInput[] | AgentToolUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutAgentInput | AgentToolCreateOrConnectWithoutAgentInput[]
    upsert?: AgentToolUpsertWithWhereUniqueWithoutAgentInput | AgentToolUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentToolCreateManyAgentInputEnvelope
    set?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    disconnect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    delete?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    update?: AgentToolUpdateWithWhereUniqueWithoutAgentInput | AgentToolUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentToolUpdateManyWithWhereWithoutAgentInput | AgentToolUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentToolScalarWhereInput | AgentToolScalarWhereInput[]
  }

  export type AgentMemoryUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentMemoryCreateWithoutAgentInput, AgentMemoryUncheckedCreateWithoutAgentInput> | AgentMemoryCreateWithoutAgentInput[] | AgentMemoryUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMemoryCreateOrConnectWithoutAgentInput | AgentMemoryCreateOrConnectWithoutAgentInput[]
    upsert?: AgentMemoryUpsertWithWhereUniqueWithoutAgentInput | AgentMemoryUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentMemoryCreateManyAgentInputEnvelope
    set?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    disconnect?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    delete?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    connect?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    update?: AgentMemoryUpdateWithWhereUniqueWithoutAgentInput | AgentMemoryUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentMemoryUpdateManyWithWhereWithoutAgentInput | AgentMemoryUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentMemoryScalarWhereInput | AgentMemoryScalarWhereInput[]
  }

  export type KnowledgeDocumentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<KnowledgeDocumentCreateWithoutAgentInput, KnowledgeDocumentUncheckedCreateWithoutAgentInput> | KnowledgeDocumentCreateWithoutAgentInput[] | KnowledgeDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeDocumentCreateOrConnectWithoutAgentInput | KnowledgeDocumentCreateOrConnectWithoutAgentInput[]
    upsert?: KnowledgeDocumentUpsertWithWhereUniqueWithoutAgentInput | KnowledgeDocumentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: KnowledgeDocumentCreateManyAgentInputEnvelope
    set?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    disconnect?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    delete?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    connect?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    update?: KnowledgeDocumentUpdateWithWhereUniqueWithoutAgentInput | KnowledgeDocumentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: KnowledgeDocumentUpdateManyWithWhereWithoutAgentInput | KnowledgeDocumentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: KnowledgeDocumentScalarWhereInput | KnowledgeDocumentScalarWhereInput[]
  }

  export type KnowledgeSettingsUpdateOneWithoutAgentNestedInput = {
    create?: XOR<KnowledgeSettingsCreateWithoutAgentInput, KnowledgeSettingsUncheckedCreateWithoutAgentInput>
    connectOrCreate?: KnowledgeSettingsCreateOrConnectWithoutAgentInput
    upsert?: KnowledgeSettingsUpsertWithoutAgentInput
    disconnect?: KnowledgeSettingsWhereInput | boolean
    delete?: KnowledgeSettingsWhereInput | boolean
    connect?: KnowledgeSettingsWhereUniqueInput
    update?: XOR<XOR<KnowledgeSettingsUpdateToOneWithWhereWithoutAgentInput, KnowledgeSettingsUpdateWithoutAgentInput>, KnowledgeSettingsUncheckedUpdateWithoutAgentInput>
  }

  export type AgentTriggerUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentTriggerCreateWithoutAgentInput, AgentTriggerUncheckedCreateWithoutAgentInput> | AgentTriggerCreateWithoutAgentInput[] | AgentTriggerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTriggerCreateOrConnectWithoutAgentInput | AgentTriggerCreateOrConnectWithoutAgentInput[]
    upsert?: AgentTriggerUpsertWithWhereUniqueWithoutAgentInput | AgentTriggerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentTriggerCreateManyAgentInputEnvelope
    set?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    disconnect?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    delete?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    connect?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    update?: AgentTriggerUpdateWithWhereUniqueWithoutAgentInput | AgentTriggerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentTriggerUpdateManyWithWhereWithoutAgentInput | AgentTriggerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentTriggerScalarWhereInput | AgentTriggerScalarWhereInput[]
  }

  export type AgentEmbedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentEmbedCreateWithoutAgentInput, AgentEmbedUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmbedCreateOrConnectWithoutAgentInput
    upsert?: AgentEmbedUpsertWithoutAgentInput
    disconnect?: AgentEmbedWhereInput | boolean
    delete?: AgentEmbedWhereInput | boolean
    connect?: AgentEmbedWhereUniqueInput
    update?: XOR<XOR<AgentEmbedUpdateToOneWithWhereWithoutAgentInput, AgentEmbedUpdateWithoutAgentInput>, AgentEmbedUncheckedUpdateWithoutAgentInput>
  }

  export type AgentConnectionUpdateManyWithoutSourceAgentNestedInput = {
    create?: XOR<AgentConnectionCreateWithoutSourceAgentInput, AgentConnectionUncheckedCreateWithoutSourceAgentInput> | AgentConnectionCreateWithoutSourceAgentInput[] | AgentConnectionUncheckedCreateWithoutSourceAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutSourceAgentInput | AgentConnectionCreateOrConnectWithoutSourceAgentInput[]
    upsert?: AgentConnectionUpsertWithWhereUniqueWithoutSourceAgentInput | AgentConnectionUpsertWithWhereUniqueWithoutSourceAgentInput[]
    createMany?: AgentConnectionCreateManySourceAgentInputEnvelope
    set?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    disconnect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    delete?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    update?: AgentConnectionUpdateWithWhereUniqueWithoutSourceAgentInput | AgentConnectionUpdateWithWhereUniqueWithoutSourceAgentInput[]
    updateMany?: AgentConnectionUpdateManyWithWhereWithoutSourceAgentInput | AgentConnectionUpdateManyWithWhereWithoutSourceAgentInput[]
    deleteMany?: AgentConnectionScalarWhereInput | AgentConnectionScalarWhereInput[]
  }

  export type AgentConnectionUpdateManyWithoutTargetAgentNestedInput = {
    create?: XOR<AgentConnectionCreateWithoutTargetAgentInput, AgentConnectionUncheckedCreateWithoutTargetAgentInput> | AgentConnectionCreateWithoutTargetAgentInput[] | AgentConnectionUncheckedCreateWithoutTargetAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutTargetAgentInput | AgentConnectionCreateOrConnectWithoutTargetAgentInput[]
    upsert?: AgentConnectionUpsertWithWhereUniqueWithoutTargetAgentInput | AgentConnectionUpsertWithWhereUniqueWithoutTargetAgentInput[]
    createMany?: AgentConnectionCreateManyTargetAgentInputEnvelope
    set?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    disconnect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    delete?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    update?: AgentConnectionUpdateWithWhereUniqueWithoutTargetAgentInput | AgentConnectionUpdateWithWhereUniqueWithoutTargetAgentInput[]
    updateMany?: AgentConnectionUpdateManyWithWhereWithoutTargetAgentInput | AgentConnectionUpdateManyWithWhereWithoutTargetAgentInput[]
    deleteMany?: AgentConnectionScalarWhereInput | AgentConnectionScalarWhereInput[]
  }

  export type AgentSwarmUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentSwarmCreateWithoutAgentInput, AgentSwarmUncheckedCreateWithoutAgentInput> | AgentSwarmCreateWithoutAgentInput[] | AgentSwarmUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSwarmCreateOrConnectWithoutAgentInput | AgentSwarmCreateOrConnectWithoutAgentInput[]
    upsert?: AgentSwarmUpsertWithWhereUniqueWithoutAgentInput | AgentSwarmUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentSwarmCreateManyAgentInputEnvelope
    set?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    disconnect?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    delete?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    connect?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    update?: AgentSwarmUpdateWithWhereUniqueWithoutAgentInput | AgentSwarmUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentSwarmUpdateManyWithWhereWithoutAgentInput | AgentSwarmUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentSwarmScalarWhereInput | AgentSwarmScalarWhereInput[]
  }

  export type AgentEmailAddressUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentEmailAddressCreateWithoutAgentInput, AgentEmailAddressUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmailAddressCreateOrConnectWithoutAgentInput
    upsert?: AgentEmailAddressUpsertWithoutAgentInput
    disconnect?: AgentEmailAddressWhereInput | boolean
    delete?: AgentEmailAddressWhereInput | boolean
    connect?: AgentEmailAddressWhereUniqueInput
    update?: XOR<XOR<AgentEmailAddressUpdateToOneWithWhereWithoutAgentInput, AgentEmailAddressUpdateWithoutAgentInput>, AgentEmailAddressUncheckedUpdateWithoutAgentInput>
  }

  export type MeetingRecordingUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MeetingRecordingCreateWithoutAgentInput, MeetingRecordingUncheckedCreateWithoutAgentInput> | MeetingRecordingCreateWithoutAgentInput[] | MeetingRecordingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MeetingRecordingCreateOrConnectWithoutAgentInput | MeetingRecordingCreateOrConnectWithoutAgentInput[]
    upsert?: MeetingRecordingUpsertWithWhereUniqueWithoutAgentInput | MeetingRecordingUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MeetingRecordingCreateManyAgentInputEnvelope
    set?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    disconnect?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    delete?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    connect?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    update?: MeetingRecordingUpdateWithWhereUniqueWithoutAgentInput | MeetingRecordingUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MeetingRecordingUpdateManyWithWhereWithoutAgentInput | MeetingRecordingUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MeetingRecordingScalarWhereInput | MeetingRecordingScalarWhereInput[]
  }

  export type AgentPhoneNumberUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentPhoneNumberCreateWithoutAgentInput, AgentPhoneNumberUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentPhoneNumberCreateOrConnectWithoutAgentInput
    upsert?: AgentPhoneNumberUpsertWithoutAgentInput
    disconnect?: AgentPhoneNumberWhereInput | boolean
    delete?: AgentPhoneNumberWhereInput | boolean
    connect?: AgentPhoneNumberWhereUniqueInput
    update?: XOR<XOR<AgentPhoneNumberUpdateToOneWithWhereWithoutAgentInput, AgentPhoneNumberUpdateWithoutAgentInput>, AgentPhoneNumberUncheckedUpdateWithoutAgentInput>
  }

  export type AgentMetricUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentMetricCreateWithoutAgentInput, AgentMetricUncheckedCreateWithoutAgentInput> | AgentMetricCreateWithoutAgentInput[] | AgentMetricUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMetricCreateOrConnectWithoutAgentInput | AgentMetricCreateOrConnectWithoutAgentInput[]
    upsert?: AgentMetricUpsertWithWhereUniqueWithoutAgentInput | AgentMetricUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentMetricCreateManyAgentInputEnvelope
    set?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    disconnect?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    delete?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    connect?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    update?: AgentMetricUpdateWithWhereUniqueWithoutAgentInput | AgentMetricUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentMetricUpdateManyWithWhereWithoutAgentInput | AgentMetricUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentMetricScalarWhereInput | AgentMetricScalarWhereInput[]
  }

  export type AgentTraceUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentTraceCreateWithoutAgentInput, AgentTraceUncheckedCreateWithoutAgentInput> | AgentTraceCreateWithoutAgentInput[] | AgentTraceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutAgentInput | AgentTraceCreateOrConnectWithoutAgentInput[]
    upsert?: AgentTraceUpsertWithWhereUniqueWithoutAgentInput | AgentTraceUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentTraceCreateManyAgentInputEnvelope
    set?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    disconnect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    delete?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    update?: AgentTraceUpdateWithWhereUniqueWithoutAgentInput | AgentTraceUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentTraceUpdateManyWithWhereWithoutAgentInput | AgentTraceUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentTraceScalarWhereInput | AgentTraceScalarWhereInput[]
  }

  export type AgentInsightUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentInsightCreateWithoutAgentInput, AgentInsightUncheckedCreateWithoutAgentInput> | AgentInsightCreateWithoutAgentInput[] | AgentInsightUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentInsightCreateOrConnectWithoutAgentInput | AgentInsightCreateOrConnectWithoutAgentInput[]
    upsert?: AgentInsightUpsertWithWhereUniqueWithoutAgentInput | AgentInsightUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentInsightCreateManyAgentInputEnvelope
    set?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    disconnect?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    delete?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    connect?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    update?: AgentInsightUpdateWithWhereUniqueWithoutAgentInput | AgentInsightUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentInsightUpdateManyWithWhereWithoutAgentInput | AgentInsightUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentInsightScalarWhereInput | AgentInsightScalarWhereInput[]
  }

  export type AgentFeedbackUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentFeedbackCreateWithoutAgentInput, AgentFeedbackUncheckedCreateWithoutAgentInput> | AgentFeedbackCreateWithoutAgentInput[] | AgentFeedbackUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutAgentInput | AgentFeedbackCreateOrConnectWithoutAgentInput[]
    upsert?: AgentFeedbackUpsertWithWhereUniqueWithoutAgentInput | AgentFeedbackUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentFeedbackCreateManyAgentInputEnvelope
    set?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    disconnect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    delete?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    update?: AgentFeedbackUpdateWithWhereUniqueWithoutAgentInput | AgentFeedbackUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentFeedbackUpdateManyWithWhereWithoutAgentInput | AgentFeedbackUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
  }

  export type AgentABTestUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentABTestCreateWithoutAgentInput, AgentABTestUncheckedCreateWithoutAgentInput> | AgentABTestCreateWithoutAgentInput[] | AgentABTestUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentABTestCreateOrConnectWithoutAgentInput | AgentABTestCreateOrConnectWithoutAgentInput[]
    upsert?: AgentABTestUpsertWithWhereUniqueWithoutAgentInput | AgentABTestUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentABTestCreateManyAgentInputEnvelope
    set?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    disconnect?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    delete?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    connect?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    update?: AgentABTestUpdateWithWhereUniqueWithoutAgentInput | AgentABTestUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentABTestUpdateManyWithWhereWithoutAgentInput | AgentABTestUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentABTestScalarWhereInput | AgentABTestScalarWhereInput[]
  }

  export type OptimizationRunUpdateManyWithoutAgentNestedInput = {
    create?: XOR<OptimizationRunCreateWithoutAgentInput, OptimizationRunUncheckedCreateWithoutAgentInput> | OptimizationRunCreateWithoutAgentInput[] | OptimizationRunUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OptimizationRunCreateOrConnectWithoutAgentInput | OptimizationRunCreateOrConnectWithoutAgentInput[]
    upsert?: OptimizationRunUpsertWithWhereUniqueWithoutAgentInput | OptimizationRunUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: OptimizationRunCreateManyAgentInputEnvelope
    set?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    disconnect?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    delete?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    connect?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    update?: OptimizationRunUpdateWithWhereUniqueWithoutAgentInput | OptimizationRunUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: OptimizationRunUpdateManyWithWhereWithoutAgentInput | OptimizationRunUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: OptimizationRunScalarWhereInput | OptimizationRunScalarWhereInput[]
  }

  export type ModificationProposalUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ModificationProposalCreateWithoutAgentInput, ModificationProposalUncheckedCreateWithoutAgentInput> | ModificationProposalCreateWithoutAgentInput[] | ModificationProposalUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ModificationProposalCreateOrConnectWithoutAgentInput | ModificationProposalCreateOrConnectWithoutAgentInput[]
    upsert?: ModificationProposalUpsertWithWhereUniqueWithoutAgentInput | ModificationProposalUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ModificationProposalCreateManyAgentInputEnvelope
    set?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    disconnect?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    delete?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    connect?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    update?: ModificationProposalUpdateWithWhereUniqueWithoutAgentInput | ModificationProposalUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ModificationProposalUpdateManyWithWhereWithoutAgentInput | ModificationProposalUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ModificationProposalScalarWhereInput | ModificationProposalScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ConversationCreateWithoutAgentInput, ConversationUncheckedCreateWithoutAgentInput> | ConversationCreateWithoutAgentInput[] | ConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAgentInput | ConversationCreateOrConnectWithoutAgentInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutAgentInput | ConversationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ConversationCreateManyAgentInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutAgentInput | ConversationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutAgentInput | ConversationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type AgentToolUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentToolCreateWithoutAgentInput, AgentToolUncheckedCreateWithoutAgentInput> | AgentToolCreateWithoutAgentInput[] | AgentToolUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentToolCreateOrConnectWithoutAgentInput | AgentToolCreateOrConnectWithoutAgentInput[]
    upsert?: AgentToolUpsertWithWhereUniqueWithoutAgentInput | AgentToolUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentToolCreateManyAgentInputEnvelope
    set?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    disconnect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    delete?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    connect?: AgentToolWhereUniqueInput | AgentToolWhereUniqueInput[]
    update?: AgentToolUpdateWithWhereUniqueWithoutAgentInput | AgentToolUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentToolUpdateManyWithWhereWithoutAgentInput | AgentToolUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentToolScalarWhereInput | AgentToolScalarWhereInput[]
  }

  export type AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentMemoryCreateWithoutAgentInput, AgentMemoryUncheckedCreateWithoutAgentInput> | AgentMemoryCreateWithoutAgentInput[] | AgentMemoryUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMemoryCreateOrConnectWithoutAgentInput | AgentMemoryCreateOrConnectWithoutAgentInput[]
    upsert?: AgentMemoryUpsertWithWhereUniqueWithoutAgentInput | AgentMemoryUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentMemoryCreateManyAgentInputEnvelope
    set?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    disconnect?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    delete?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    connect?: AgentMemoryWhereUniqueInput | AgentMemoryWhereUniqueInput[]
    update?: AgentMemoryUpdateWithWhereUniqueWithoutAgentInput | AgentMemoryUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentMemoryUpdateManyWithWhereWithoutAgentInput | AgentMemoryUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentMemoryScalarWhereInput | AgentMemoryScalarWhereInput[]
  }

  export type KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<KnowledgeDocumentCreateWithoutAgentInput, KnowledgeDocumentUncheckedCreateWithoutAgentInput> | KnowledgeDocumentCreateWithoutAgentInput[] | KnowledgeDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeDocumentCreateOrConnectWithoutAgentInput | KnowledgeDocumentCreateOrConnectWithoutAgentInput[]
    upsert?: KnowledgeDocumentUpsertWithWhereUniqueWithoutAgentInput | KnowledgeDocumentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: KnowledgeDocumentCreateManyAgentInputEnvelope
    set?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    disconnect?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    delete?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    connect?: KnowledgeDocumentWhereUniqueInput | KnowledgeDocumentWhereUniqueInput[]
    update?: KnowledgeDocumentUpdateWithWhereUniqueWithoutAgentInput | KnowledgeDocumentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: KnowledgeDocumentUpdateManyWithWhereWithoutAgentInput | KnowledgeDocumentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: KnowledgeDocumentScalarWhereInput | KnowledgeDocumentScalarWhereInput[]
  }

  export type KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<KnowledgeSettingsCreateWithoutAgentInput, KnowledgeSettingsUncheckedCreateWithoutAgentInput>
    connectOrCreate?: KnowledgeSettingsCreateOrConnectWithoutAgentInput
    upsert?: KnowledgeSettingsUpsertWithoutAgentInput
    disconnect?: KnowledgeSettingsWhereInput | boolean
    delete?: KnowledgeSettingsWhereInput | boolean
    connect?: KnowledgeSettingsWhereUniqueInput
    update?: XOR<XOR<KnowledgeSettingsUpdateToOneWithWhereWithoutAgentInput, KnowledgeSettingsUpdateWithoutAgentInput>, KnowledgeSettingsUncheckedUpdateWithoutAgentInput>
  }

  export type AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentTriggerCreateWithoutAgentInput, AgentTriggerUncheckedCreateWithoutAgentInput> | AgentTriggerCreateWithoutAgentInput[] | AgentTriggerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTriggerCreateOrConnectWithoutAgentInput | AgentTriggerCreateOrConnectWithoutAgentInput[]
    upsert?: AgentTriggerUpsertWithWhereUniqueWithoutAgentInput | AgentTriggerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentTriggerCreateManyAgentInputEnvelope
    set?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    disconnect?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    delete?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    connect?: AgentTriggerWhereUniqueInput | AgentTriggerWhereUniqueInput[]
    update?: AgentTriggerUpdateWithWhereUniqueWithoutAgentInput | AgentTriggerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentTriggerUpdateManyWithWhereWithoutAgentInput | AgentTriggerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentTriggerScalarWhereInput | AgentTriggerScalarWhereInput[]
  }

  export type AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentEmbedCreateWithoutAgentInput, AgentEmbedUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmbedCreateOrConnectWithoutAgentInput
    upsert?: AgentEmbedUpsertWithoutAgentInput
    disconnect?: AgentEmbedWhereInput | boolean
    delete?: AgentEmbedWhereInput | boolean
    connect?: AgentEmbedWhereUniqueInput
    update?: XOR<XOR<AgentEmbedUpdateToOneWithWhereWithoutAgentInput, AgentEmbedUpdateWithoutAgentInput>, AgentEmbedUncheckedUpdateWithoutAgentInput>
  }

  export type AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput = {
    create?: XOR<AgentConnectionCreateWithoutSourceAgentInput, AgentConnectionUncheckedCreateWithoutSourceAgentInput> | AgentConnectionCreateWithoutSourceAgentInput[] | AgentConnectionUncheckedCreateWithoutSourceAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutSourceAgentInput | AgentConnectionCreateOrConnectWithoutSourceAgentInput[]
    upsert?: AgentConnectionUpsertWithWhereUniqueWithoutSourceAgentInput | AgentConnectionUpsertWithWhereUniqueWithoutSourceAgentInput[]
    createMany?: AgentConnectionCreateManySourceAgentInputEnvelope
    set?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    disconnect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    delete?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    update?: AgentConnectionUpdateWithWhereUniqueWithoutSourceAgentInput | AgentConnectionUpdateWithWhereUniqueWithoutSourceAgentInput[]
    updateMany?: AgentConnectionUpdateManyWithWhereWithoutSourceAgentInput | AgentConnectionUpdateManyWithWhereWithoutSourceAgentInput[]
    deleteMany?: AgentConnectionScalarWhereInput | AgentConnectionScalarWhereInput[]
  }

  export type AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput = {
    create?: XOR<AgentConnectionCreateWithoutTargetAgentInput, AgentConnectionUncheckedCreateWithoutTargetAgentInput> | AgentConnectionCreateWithoutTargetAgentInput[] | AgentConnectionUncheckedCreateWithoutTargetAgentInput[]
    connectOrCreate?: AgentConnectionCreateOrConnectWithoutTargetAgentInput | AgentConnectionCreateOrConnectWithoutTargetAgentInput[]
    upsert?: AgentConnectionUpsertWithWhereUniqueWithoutTargetAgentInput | AgentConnectionUpsertWithWhereUniqueWithoutTargetAgentInput[]
    createMany?: AgentConnectionCreateManyTargetAgentInputEnvelope
    set?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    disconnect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    delete?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    connect?: AgentConnectionWhereUniqueInput | AgentConnectionWhereUniqueInput[]
    update?: AgentConnectionUpdateWithWhereUniqueWithoutTargetAgentInput | AgentConnectionUpdateWithWhereUniqueWithoutTargetAgentInput[]
    updateMany?: AgentConnectionUpdateManyWithWhereWithoutTargetAgentInput | AgentConnectionUpdateManyWithWhereWithoutTargetAgentInput[]
    deleteMany?: AgentConnectionScalarWhereInput | AgentConnectionScalarWhereInput[]
  }

  export type AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentSwarmCreateWithoutAgentInput, AgentSwarmUncheckedCreateWithoutAgentInput> | AgentSwarmCreateWithoutAgentInput[] | AgentSwarmUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSwarmCreateOrConnectWithoutAgentInput | AgentSwarmCreateOrConnectWithoutAgentInput[]
    upsert?: AgentSwarmUpsertWithWhereUniqueWithoutAgentInput | AgentSwarmUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentSwarmCreateManyAgentInputEnvelope
    set?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    disconnect?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    delete?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    connect?: AgentSwarmWhereUniqueInput | AgentSwarmWhereUniqueInput[]
    update?: AgentSwarmUpdateWithWhereUniqueWithoutAgentInput | AgentSwarmUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentSwarmUpdateManyWithWhereWithoutAgentInput | AgentSwarmUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentSwarmScalarWhereInput | AgentSwarmScalarWhereInput[]
  }

  export type AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentEmailAddressCreateWithoutAgentInput, AgentEmailAddressUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentEmailAddressCreateOrConnectWithoutAgentInput
    upsert?: AgentEmailAddressUpsertWithoutAgentInput
    disconnect?: AgentEmailAddressWhereInput | boolean
    delete?: AgentEmailAddressWhereInput | boolean
    connect?: AgentEmailAddressWhereUniqueInput
    update?: XOR<XOR<AgentEmailAddressUpdateToOneWithWhereWithoutAgentInput, AgentEmailAddressUpdateWithoutAgentInput>, AgentEmailAddressUncheckedUpdateWithoutAgentInput>
  }

  export type MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MeetingRecordingCreateWithoutAgentInput, MeetingRecordingUncheckedCreateWithoutAgentInput> | MeetingRecordingCreateWithoutAgentInput[] | MeetingRecordingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MeetingRecordingCreateOrConnectWithoutAgentInput | MeetingRecordingCreateOrConnectWithoutAgentInput[]
    upsert?: MeetingRecordingUpsertWithWhereUniqueWithoutAgentInput | MeetingRecordingUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MeetingRecordingCreateManyAgentInputEnvelope
    set?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    disconnect?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    delete?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    connect?: MeetingRecordingWhereUniqueInput | MeetingRecordingWhereUniqueInput[]
    update?: MeetingRecordingUpdateWithWhereUniqueWithoutAgentInput | MeetingRecordingUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MeetingRecordingUpdateManyWithWhereWithoutAgentInput | MeetingRecordingUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MeetingRecordingScalarWhereInput | MeetingRecordingScalarWhereInput[]
  }

  export type AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentPhoneNumberCreateWithoutAgentInput, AgentPhoneNumberUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentPhoneNumberCreateOrConnectWithoutAgentInput
    upsert?: AgentPhoneNumberUpsertWithoutAgentInput
    disconnect?: AgentPhoneNumberWhereInput | boolean
    delete?: AgentPhoneNumberWhereInput | boolean
    connect?: AgentPhoneNumberWhereUniqueInput
    update?: XOR<XOR<AgentPhoneNumberUpdateToOneWithWhereWithoutAgentInput, AgentPhoneNumberUpdateWithoutAgentInput>, AgentPhoneNumberUncheckedUpdateWithoutAgentInput>
  }

  export type AgentMetricUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentMetricCreateWithoutAgentInput, AgentMetricUncheckedCreateWithoutAgentInput> | AgentMetricCreateWithoutAgentInput[] | AgentMetricUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentMetricCreateOrConnectWithoutAgentInput | AgentMetricCreateOrConnectWithoutAgentInput[]
    upsert?: AgentMetricUpsertWithWhereUniqueWithoutAgentInput | AgentMetricUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentMetricCreateManyAgentInputEnvelope
    set?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    disconnect?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    delete?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    connect?: AgentMetricWhereUniqueInput | AgentMetricWhereUniqueInput[]
    update?: AgentMetricUpdateWithWhereUniqueWithoutAgentInput | AgentMetricUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentMetricUpdateManyWithWhereWithoutAgentInput | AgentMetricUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentMetricScalarWhereInput | AgentMetricScalarWhereInput[]
  }

  export type AgentTraceUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentTraceCreateWithoutAgentInput, AgentTraceUncheckedCreateWithoutAgentInput> | AgentTraceCreateWithoutAgentInput[] | AgentTraceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutAgentInput | AgentTraceCreateOrConnectWithoutAgentInput[]
    upsert?: AgentTraceUpsertWithWhereUniqueWithoutAgentInput | AgentTraceUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentTraceCreateManyAgentInputEnvelope
    set?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    disconnect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    delete?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    update?: AgentTraceUpdateWithWhereUniqueWithoutAgentInput | AgentTraceUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentTraceUpdateManyWithWhereWithoutAgentInput | AgentTraceUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentTraceScalarWhereInput | AgentTraceScalarWhereInput[]
  }

  export type AgentInsightUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentInsightCreateWithoutAgentInput, AgentInsightUncheckedCreateWithoutAgentInput> | AgentInsightCreateWithoutAgentInput[] | AgentInsightUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentInsightCreateOrConnectWithoutAgentInput | AgentInsightCreateOrConnectWithoutAgentInput[]
    upsert?: AgentInsightUpsertWithWhereUniqueWithoutAgentInput | AgentInsightUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentInsightCreateManyAgentInputEnvelope
    set?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    disconnect?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    delete?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    connect?: AgentInsightWhereUniqueInput | AgentInsightWhereUniqueInput[]
    update?: AgentInsightUpdateWithWhereUniqueWithoutAgentInput | AgentInsightUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentInsightUpdateManyWithWhereWithoutAgentInput | AgentInsightUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentInsightScalarWhereInput | AgentInsightScalarWhereInput[]
  }

  export type AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentFeedbackCreateWithoutAgentInput, AgentFeedbackUncheckedCreateWithoutAgentInput> | AgentFeedbackCreateWithoutAgentInput[] | AgentFeedbackUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutAgentInput | AgentFeedbackCreateOrConnectWithoutAgentInput[]
    upsert?: AgentFeedbackUpsertWithWhereUniqueWithoutAgentInput | AgentFeedbackUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentFeedbackCreateManyAgentInputEnvelope
    set?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    disconnect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    delete?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    update?: AgentFeedbackUpdateWithWhereUniqueWithoutAgentInput | AgentFeedbackUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentFeedbackUpdateManyWithWhereWithoutAgentInput | AgentFeedbackUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
  }

  export type AgentABTestUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentABTestCreateWithoutAgentInput, AgentABTestUncheckedCreateWithoutAgentInput> | AgentABTestCreateWithoutAgentInput[] | AgentABTestUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentABTestCreateOrConnectWithoutAgentInput | AgentABTestCreateOrConnectWithoutAgentInput[]
    upsert?: AgentABTestUpsertWithWhereUniqueWithoutAgentInput | AgentABTestUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentABTestCreateManyAgentInputEnvelope
    set?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    disconnect?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    delete?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    connect?: AgentABTestWhereUniqueInput | AgentABTestWhereUniqueInput[]
    update?: AgentABTestUpdateWithWhereUniqueWithoutAgentInput | AgentABTestUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentABTestUpdateManyWithWhereWithoutAgentInput | AgentABTestUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentABTestScalarWhereInput | AgentABTestScalarWhereInput[]
  }

  export type OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<OptimizationRunCreateWithoutAgentInput, OptimizationRunUncheckedCreateWithoutAgentInput> | OptimizationRunCreateWithoutAgentInput[] | OptimizationRunUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OptimizationRunCreateOrConnectWithoutAgentInput | OptimizationRunCreateOrConnectWithoutAgentInput[]
    upsert?: OptimizationRunUpsertWithWhereUniqueWithoutAgentInput | OptimizationRunUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: OptimizationRunCreateManyAgentInputEnvelope
    set?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    disconnect?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    delete?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    connect?: OptimizationRunWhereUniqueInput | OptimizationRunWhereUniqueInput[]
    update?: OptimizationRunUpdateWithWhereUniqueWithoutAgentInput | OptimizationRunUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: OptimizationRunUpdateManyWithWhereWithoutAgentInput | OptimizationRunUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: OptimizationRunScalarWhereInput | OptimizationRunScalarWhereInput[]
  }

  export type ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ModificationProposalCreateWithoutAgentInput, ModificationProposalUncheckedCreateWithoutAgentInput> | ModificationProposalCreateWithoutAgentInput[] | ModificationProposalUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ModificationProposalCreateOrConnectWithoutAgentInput | ModificationProposalCreateOrConnectWithoutAgentInput[]
    upsert?: ModificationProposalUpsertWithWhereUniqueWithoutAgentInput | ModificationProposalUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ModificationProposalCreateManyAgentInputEnvelope
    set?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    disconnect?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    delete?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    connect?: ModificationProposalWhereUniqueInput | ModificationProposalWhereUniqueInput[]
    update?: ModificationProposalUpdateWithWhereUniqueWithoutAgentInput | ModificationProposalUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ModificationProposalUpdateManyWithWhereWithoutAgentInput | ModificationProposalUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ModificationProposalScalarWhereInput | ModificationProposalScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutConnectedToInput = {
    create?: XOR<AgentCreateWithoutConnectedToInput, AgentUncheckedCreateWithoutConnectedToInput>
    connectOrCreate?: AgentCreateOrConnectWithoutConnectedToInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutConnectedFromInput = {
    create?: XOR<AgentCreateWithoutConnectedFromInput, AgentUncheckedCreateWithoutConnectedFromInput>
    connectOrCreate?: AgentCreateOrConnectWithoutConnectedFromInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutConnectedToNestedInput = {
    create?: XOR<AgentCreateWithoutConnectedToInput, AgentUncheckedCreateWithoutConnectedToInput>
    connectOrCreate?: AgentCreateOrConnectWithoutConnectedToInput
    upsert?: AgentUpsertWithoutConnectedToInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutConnectedToInput, AgentUpdateWithoutConnectedToInput>, AgentUncheckedUpdateWithoutConnectedToInput>
  }

  export type AgentUpdateOneRequiredWithoutConnectedFromNestedInput = {
    create?: XOR<AgentCreateWithoutConnectedFromInput, AgentUncheckedCreateWithoutConnectedFromInput>
    connectOrCreate?: AgentCreateOrConnectWithoutConnectedFromInput
    upsert?: AgentUpsertWithoutConnectedFromInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutConnectedFromInput, AgentUpdateWithoutConnectedFromInput>, AgentUncheckedUpdateWithoutConnectedFromInput>
  }

  export type AgentCreateNestedOneWithoutAgentToolsInput = {
    create?: XOR<AgentCreateWithoutAgentToolsInput, AgentUncheckedCreateWithoutAgentToolsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentToolsInput
    connect?: AgentWhereUniqueInput
  }

  export type WorkflowCreateNestedOneWithoutAgentToolsInput = {
    create?: XOR<WorkflowCreateWithoutAgentToolsInput, WorkflowUncheckedCreateWithoutAgentToolsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutAgentToolsInput
    connect?: WorkflowWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutAgentToolsNestedInput = {
    create?: XOR<AgentCreateWithoutAgentToolsInput, AgentUncheckedCreateWithoutAgentToolsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentToolsInput
    upsert?: AgentUpsertWithoutAgentToolsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAgentToolsInput, AgentUpdateWithoutAgentToolsInput>, AgentUncheckedUpdateWithoutAgentToolsInput>
  }

  export type WorkflowUpdateOneWithoutAgentToolsNestedInput = {
    create?: XOR<WorkflowCreateWithoutAgentToolsInput, WorkflowUncheckedCreateWithoutAgentToolsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutAgentToolsInput
    upsert?: WorkflowUpsertWithoutAgentToolsInput
    disconnect?: WorkflowWhereInput | boolean
    delete?: WorkflowWhereInput | boolean
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutAgentToolsInput, WorkflowUpdateWithoutAgentToolsInput>, WorkflowUncheckedUpdateWithoutAgentToolsInput>
  }

  export type AgentCreateNestedOneWithoutConversationsInput = {
    create?: XOR<AgentCreateWithoutConversationsInput, AgentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutConversationsInput
    connect?: AgentWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationActivityCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationActivityCreateWithoutConversationInput, ConversationActivityUncheckedCreateWithoutConversationInput> | ConversationActivityCreateWithoutConversationInput[] | ConversationActivityUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationActivityCreateOrConnectWithoutConversationInput | ConversationActivityCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationActivityCreateManyConversationInputEnvelope
    connect?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
  }

  export type AgentTraceCreateNestedManyWithoutConversationInput = {
    create?: XOR<AgentTraceCreateWithoutConversationInput, AgentTraceUncheckedCreateWithoutConversationInput> | AgentTraceCreateWithoutConversationInput[] | AgentTraceUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutConversationInput | AgentTraceCreateOrConnectWithoutConversationInput[]
    createMany?: AgentTraceCreateManyConversationInputEnvelope
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
  }

  export type ConversationEvaluationCreateNestedOneWithoutConversationInput = {
    create?: XOR<ConversationEvaluationCreateWithoutConversationInput, ConversationEvaluationUncheckedCreateWithoutConversationInput>
    connectOrCreate?: ConversationEvaluationCreateOrConnectWithoutConversationInput
    connect?: ConversationEvaluationWhereUniqueInput
  }

  export type AgentFeedbackCreateNestedManyWithoutConversationInput = {
    create?: XOR<AgentFeedbackCreateWithoutConversationInput, AgentFeedbackUncheckedCreateWithoutConversationInput> | AgentFeedbackCreateWithoutConversationInput[] | AgentFeedbackUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutConversationInput | AgentFeedbackCreateOrConnectWithoutConversationInput[]
    createMany?: AgentFeedbackCreateManyConversationInputEnvelope
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationActivityUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationActivityCreateWithoutConversationInput, ConversationActivityUncheckedCreateWithoutConversationInput> | ConversationActivityCreateWithoutConversationInput[] | ConversationActivityUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationActivityCreateOrConnectWithoutConversationInput | ConversationActivityCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationActivityCreateManyConversationInputEnvelope
    connect?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
  }

  export type AgentTraceUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<AgentTraceCreateWithoutConversationInput, AgentTraceUncheckedCreateWithoutConversationInput> | AgentTraceCreateWithoutConversationInput[] | AgentTraceUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutConversationInput | AgentTraceCreateOrConnectWithoutConversationInput[]
    createMany?: AgentTraceCreateManyConversationInputEnvelope
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
  }

  export type ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput = {
    create?: XOR<ConversationEvaluationCreateWithoutConversationInput, ConversationEvaluationUncheckedCreateWithoutConversationInput>
    connectOrCreate?: ConversationEvaluationCreateOrConnectWithoutConversationInput
    connect?: ConversationEvaluationWhereUniqueInput
  }

  export type AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<AgentFeedbackCreateWithoutConversationInput, AgentFeedbackUncheckedCreateWithoutConversationInput> | AgentFeedbackCreateWithoutConversationInput[] | AgentFeedbackUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutConversationInput | AgentFeedbackCreateOrConnectWithoutConversationInput[]
    createMany?: AgentFeedbackCreateManyConversationInputEnvelope
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
  }

  export type EnumConversationSourceFieldUpdateOperationsInput = {
    set?: $Enums.ConversationSource
  }

  export type AgentUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<AgentCreateWithoutConversationsInput, AgentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutConversationsInput
    upsert?: AgentUpsertWithoutConversationsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutConversationsInput, AgentUpdateWithoutConversationsInput>, AgentUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationActivityUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationActivityCreateWithoutConversationInput, ConversationActivityUncheckedCreateWithoutConversationInput> | ConversationActivityCreateWithoutConversationInput[] | ConversationActivityUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationActivityCreateOrConnectWithoutConversationInput | ConversationActivityCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationActivityUpsertWithWhereUniqueWithoutConversationInput | ConversationActivityUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationActivityCreateManyConversationInputEnvelope
    set?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    disconnect?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    delete?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    connect?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    update?: ConversationActivityUpdateWithWhereUniqueWithoutConversationInput | ConversationActivityUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationActivityUpdateManyWithWhereWithoutConversationInput | ConversationActivityUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationActivityScalarWhereInput | ConversationActivityScalarWhereInput[]
  }

  export type AgentTraceUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AgentTraceCreateWithoutConversationInput, AgentTraceUncheckedCreateWithoutConversationInput> | AgentTraceCreateWithoutConversationInput[] | AgentTraceUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutConversationInput | AgentTraceCreateOrConnectWithoutConversationInput[]
    upsert?: AgentTraceUpsertWithWhereUniqueWithoutConversationInput | AgentTraceUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AgentTraceCreateManyConversationInputEnvelope
    set?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    disconnect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    delete?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    update?: AgentTraceUpdateWithWhereUniqueWithoutConversationInput | AgentTraceUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AgentTraceUpdateManyWithWhereWithoutConversationInput | AgentTraceUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AgentTraceScalarWhereInput | AgentTraceScalarWhereInput[]
  }

  export type ConversationEvaluationUpdateOneWithoutConversationNestedInput = {
    create?: XOR<ConversationEvaluationCreateWithoutConversationInput, ConversationEvaluationUncheckedCreateWithoutConversationInput>
    connectOrCreate?: ConversationEvaluationCreateOrConnectWithoutConversationInput
    upsert?: ConversationEvaluationUpsertWithoutConversationInput
    disconnect?: ConversationEvaluationWhereInput | boolean
    delete?: ConversationEvaluationWhereInput | boolean
    connect?: ConversationEvaluationWhereUniqueInput
    update?: XOR<XOR<ConversationEvaluationUpdateToOneWithWhereWithoutConversationInput, ConversationEvaluationUpdateWithoutConversationInput>, ConversationEvaluationUncheckedUpdateWithoutConversationInput>
  }

  export type AgentFeedbackUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AgentFeedbackCreateWithoutConversationInput, AgentFeedbackUncheckedCreateWithoutConversationInput> | AgentFeedbackCreateWithoutConversationInput[] | AgentFeedbackUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutConversationInput | AgentFeedbackCreateOrConnectWithoutConversationInput[]
    upsert?: AgentFeedbackUpsertWithWhereUniqueWithoutConversationInput | AgentFeedbackUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AgentFeedbackCreateManyConversationInputEnvelope
    set?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    disconnect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    delete?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    update?: AgentFeedbackUpdateWithWhereUniqueWithoutConversationInput | AgentFeedbackUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AgentFeedbackUpdateManyWithWhereWithoutConversationInput | AgentFeedbackUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationActivityCreateWithoutConversationInput, ConversationActivityUncheckedCreateWithoutConversationInput> | ConversationActivityCreateWithoutConversationInput[] | ConversationActivityUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationActivityCreateOrConnectWithoutConversationInput | ConversationActivityCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationActivityUpsertWithWhereUniqueWithoutConversationInput | ConversationActivityUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationActivityCreateManyConversationInputEnvelope
    set?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    disconnect?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    delete?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    connect?: ConversationActivityWhereUniqueInput | ConversationActivityWhereUniqueInput[]
    update?: ConversationActivityUpdateWithWhereUniqueWithoutConversationInput | ConversationActivityUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationActivityUpdateManyWithWhereWithoutConversationInput | ConversationActivityUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationActivityScalarWhereInput | ConversationActivityScalarWhereInput[]
  }

  export type AgentTraceUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AgentTraceCreateWithoutConversationInput, AgentTraceUncheckedCreateWithoutConversationInput> | AgentTraceCreateWithoutConversationInput[] | AgentTraceUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentTraceCreateOrConnectWithoutConversationInput | AgentTraceCreateOrConnectWithoutConversationInput[]
    upsert?: AgentTraceUpsertWithWhereUniqueWithoutConversationInput | AgentTraceUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AgentTraceCreateManyConversationInputEnvelope
    set?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    disconnect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    delete?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    connect?: AgentTraceWhereUniqueInput | AgentTraceWhereUniqueInput[]
    update?: AgentTraceUpdateWithWhereUniqueWithoutConversationInput | AgentTraceUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AgentTraceUpdateManyWithWhereWithoutConversationInput | AgentTraceUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AgentTraceScalarWhereInput | AgentTraceScalarWhereInput[]
  }

  export type ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput = {
    create?: XOR<ConversationEvaluationCreateWithoutConversationInput, ConversationEvaluationUncheckedCreateWithoutConversationInput>
    connectOrCreate?: ConversationEvaluationCreateOrConnectWithoutConversationInput
    upsert?: ConversationEvaluationUpsertWithoutConversationInput
    disconnect?: ConversationEvaluationWhereInput | boolean
    delete?: ConversationEvaluationWhereInput | boolean
    connect?: ConversationEvaluationWhereUniqueInput
    update?: XOR<XOR<ConversationEvaluationUpdateToOneWithWhereWithoutConversationInput, ConversationEvaluationUpdateWithoutConversationInput>, ConversationEvaluationUncheckedUpdateWithoutConversationInput>
  }

  export type AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AgentFeedbackCreateWithoutConversationInput, AgentFeedbackUncheckedCreateWithoutConversationInput> | AgentFeedbackCreateWithoutConversationInput[] | AgentFeedbackUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutConversationInput | AgentFeedbackCreateOrConnectWithoutConversationInput[]
    upsert?: AgentFeedbackUpsertWithWhereUniqueWithoutConversationInput | AgentFeedbackUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AgentFeedbackCreateManyConversationInputEnvelope
    set?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    disconnect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    delete?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    update?: AgentFeedbackUpdateWithWhereUniqueWithoutConversationInput | AgentFeedbackUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AgentFeedbackUpdateManyWithWhereWithoutConversationInput | AgentFeedbackUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumMessageRoleFieldUpdateOperationsInput = {
    set?: $Enums.MessageRole
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ConversationCreateWithoutActivitiesInput, ConversationUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutActivitiesInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type ConversationUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ConversationCreateWithoutActivitiesInput, ConversationUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutActivitiesInput
    upsert?: ConversationUpsertWithoutActivitiesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutActivitiesInput, ConversationUpdateWithoutActivitiesInput>, ConversationUncheckedUpdateWithoutActivitiesInput>
  }

  export type AgentMemoryCreateembeddingInput = {
    set: number[]
  }

  export type AgentCreateNestedOneWithoutMemoriesInput = {
    create?: XOR<AgentCreateWithoutMemoriesInput, AgentUncheckedCreateWithoutMemoriesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMemoriesInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumMemoryCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MemoryCategory
  }

  export type AgentMemoryUpdateembeddingInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AgentUpdateOneRequiredWithoutMemoriesNestedInput = {
    create?: XOR<AgentCreateWithoutMemoriesInput, AgentUncheckedCreateWithoutMemoriesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMemoriesInput
    upsert?: AgentUpsertWithoutMemoriesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMemoriesInput, AgentUpdateWithoutMemoriesInput>, AgentUncheckedUpdateWithoutMemoriesInput>
  }

  export type AgentCreateNestedOneWithoutKnowledgeDocumentsInput = {
    create?: XOR<AgentCreateWithoutKnowledgeDocumentsInput, AgentUncheckedCreateWithoutKnowledgeDocumentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutKnowledgeDocumentsInput
    connect?: AgentWhereUniqueInput
  }

  export type KnowledgeChunkCreateNestedManyWithoutDocumentInput = {
    create?: XOR<KnowledgeChunkCreateWithoutDocumentInput, KnowledgeChunkUncheckedCreateWithoutDocumentInput> | KnowledgeChunkCreateWithoutDocumentInput[] | KnowledgeChunkUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutDocumentInput | KnowledgeChunkCreateOrConnectWithoutDocumentInput[]
    createMany?: KnowledgeChunkCreateManyDocumentInputEnvelope
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
  }

  export type KnowledgeChunkUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<KnowledgeChunkCreateWithoutDocumentInput, KnowledgeChunkUncheckedCreateWithoutDocumentInput> | KnowledgeChunkCreateWithoutDocumentInput[] | KnowledgeChunkUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutDocumentInput | KnowledgeChunkCreateOrConnectWithoutDocumentInput[]
    createMany?: KnowledgeChunkCreateManyDocumentInputEnvelope
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
  }

  export type EnumKnowledgeSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.KnowledgeSourceType
  }

  export type EnumKnowledgeSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.KnowledgeSyncStatus
  }

  export type AgentUpdateOneRequiredWithoutKnowledgeDocumentsNestedInput = {
    create?: XOR<AgentCreateWithoutKnowledgeDocumentsInput, AgentUncheckedCreateWithoutKnowledgeDocumentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutKnowledgeDocumentsInput
    upsert?: AgentUpsertWithoutKnowledgeDocumentsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutKnowledgeDocumentsInput, AgentUpdateWithoutKnowledgeDocumentsInput>, AgentUncheckedUpdateWithoutKnowledgeDocumentsInput>
  }

  export type KnowledgeChunkUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<KnowledgeChunkCreateWithoutDocumentInput, KnowledgeChunkUncheckedCreateWithoutDocumentInput> | KnowledgeChunkCreateWithoutDocumentInput[] | KnowledgeChunkUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutDocumentInput | KnowledgeChunkCreateOrConnectWithoutDocumentInput[]
    upsert?: KnowledgeChunkUpsertWithWhereUniqueWithoutDocumentInput | KnowledgeChunkUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: KnowledgeChunkCreateManyDocumentInputEnvelope
    set?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    disconnect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    delete?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    update?: KnowledgeChunkUpdateWithWhereUniqueWithoutDocumentInput | KnowledgeChunkUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: KnowledgeChunkUpdateManyWithWhereWithoutDocumentInput | KnowledgeChunkUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
  }

  export type KnowledgeChunkUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<KnowledgeChunkCreateWithoutDocumentInput, KnowledgeChunkUncheckedCreateWithoutDocumentInput> | KnowledgeChunkCreateWithoutDocumentInput[] | KnowledgeChunkUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutDocumentInput | KnowledgeChunkCreateOrConnectWithoutDocumentInput[]
    upsert?: KnowledgeChunkUpsertWithWhereUniqueWithoutDocumentInput | KnowledgeChunkUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: KnowledgeChunkCreateManyDocumentInputEnvelope
    set?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    disconnect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    delete?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    update?: KnowledgeChunkUpdateWithWhereUniqueWithoutDocumentInput | KnowledgeChunkUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: KnowledgeChunkUpdateManyWithWhereWithoutDocumentInput | KnowledgeChunkUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
  }

  export type KnowledgeChunkCreateembeddingInput = {
    set: number[]
  }

  export type KnowledgeDocumentCreateNestedOneWithoutChunksInput = {
    create?: XOR<KnowledgeDocumentCreateWithoutChunksInput, KnowledgeDocumentUncheckedCreateWithoutChunksInput>
    connectOrCreate?: KnowledgeDocumentCreateOrConnectWithoutChunksInput
    connect?: KnowledgeDocumentWhereUniqueInput
  }

  export type KnowledgeChunkUpdateembeddingInput = {
    set?: number[]
    push?: number | number[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KnowledgeDocumentUpdateOneRequiredWithoutChunksNestedInput = {
    create?: XOR<KnowledgeDocumentCreateWithoutChunksInput, KnowledgeDocumentUncheckedCreateWithoutChunksInput>
    connectOrCreate?: KnowledgeDocumentCreateOrConnectWithoutChunksInput
    upsert?: KnowledgeDocumentUpsertWithoutChunksInput
    connect?: KnowledgeDocumentWhereUniqueInput
    update?: XOR<XOR<KnowledgeDocumentUpdateToOneWithWhereWithoutChunksInput, KnowledgeDocumentUpdateWithoutChunksInput>, KnowledgeDocumentUncheckedUpdateWithoutChunksInput>
  }

  export type AgentCreateNestedOneWithoutKnowledgeSettingsInput = {
    create?: XOR<AgentCreateWithoutKnowledgeSettingsInput, AgentUncheckedCreateWithoutKnowledgeSettingsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutKnowledgeSettingsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutKnowledgeSettingsNestedInput = {
    create?: XOR<AgentCreateWithoutKnowledgeSettingsInput, AgentUncheckedCreateWithoutKnowledgeSettingsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutKnowledgeSettingsInput
    upsert?: AgentUpsertWithoutKnowledgeSettingsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutKnowledgeSettingsInput, AgentUpdateWithoutKnowledgeSettingsInput>, AgentUncheckedUpdateWithoutKnowledgeSettingsInput>
  }

  export type AgentCreateNestedOneWithoutTriggersInput = {
    create?: XOR<AgentCreateWithoutTriggersInput, AgentUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTriggersInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.TriggerType
  }

  export type AgentUpdateOneRequiredWithoutTriggersNestedInput = {
    create?: XOR<AgentCreateWithoutTriggersInput, AgentUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTriggersInput
    upsert?: AgentUpsertWithoutTriggersInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTriggersInput, AgentUpdateWithoutTriggersInput>, AgentUncheckedUpdateWithoutTriggersInput>
  }

  export type AgentTemplateCreatesuggestedIntegrationsInput = {
    set: string[]
  }

  export type AgentTemplateCreatetagsInput = {
    set: string[]
  }

  export type AgentCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AgentCreateWithoutTemplateInput, AgentUncheckedCreateWithoutTemplateInput> | AgentCreateWithoutTemplateInput[] | AgentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTemplateInput | AgentCreateOrConnectWithoutTemplateInput[]
    createMany?: AgentCreateManyTemplateInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AgentCreateWithoutTemplateInput, AgentUncheckedCreateWithoutTemplateInput> | AgentCreateWithoutTemplateInput[] | AgentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTemplateInput | AgentCreateOrConnectWithoutTemplateInput[]
    createMany?: AgentCreateManyTemplateInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type EnumTemplateCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TemplateCategory
  }

  export type NullableEnumTemplateRoleFieldUpdateOperationsInput = {
    set?: $Enums.TemplateRole | null
  }

  export type NullableEnumTemplateUseCaseFieldUpdateOperationsInput = {
    set?: $Enums.TemplateUseCase | null
  }

  export type AgentTemplateUpdatesuggestedIntegrationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentTemplateUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AgentCreateWithoutTemplateInput, AgentUncheckedCreateWithoutTemplateInput> | AgentCreateWithoutTemplateInput[] | AgentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTemplateInput | AgentCreateOrConnectWithoutTemplateInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutTemplateInput | AgentUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AgentCreateManyTemplateInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutTemplateInput | AgentUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutTemplateInput | AgentUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AgentCreateWithoutTemplateInput, AgentUncheckedCreateWithoutTemplateInput> | AgentCreateWithoutTemplateInput[] | AgentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTemplateInput | AgentCreateOrConnectWithoutTemplateInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutTemplateInput | AgentUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AgentCreateManyTemplateInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutTemplateInput | AgentUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutTemplateInput | AgentUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AgentEmbedCreateallowedDomainsInput = {
    set: string[]
  }

  export type AgentCreateNestedOneWithoutEmbedInput = {
    create?: XOR<AgentCreateWithoutEmbedInput, AgentUncheckedCreateWithoutEmbedInput>
    connectOrCreate?: AgentCreateOrConnectWithoutEmbedInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentEmbedUpdateallowedDomainsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumEmbedPositionFieldUpdateOperationsInput = {
    set?: $Enums.EmbedPosition
  }

  export type AgentUpdateOneRequiredWithoutEmbedNestedInput = {
    create?: XOR<AgentCreateWithoutEmbedInput, AgentUncheckedCreateWithoutEmbedInput>
    connectOrCreate?: AgentCreateOrConnectWithoutEmbedInput
    upsert?: AgentUpsertWithoutEmbedInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutEmbedInput, AgentUpdateWithoutEmbedInput>, AgentUncheckedUpdateWithoutEmbedInput>
  }

  export type AgentCreateNestedOneWithoutEmailAddressInput = {
    create?: XOR<AgentCreateWithoutEmailAddressInput, AgentUncheckedCreateWithoutEmailAddressInput>
    connectOrCreate?: AgentCreateOrConnectWithoutEmailAddressInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutEmailAddressNestedInput = {
    create?: XOR<AgentCreateWithoutEmailAddressInput, AgentUncheckedCreateWithoutEmailAddressInput>
    connectOrCreate?: AgentCreateOrConnectWithoutEmailAddressInput
    upsert?: AgentUpsertWithoutEmailAddressInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutEmailAddressInput, AgentUpdateWithoutEmailAddressInput>, AgentUncheckedUpdateWithoutEmailAddressInput>
  }

  export type IntegrationCreatescopesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationType
  }

  export type IntegrationUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationsInput
    upsert?: UserUpsertWithoutIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIntegrationsInput, UserUpdateWithoutIntegrationsInput>, UserUncheckedUpdateWithoutIntegrationsInput>
  }

  export type AgentCreateNestedOneWithoutSwarmsInput = {
    create?: XOR<AgentCreateWithoutSwarmsInput, AgentUncheckedCreateWithoutSwarmsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSwarmsInput
    connect?: AgentWhereUniqueInput
  }

  export type SwarmTaskCreateNestedManyWithoutSwarmInput = {
    create?: XOR<SwarmTaskCreateWithoutSwarmInput, SwarmTaskUncheckedCreateWithoutSwarmInput> | SwarmTaskCreateWithoutSwarmInput[] | SwarmTaskUncheckedCreateWithoutSwarmInput[]
    connectOrCreate?: SwarmTaskCreateOrConnectWithoutSwarmInput | SwarmTaskCreateOrConnectWithoutSwarmInput[]
    createMany?: SwarmTaskCreateManySwarmInputEnvelope
    connect?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
  }

  export type SwarmTaskUncheckedCreateNestedManyWithoutSwarmInput = {
    create?: XOR<SwarmTaskCreateWithoutSwarmInput, SwarmTaskUncheckedCreateWithoutSwarmInput> | SwarmTaskCreateWithoutSwarmInput[] | SwarmTaskUncheckedCreateWithoutSwarmInput[]
    connectOrCreate?: SwarmTaskCreateOrConnectWithoutSwarmInput | SwarmTaskCreateOrConnectWithoutSwarmInput[]
    createMany?: SwarmTaskCreateManySwarmInputEnvelope
    connect?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
  }

  export type EnumSwarmStatusFieldUpdateOperationsInput = {
    set?: $Enums.SwarmStatus
  }

  export type AgentUpdateOneRequiredWithoutSwarmsNestedInput = {
    create?: XOR<AgentCreateWithoutSwarmsInput, AgentUncheckedCreateWithoutSwarmsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSwarmsInput
    upsert?: AgentUpsertWithoutSwarmsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutSwarmsInput, AgentUpdateWithoutSwarmsInput>, AgentUncheckedUpdateWithoutSwarmsInput>
  }

  export type SwarmTaskUpdateManyWithoutSwarmNestedInput = {
    create?: XOR<SwarmTaskCreateWithoutSwarmInput, SwarmTaskUncheckedCreateWithoutSwarmInput> | SwarmTaskCreateWithoutSwarmInput[] | SwarmTaskUncheckedCreateWithoutSwarmInput[]
    connectOrCreate?: SwarmTaskCreateOrConnectWithoutSwarmInput | SwarmTaskCreateOrConnectWithoutSwarmInput[]
    upsert?: SwarmTaskUpsertWithWhereUniqueWithoutSwarmInput | SwarmTaskUpsertWithWhereUniqueWithoutSwarmInput[]
    createMany?: SwarmTaskCreateManySwarmInputEnvelope
    set?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    disconnect?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    delete?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    connect?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    update?: SwarmTaskUpdateWithWhereUniqueWithoutSwarmInput | SwarmTaskUpdateWithWhereUniqueWithoutSwarmInput[]
    updateMany?: SwarmTaskUpdateManyWithWhereWithoutSwarmInput | SwarmTaskUpdateManyWithWhereWithoutSwarmInput[]
    deleteMany?: SwarmTaskScalarWhereInput | SwarmTaskScalarWhereInput[]
  }

  export type SwarmTaskUncheckedUpdateManyWithoutSwarmNestedInput = {
    create?: XOR<SwarmTaskCreateWithoutSwarmInput, SwarmTaskUncheckedCreateWithoutSwarmInput> | SwarmTaskCreateWithoutSwarmInput[] | SwarmTaskUncheckedCreateWithoutSwarmInput[]
    connectOrCreate?: SwarmTaskCreateOrConnectWithoutSwarmInput | SwarmTaskCreateOrConnectWithoutSwarmInput[]
    upsert?: SwarmTaskUpsertWithWhereUniqueWithoutSwarmInput | SwarmTaskUpsertWithWhereUniqueWithoutSwarmInput[]
    createMany?: SwarmTaskCreateManySwarmInputEnvelope
    set?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    disconnect?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    delete?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    connect?: SwarmTaskWhereUniqueInput | SwarmTaskWhereUniqueInput[]
    update?: SwarmTaskUpdateWithWhereUniqueWithoutSwarmInput | SwarmTaskUpdateWithWhereUniqueWithoutSwarmInput[]
    updateMany?: SwarmTaskUpdateManyWithWhereWithoutSwarmInput | SwarmTaskUpdateManyWithWhereWithoutSwarmInput[]
    deleteMany?: SwarmTaskScalarWhereInput | SwarmTaskScalarWhereInput[]
  }

  export type AgentSwarmCreateNestedOneWithoutTasksInput = {
    create?: XOR<AgentSwarmCreateWithoutTasksInput, AgentSwarmUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AgentSwarmCreateOrConnectWithoutTasksInput
    connect?: AgentSwarmWhereUniqueInput
  }

  export type EnumSwarmTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.SwarmTaskStatus
  }

  export type AgentSwarmUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<AgentSwarmCreateWithoutTasksInput, AgentSwarmUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AgentSwarmCreateOrConnectWithoutTasksInput
    upsert?: AgentSwarmUpsertWithoutTasksInput
    connect?: AgentSwarmWhereUniqueInput
    update?: XOR<XOR<AgentSwarmUpdateToOneWithWhereWithoutTasksInput, AgentSwarmUpdateWithoutTasksInput>, AgentSwarmUncheckedUpdateWithoutTasksInput>
  }

  export type AgentCreateNestedOneWithoutMeetingRecordingsInput = {
    create?: XOR<AgentCreateWithoutMeetingRecordingsInput, AgentUncheckedCreateWithoutMeetingRecordingsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMeetingRecordingsInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumMeetingPlatformFieldUpdateOperationsInput = {
    set?: $Enums.MeetingPlatform
  }

  export type EnumRecordingStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecordingStatus
  }

  export type AgentUpdateOneRequiredWithoutMeetingRecordingsNestedInput = {
    create?: XOR<AgentCreateWithoutMeetingRecordingsInput, AgentUncheckedCreateWithoutMeetingRecordingsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMeetingRecordingsInput
    upsert?: AgentUpsertWithoutMeetingRecordingsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMeetingRecordingsInput, AgentUpdateWithoutMeetingRecordingsInput>, AgentUncheckedUpdateWithoutMeetingRecordingsInput>
  }

  export type AgentCreateNestedOneWithoutPhoneNumberInput = {
    create?: XOR<AgentCreateWithoutPhoneNumberInput, AgentUncheckedCreateWithoutPhoneNumberInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPhoneNumberInput
    connect?: AgentWhereUniqueInput
  }

  export type PhoneCallCreateNestedManyWithoutPhoneNumberInput = {
    create?: XOR<PhoneCallCreateWithoutPhoneNumberInput, PhoneCallUncheckedCreateWithoutPhoneNumberInput> | PhoneCallCreateWithoutPhoneNumberInput[] | PhoneCallUncheckedCreateWithoutPhoneNumberInput[]
    connectOrCreate?: PhoneCallCreateOrConnectWithoutPhoneNumberInput | PhoneCallCreateOrConnectWithoutPhoneNumberInput[]
    createMany?: PhoneCallCreateManyPhoneNumberInputEnvelope
    connect?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
  }

  export type PhoneCallUncheckedCreateNestedManyWithoutPhoneNumberInput = {
    create?: XOR<PhoneCallCreateWithoutPhoneNumberInput, PhoneCallUncheckedCreateWithoutPhoneNumberInput> | PhoneCallCreateWithoutPhoneNumberInput[] | PhoneCallUncheckedCreateWithoutPhoneNumberInput[]
    connectOrCreate?: PhoneCallCreateOrConnectWithoutPhoneNumberInput | PhoneCallCreateOrConnectWithoutPhoneNumberInput[]
    createMany?: PhoneCallCreateManyPhoneNumberInputEnvelope
    connect?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
  }

  export type AgentUpdateOneRequiredWithoutPhoneNumberNestedInput = {
    create?: XOR<AgentCreateWithoutPhoneNumberInput, AgentUncheckedCreateWithoutPhoneNumberInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPhoneNumberInput
    upsert?: AgentUpsertWithoutPhoneNumberInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPhoneNumberInput, AgentUpdateWithoutPhoneNumberInput>, AgentUncheckedUpdateWithoutPhoneNumberInput>
  }

  export type PhoneCallUpdateManyWithoutPhoneNumberNestedInput = {
    create?: XOR<PhoneCallCreateWithoutPhoneNumberInput, PhoneCallUncheckedCreateWithoutPhoneNumberInput> | PhoneCallCreateWithoutPhoneNumberInput[] | PhoneCallUncheckedCreateWithoutPhoneNumberInput[]
    connectOrCreate?: PhoneCallCreateOrConnectWithoutPhoneNumberInput | PhoneCallCreateOrConnectWithoutPhoneNumberInput[]
    upsert?: PhoneCallUpsertWithWhereUniqueWithoutPhoneNumberInput | PhoneCallUpsertWithWhereUniqueWithoutPhoneNumberInput[]
    createMany?: PhoneCallCreateManyPhoneNumberInputEnvelope
    set?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    disconnect?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    delete?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    connect?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    update?: PhoneCallUpdateWithWhereUniqueWithoutPhoneNumberInput | PhoneCallUpdateWithWhereUniqueWithoutPhoneNumberInput[]
    updateMany?: PhoneCallUpdateManyWithWhereWithoutPhoneNumberInput | PhoneCallUpdateManyWithWhereWithoutPhoneNumberInput[]
    deleteMany?: PhoneCallScalarWhereInput | PhoneCallScalarWhereInput[]
  }

  export type PhoneCallUncheckedUpdateManyWithoutPhoneNumberNestedInput = {
    create?: XOR<PhoneCallCreateWithoutPhoneNumberInput, PhoneCallUncheckedCreateWithoutPhoneNumberInput> | PhoneCallCreateWithoutPhoneNumberInput[] | PhoneCallUncheckedCreateWithoutPhoneNumberInput[]
    connectOrCreate?: PhoneCallCreateOrConnectWithoutPhoneNumberInput | PhoneCallCreateOrConnectWithoutPhoneNumberInput[]
    upsert?: PhoneCallUpsertWithWhereUniqueWithoutPhoneNumberInput | PhoneCallUpsertWithWhereUniqueWithoutPhoneNumberInput[]
    createMany?: PhoneCallCreateManyPhoneNumberInputEnvelope
    set?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    disconnect?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    delete?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    connect?: PhoneCallWhereUniqueInput | PhoneCallWhereUniqueInput[]
    update?: PhoneCallUpdateWithWhereUniqueWithoutPhoneNumberInput | PhoneCallUpdateWithWhereUniqueWithoutPhoneNumberInput[]
    updateMany?: PhoneCallUpdateManyWithWhereWithoutPhoneNumberInput | PhoneCallUpdateManyWithWhereWithoutPhoneNumberInput[]
    deleteMany?: PhoneCallScalarWhereInput | PhoneCallScalarWhereInput[]
  }

  export type AgentPhoneNumberCreateNestedOneWithoutCallsInput = {
    create?: XOR<AgentPhoneNumberCreateWithoutCallsInput, AgentPhoneNumberUncheckedCreateWithoutCallsInput>
    connectOrCreate?: AgentPhoneNumberCreateOrConnectWithoutCallsInput
    connect?: AgentPhoneNumberWhereUniqueInput
  }

  export type EnumCallDirectionFieldUpdateOperationsInput = {
    set?: $Enums.CallDirection
  }

  export type EnumCallStatusFieldUpdateOperationsInput = {
    set?: $Enums.CallStatus
  }

  export type AgentPhoneNumberUpdateOneRequiredWithoutCallsNestedInput = {
    create?: XOR<AgentPhoneNumberCreateWithoutCallsInput, AgentPhoneNumberUncheckedCreateWithoutCallsInput>
    connectOrCreate?: AgentPhoneNumberCreateOrConnectWithoutCallsInput
    upsert?: AgentPhoneNumberUpsertWithoutCallsInput
    connect?: AgentPhoneNumberWhereUniqueInput
    update?: XOR<XOR<AgentPhoneNumberUpdateToOneWithWhereWithoutCallsInput, AgentPhoneNumberUpdateWithoutCallsInput>, AgentPhoneNumberUncheckedUpdateWithoutCallsInput>
  }

  export type AgentCreateNestedOneWithoutMetricsInput = {
    create?: XOR<AgentCreateWithoutMetricsInput, AgentUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMetricsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<AgentCreateWithoutMetricsInput, AgentUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMetricsInput
    upsert?: AgentUpsertWithoutMetricsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMetricsInput, AgentUpdateWithoutMetricsInput>, AgentUncheckedUpdateWithoutMetricsInput>
  }

  export type EnumScanCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ScanCategory
  }

  export type EnumSignalSeverityFieldUpdateOperationsInput = {
    set?: $Enums.SignalSeverity
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AgentTraceCreateNestedOneWithoutAiEventsInput = {
    create?: XOR<AgentTraceCreateWithoutAiEventsInput, AgentTraceUncheckedCreateWithoutAiEventsInput>
    connectOrCreate?: AgentTraceCreateOrConnectWithoutAiEventsInput
    connect?: AgentTraceWhereUniqueInput
  }

  export type AgentTraceUpdateOneWithoutAiEventsNestedInput = {
    create?: XOR<AgentTraceCreateWithoutAiEventsInput, AgentTraceUncheckedCreateWithoutAiEventsInput>
    connectOrCreate?: AgentTraceCreateOrConnectWithoutAiEventsInput
    upsert?: AgentTraceUpsertWithoutAiEventsInput
    disconnect?: AgentTraceWhereInput | boolean
    delete?: AgentTraceWhereInput | boolean
    connect?: AgentTraceWhereUniqueInput
    update?: XOR<XOR<AgentTraceUpdateToOneWithWhereWithoutAiEventsInput, AgentTraceUpdateWithoutAiEventsInput>, AgentTraceUncheckedUpdateWithoutAiEventsInput>
  }

  export type AgentCreateNestedOneWithoutTracesInput = {
    create?: XOR<AgentCreateWithoutTracesInput, AgentUncheckedCreateWithoutTracesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTracesInput
    connect?: AgentWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutTracesInput = {
    create?: XOR<ConversationCreateWithoutTracesInput, ConversationUncheckedCreateWithoutTracesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutTracesInput
    connect?: ConversationWhereUniqueInput
  }

  export type AiEventCreateNestedManyWithoutTraceInput = {
    create?: XOR<AiEventCreateWithoutTraceInput, AiEventUncheckedCreateWithoutTraceInput> | AiEventCreateWithoutTraceInput[] | AiEventUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AiEventCreateOrConnectWithoutTraceInput | AiEventCreateOrConnectWithoutTraceInput[]
    createMany?: AiEventCreateManyTraceInputEnvelope
    connect?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
  }

  export type AgentFeedbackCreateNestedManyWithoutTraceInput = {
    create?: XOR<AgentFeedbackCreateWithoutTraceInput, AgentFeedbackUncheckedCreateWithoutTraceInput> | AgentFeedbackCreateWithoutTraceInput[] | AgentFeedbackUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutTraceInput | AgentFeedbackCreateOrConnectWithoutTraceInput[]
    createMany?: AgentFeedbackCreateManyTraceInputEnvelope
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
  }

  export type AiEventUncheckedCreateNestedManyWithoutTraceInput = {
    create?: XOR<AiEventCreateWithoutTraceInput, AiEventUncheckedCreateWithoutTraceInput> | AiEventCreateWithoutTraceInput[] | AiEventUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AiEventCreateOrConnectWithoutTraceInput | AiEventCreateOrConnectWithoutTraceInput[]
    createMany?: AiEventCreateManyTraceInputEnvelope
    connect?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
  }

  export type AgentFeedbackUncheckedCreateNestedManyWithoutTraceInput = {
    create?: XOR<AgentFeedbackCreateWithoutTraceInput, AgentFeedbackUncheckedCreateWithoutTraceInput> | AgentFeedbackCreateWithoutTraceInput[] | AgentFeedbackUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutTraceInput | AgentFeedbackCreateOrConnectWithoutTraceInput[]
    createMany?: AgentFeedbackCreateManyTraceInputEnvelope
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
  }

  export type EnumTraceStatusFieldUpdateOperationsInput = {
    set?: $Enums.TraceStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgentUpdateOneRequiredWithoutTracesNestedInput = {
    create?: XOR<AgentCreateWithoutTracesInput, AgentUncheckedCreateWithoutTracesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTracesInput
    upsert?: AgentUpsertWithoutTracesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTracesInput, AgentUpdateWithoutTracesInput>, AgentUncheckedUpdateWithoutTracesInput>
  }

  export type ConversationUpdateOneRequiredWithoutTracesNestedInput = {
    create?: XOR<ConversationCreateWithoutTracesInput, ConversationUncheckedCreateWithoutTracesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutTracesInput
    upsert?: ConversationUpsertWithoutTracesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutTracesInput, ConversationUpdateWithoutTracesInput>, ConversationUncheckedUpdateWithoutTracesInput>
  }

  export type AiEventUpdateManyWithoutTraceNestedInput = {
    create?: XOR<AiEventCreateWithoutTraceInput, AiEventUncheckedCreateWithoutTraceInput> | AiEventCreateWithoutTraceInput[] | AiEventUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AiEventCreateOrConnectWithoutTraceInput | AiEventCreateOrConnectWithoutTraceInput[]
    upsert?: AiEventUpsertWithWhereUniqueWithoutTraceInput | AiEventUpsertWithWhereUniqueWithoutTraceInput[]
    createMany?: AiEventCreateManyTraceInputEnvelope
    set?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    disconnect?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    delete?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    connect?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    update?: AiEventUpdateWithWhereUniqueWithoutTraceInput | AiEventUpdateWithWhereUniqueWithoutTraceInput[]
    updateMany?: AiEventUpdateManyWithWhereWithoutTraceInput | AiEventUpdateManyWithWhereWithoutTraceInput[]
    deleteMany?: AiEventScalarWhereInput | AiEventScalarWhereInput[]
  }

  export type AgentFeedbackUpdateManyWithoutTraceNestedInput = {
    create?: XOR<AgentFeedbackCreateWithoutTraceInput, AgentFeedbackUncheckedCreateWithoutTraceInput> | AgentFeedbackCreateWithoutTraceInput[] | AgentFeedbackUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutTraceInput | AgentFeedbackCreateOrConnectWithoutTraceInput[]
    upsert?: AgentFeedbackUpsertWithWhereUniqueWithoutTraceInput | AgentFeedbackUpsertWithWhereUniqueWithoutTraceInput[]
    createMany?: AgentFeedbackCreateManyTraceInputEnvelope
    set?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    disconnect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    delete?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    update?: AgentFeedbackUpdateWithWhereUniqueWithoutTraceInput | AgentFeedbackUpdateWithWhereUniqueWithoutTraceInput[]
    updateMany?: AgentFeedbackUpdateManyWithWhereWithoutTraceInput | AgentFeedbackUpdateManyWithWhereWithoutTraceInput[]
    deleteMany?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
  }

  export type AiEventUncheckedUpdateManyWithoutTraceNestedInput = {
    create?: XOR<AiEventCreateWithoutTraceInput, AiEventUncheckedCreateWithoutTraceInput> | AiEventCreateWithoutTraceInput[] | AiEventUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AiEventCreateOrConnectWithoutTraceInput | AiEventCreateOrConnectWithoutTraceInput[]
    upsert?: AiEventUpsertWithWhereUniqueWithoutTraceInput | AiEventUpsertWithWhereUniqueWithoutTraceInput[]
    createMany?: AiEventCreateManyTraceInputEnvelope
    set?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    disconnect?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    delete?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    connect?: AiEventWhereUniqueInput | AiEventWhereUniqueInput[]
    update?: AiEventUpdateWithWhereUniqueWithoutTraceInput | AiEventUpdateWithWhereUniqueWithoutTraceInput[]
    updateMany?: AiEventUpdateManyWithWhereWithoutTraceInput | AiEventUpdateManyWithWhereWithoutTraceInput[]
    deleteMany?: AiEventScalarWhereInput | AiEventScalarWhereInput[]
  }

  export type AgentFeedbackUncheckedUpdateManyWithoutTraceNestedInput = {
    create?: XOR<AgentFeedbackCreateWithoutTraceInput, AgentFeedbackUncheckedCreateWithoutTraceInput> | AgentFeedbackCreateWithoutTraceInput[] | AgentFeedbackUncheckedCreateWithoutTraceInput[]
    connectOrCreate?: AgentFeedbackCreateOrConnectWithoutTraceInput | AgentFeedbackCreateOrConnectWithoutTraceInput[]
    upsert?: AgentFeedbackUpsertWithWhereUniqueWithoutTraceInput | AgentFeedbackUpsertWithWhereUniqueWithoutTraceInput[]
    createMany?: AgentFeedbackCreateManyTraceInputEnvelope
    set?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    disconnect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    delete?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    connect?: AgentFeedbackWhereUniqueInput | AgentFeedbackWhereUniqueInput[]
    update?: AgentFeedbackUpdateWithWhereUniqueWithoutTraceInput | AgentFeedbackUpdateWithWhereUniqueWithoutTraceInput[]
    updateMany?: AgentFeedbackUpdateManyWithWhereWithoutTraceInput | AgentFeedbackUpdateManyWithWhereWithoutTraceInput[]
    deleteMany?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
  }

  export type ConversationEvaluationCreatecategoriesInput = {
    set: string[]
  }

  export type ConversationEvaluationCreatefailureModesInput = {
    set: string[]
  }

  export type ConversationEvaluationCreateimprovementSuggestionsInput = {
    set: string[]
  }

  export type ConversationCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<ConversationCreateWithoutEvaluationInput, ConversationUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutEvaluationInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationEvaluationUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConversationEvaluationUpdatefailureModesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConversationEvaluationUpdateimprovementSuggestionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConversationUpdateOneRequiredWithoutEvaluationNestedInput = {
    create?: XOR<ConversationCreateWithoutEvaluationInput, ConversationUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutEvaluationInput
    upsert?: ConversationUpsertWithoutEvaluationInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutEvaluationInput, ConversationUpdateWithoutEvaluationInput>, ConversationUncheckedUpdateWithoutEvaluationInput>
  }

  export type AgentCreateNestedOneWithoutInsightsInput = {
    create?: XOR<AgentCreateWithoutInsightsInput, AgentUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutInsightsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<AgentCreateWithoutInsightsInput, AgentUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutInsightsInput
    upsert?: AgentUpsertWithoutInsightsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutInsightsInput, AgentUpdateWithoutInsightsInput>, AgentUncheckedUpdateWithoutInsightsInput>
  }

  export type AgentTraceCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<AgentTraceCreateWithoutFeedbacksInput, AgentTraceUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: AgentTraceCreateOrConnectWithoutFeedbacksInput
    connect?: AgentTraceWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<ConversationCreateWithoutFeedbacksInput, ConversationUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutFeedbacksInput
    connect?: ConversationWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<AgentCreateWithoutFeedbacksInput, AgentUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: AgentCreateOrConnectWithoutFeedbacksInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type AgentTraceUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<AgentTraceCreateWithoutFeedbacksInput, AgentTraceUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: AgentTraceCreateOrConnectWithoutFeedbacksInput
    upsert?: AgentTraceUpsertWithoutFeedbacksInput
    connect?: AgentTraceWhereUniqueInput
    update?: XOR<XOR<AgentTraceUpdateToOneWithWhereWithoutFeedbacksInput, AgentTraceUpdateWithoutFeedbacksInput>, AgentTraceUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ConversationUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<ConversationCreateWithoutFeedbacksInput, ConversationUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutFeedbacksInput
    upsert?: ConversationUpsertWithoutFeedbacksInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutFeedbacksInput, ConversationUpdateWithoutFeedbacksInput>, ConversationUncheckedUpdateWithoutFeedbacksInput>
  }

  export type AgentUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<AgentCreateWithoutFeedbacksInput, AgentUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: AgentCreateOrConnectWithoutFeedbacksInput
    upsert?: AgentUpsertWithoutFeedbacksInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutFeedbacksInput, AgentUpdateWithoutFeedbacksInput>, AgentUncheckedUpdateWithoutFeedbacksInput>
  }

  export type AgentCreateNestedOneWithoutAbTestsInput = {
    create?: XOR<AgentCreateWithoutAbTestsInput, AgentUncheckedCreateWithoutAbTestsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAbTestsInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumABTestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ABTestStatus
  }

  export type AgentUpdateOneRequiredWithoutAbTestsNestedInput = {
    create?: XOR<AgentCreateWithoutAbTestsInput, AgentUncheckedCreateWithoutAbTestsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAbTestsInput
    upsert?: AgentUpsertWithoutAbTestsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAbTestsInput, AgentUpdateWithoutAbTestsInput>, AgentUncheckedUpdateWithoutAbTestsInput>
  }

  export type AgentCreateNestedOneWithoutOptimizationRunsInput = {
    create?: XOR<AgentCreateWithoutOptimizationRunsInput, AgentUncheckedCreateWithoutOptimizationRunsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutOptimizationRunsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutOptimizationRunsNestedInput = {
    create?: XOR<AgentCreateWithoutOptimizationRunsInput, AgentUncheckedCreateWithoutOptimizationRunsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutOptimizationRunsInput
    upsert?: AgentUpsertWithoutOptimizationRunsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutOptimizationRunsInput, AgentUpdateWithoutOptimizationRunsInput>, AgentUncheckedUpdateWithoutOptimizationRunsInput>
  }

  export type AgentCreateNestedOneWithoutModificationProposalsInput = {
    create?: XOR<AgentCreateWithoutModificationProposalsInput, AgentUncheckedCreateWithoutModificationProposalsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutModificationProposalsInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumModificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ModificationType
  }

  export type EnumProposalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProposalStatus
  }

  export type AgentUpdateOneRequiredWithoutModificationProposalsNestedInput = {
    create?: XOR<AgentCreateWithoutModificationProposalsInput, AgentUncheckedCreateWithoutModificationProposalsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutModificationProposalsInput
    upsert?: AgentUpsertWithoutModificationProposalsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutModificationProposalsInput, AgentUpdateWithoutModificationProposalsInput>, AgentUncheckedUpdateWithoutModificationProposalsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCredentialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeFilter<$PrismaModel> | $Enums.CredentialType
  }

  export type NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel> | $Enums.CredentialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialTypeFilter<$PrismaModel>
    _max?: NestedEnumCredentialTypeFilter<$PrismaModel>
  }

  export type NestedEnumNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeFilter<$PrismaModel> | $Enums.NodeType
  }

  export type NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.NodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExecutionStatusFilter<$PrismaModel> | $Enums.ExecutionStatus
  }

  export type NestedEnumExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumExecutionStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAgentModelFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentModel | EnumAgentModelFieldRefInput<$PrismaModel>
    in?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentModelFilter<$PrismaModel> | $Enums.AgentModel
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAgentModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentModel | EnumAgentModelFieldRefInput<$PrismaModel>
    in?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentModel[] | ListEnumAgentModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentModelWithAggregatesFilter<$PrismaModel> | $Enums.AgentModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentModelFilter<$PrismaModel>
    _max?: NestedEnumAgentModelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumConversationSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationSource | EnumConversationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationSourceFilter<$PrismaModel> | $Enums.ConversationSource
  }

  export type NestedEnumConversationSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationSource | EnumConversationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationSource[] | ListEnumConversationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationSourceWithAggregatesFilter<$PrismaModel> | $Enums.ConversationSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationSourceFilter<$PrismaModel>
    _max?: NestedEnumConversationSourceFilter<$PrismaModel>
  }

  export type NestedEnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumMemoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MemoryCategory | EnumMemoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMemoryCategoryFilter<$PrismaModel> | $Enums.MemoryCategory
  }

  export type NestedEnumMemoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemoryCategory | EnumMemoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemoryCategory[] | ListEnumMemoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMemoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MemoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumMemoryCategoryFilter<$PrismaModel>
  }

  export type NestedEnumKnowledgeSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSourceType | EnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSourceTypeFilter<$PrismaModel> | $Enums.KnowledgeSourceType
  }

  export type NestedEnumKnowledgeSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSyncStatus | EnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSyncStatusFilter<$PrismaModel> | $Enums.KnowledgeSyncStatus
  }

  export type NestedEnumKnowledgeSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSourceType | EnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSourceType[] | ListEnumKnowledgeSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeSourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumKnowledgeSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeSyncStatus | EnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeSyncStatus[] | ListEnumKnowledgeSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeSyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeSyncStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeFilter<$PrismaModel> | $Enums.TriggerType
  }

  export type NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumTemplateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateCategory | EnumTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTemplateCategoryFilter<$PrismaModel> | $Enums.TemplateCategory
  }

  export type NestedEnumTemplateRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableFilter<$PrismaModel> | $Enums.TemplateRole | null
  }

  export type NestedEnumTemplateUseCaseNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateUseCase | EnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateUseCaseNullableFilter<$PrismaModel> | $Enums.TemplateUseCase | null
  }

  export type NestedEnumTemplateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateCategory | EnumTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TemplateCategory[] | ListEnumTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTemplateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TemplateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTemplateCategoryFilter<$PrismaModel>
    _max?: NestedEnumTemplateCategoryFilter<$PrismaModel>
  }

  export type NestedEnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemplateRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumTemplateUseCaseNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateUseCase | EnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateUseCase[] | ListEnumTemplateUseCaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateUseCaseNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemplateUseCase | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemplateUseCaseNullableFilter<$PrismaModel>
    _max?: NestedEnumTemplateUseCaseNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmbedPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbedPosition | EnumEmbedPositionFieldRefInput<$PrismaModel>
    in?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbedPositionFilter<$PrismaModel> | $Enums.EmbedPosition
  }

  export type NestedEnumEmbedPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbedPosition | EnumEmbedPositionFieldRefInput<$PrismaModel>
    in?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbedPosition[] | ListEnumEmbedPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbedPositionWithAggregatesFilter<$PrismaModel> | $Enums.EmbedPosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmbedPositionFilter<$PrismaModel>
    _max?: NestedEnumEmbedPositionFilter<$PrismaModel>
  }

  export type NestedEnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSwarmStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmStatus | EnumSwarmStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmStatusFilter<$PrismaModel> | $Enums.SwarmStatus
  }

  export type NestedEnumSwarmStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmStatus | EnumSwarmStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmStatus[] | ListEnumSwarmStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmStatusWithAggregatesFilter<$PrismaModel> | $Enums.SwarmStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSwarmStatusFilter<$PrismaModel>
    _max?: NestedEnumSwarmStatusFilter<$PrismaModel>
  }

  export type NestedEnumSwarmTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmTaskStatus | EnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmTaskStatusFilter<$PrismaModel> | $Enums.SwarmTaskStatus
  }

  export type NestedEnumSwarmTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SwarmTaskStatus | EnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SwarmTaskStatus[] | ListEnumSwarmTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwarmTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.SwarmTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSwarmTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumSwarmTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumMeetingPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingPlatform | EnumMeetingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingPlatformFilter<$PrismaModel> | $Enums.MeetingPlatform
  }

  export type NestedEnumRecordingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusFilter<$PrismaModel> | $Enums.RecordingStatus
  }

  export type NestedEnumMeetingPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingPlatform | EnumMeetingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingPlatform[] | ListEnumMeetingPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingPlatformWithAggregatesFilter<$PrismaModel> | $Enums.MeetingPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingPlatformFilter<$PrismaModel>
    _max?: NestedEnumMeetingPlatformFilter<$PrismaModel>
  }

  export type NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecordingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingStatusFilter<$PrismaModel>
    _max?: NestedEnumRecordingStatusFilter<$PrismaModel>
  }

  export type NestedEnumCallDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionFilter<$PrismaModel> | $Enums.CallDirection
  }

  export type NestedEnumCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusFilter<$PrismaModel> | $Enums.CallStatus
  }

  export type NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CallDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallDirectionFilter<$PrismaModel>
    _max?: NestedEnumCallDirectionFilter<$PrismaModel>
  }

  export type NestedEnumCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallStatusFilter<$PrismaModel>
    _max?: NestedEnumCallStatusFilter<$PrismaModel>
  }

  export type NestedEnumScanCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanCategory | EnumScanCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumScanCategoryFilter<$PrismaModel> | $Enums.ScanCategory
  }

  export type NestedEnumScanCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanCategory | EnumScanCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanCategory[] | ListEnumScanCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumScanCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ScanCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScanCategoryFilter<$PrismaModel>
    _max?: NestedEnumScanCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSignalSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SignalSeverity | EnumSignalSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSignalSeverityFilter<$PrismaModel> | $Enums.SignalSeverity
  }

  export type NestedEnumSignalSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignalSeverity | EnumSignalSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignalSeverity[] | ListEnumSignalSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSignalSeverityWithAggregatesFilter<$PrismaModel> | $Enums.SignalSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignalSeverityFilter<$PrismaModel>
    _max?: NestedEnumSignalSeverityFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTraceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TraceStatus | EnumTraceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTraceStatusFilter<$PrismaModel> | $Enums.TraceStatus
  }

  export type NestedEnumTraceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TraceStatus | EnumTraceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TraceStatus[] | ListEnumTraceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTraceStatusWithAggregatesFilter<$PrismaModel> | $Enums.TraceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTraceStatusFilter<$PrismaModel>
    _max?: NestedEnumTraceStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumABTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ABTestStatus | EnumABTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumABTestStatusFilter<$PrismaModel> | $Enums.ABTestStatus
  }

  export type NestedEnumABTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ABTestStatus | EnumABTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABTestStatus[] | ListEnumABTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumABTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ABTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumABTestStatusFilter<$PrismaModel>
    _max?: NestedEnumABTestStatusFilter<$PrismaModel>
  }

  export type NestedEnumModificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModificationTypeFilter<$PrismaModel> | $Enums.ModificationType
  }

  export type NestedEnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type NestedEnumModificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModificationType[] | ListEnumModificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModificationTypeFilter<$PrismaModel>
    _max?: NestedEnumModificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: NodeCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionUncheckedCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutUserInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput>
  }

  export type WorkflowCreateManyUserInputEnvelope = {
    data: WorkflowCreateManyUserInput | WorkflowCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CredentialCreateWithoutUserInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    Node?: NodeCreateNestedManyWithoutCredentialInput
    agents?: AgentCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    Node?: NodeUncheckedCreateNestedManyWithoutCredentialInput
    agents?: AgentUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutUserInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
  }

  export type CredentialCreateManyUserInputEnvelope = {
    data: CredentialCreateManyUserInput | CredentialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentCreateManyUserInputEnvelope = {
    data: AgentCreateManyUserInput | AgentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutUserInput = {
    id?: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    accountEmail?: string | null
    accountName?: string | null
    scopes?: IntegrationCreatescopesInput | string[]
    teamId?: string | null
    teamName?: string | null
    botUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    accountEmail?: string | null
    accountName?: string | null
    scopes?: IntegrationCreatescopesInput | string[]
    teamId?: string | null
    teamName?: string | null
    botUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCreateManyUserInputEnvelope = {
    data: IntegrationCreateManyUserInput | IntegrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutUserInput, WorkflowUncheckedUpdateWithoutUserInput>
    create: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutUserInput, WorkflowUncheckedUpdateWithoutUserInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutUserInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    userId?: StringFilter<"Workflow"> | string
  }

  export type CredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: CredentialWhereUniqueInput
    update: XOR<CredentialUpdateWithoutUserInput, CredentialUncheckedUpdateWithoutUserInput>
    create: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
  }

  export type CredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: CredentialWhereUniqueInput
    data: XOR<CredentialUpdateWithoutUserInput, CredentialUncheckedUpdateWithoutUserInput>
  }

  export type CredentialUpdateManyWithWhereWithoutUserInput = {
    where: CredentialScalarWhereInput
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyWithoutUserInput>
  }

  export type CredentialScalarWhereInput = {
    AND?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
    OR?: CredentialScalarWhereInput[]
    NOT?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
    id?: StringFilter<"Credential"> | string
    name?: StringFilter<"Credential"> | string
    value?: StringFilter<"Credential"> | string
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    userId?: StringFilter<"Credential"> | string
  }

  export type AgentUpsertWithWhereUniqueWithoutUserInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutUserInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateManyWithWhereWithoutUserInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutUserInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    systemPrompt?: StringFilter<"Agent"> | string
    context?: StringNullableFilter<"Agent"> | string | null
    model?: EnumAgentModelFilter<"Agent"> | $Enums.AgentModel
    temperature?: FloatFilter<"Agent"> | number
    safeMode?: BoolFilter<"Agent"> | boolean
    llmTier?: StringNullableFilter<"Agent"> | string | null
    maxStepsPerRun?: IntNullableFilter<"Agent"> | number | null
    evalRules?: JsonNullableFilter<"Agent">
    workspaceId?: StringNullableFilter<"Agent"> | string | null
    avatar?: StringNullableFilter<"Agent"> | string | null
    tags?: StringNullableListFilter<"Agent">
    isFavorite?: BoolFilter<"Agent"> | boolean
    isEnabled?: BoolFilter<"Agent"> | boolean
    templateId?: StringNullableFilter<"Agent"> | string | null
    flowData?: JsonNullableFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    userId?: StringFilter<"Agent"> | string
    credentialId?: StringNullableFilter<"Agent"> | string | null
  }

  export type IntegrationUpsertWithWhereUniqueWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutUserInput, IntegrationUncheckedUpdateWithoutUserInput>
    create: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutUserInput, IntegrationUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutUserInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutUserInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    userId?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    accessToken?: StringFilter<"Integration"> | string
    refreshToken?: StringNullableFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    accountEmail?: StringNullableFilter<"Integration"> | string | null
    accountName?: StringNullableFilter<"Integration"> | string | null
    scopes?: StringNullableListFilter<"Integration">
    teamId?: StringNullableFilter<"Integration"> | string | null
    teamName?: StringNullableFilter<"Integration"> | string | null
    botUserId?: StringNullableFilter<"Integration"> | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCredentialsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCredentialsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
  }

  export type NodeCreateWithoutCredentialInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    outputConnections?: ConnectionCreateNestedManyWithoutFromNodeInput
    inputConnections?: ConnectionCreateNestedManyWithoutToNodeInput
  }

  export type NodeUncheckedCreateWithoutCredentialInput = {
    id?: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    outputConnections?: ConnectionUncheckedCreateNestedManyWithoutFromNodeInput
    inputConnections?: ConnectionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type NodeCreateOrConnectWithoutCredentialInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutCredentialInput, NodeUncheckedCreateWithoutCredentialInput>
  }

  export type NodeCreateManyCredentialInputEnvelope = {
    data: NodeCreateManyCredentialInput | NodeCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutCredentialInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutCredentialInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutCredentialInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCredentialInput, AgentUncheckedCreateWithoutCredentialInput>
  }

  export type AgentCreateManyCredentialInputEnvelope = {
    data: AgentCreateManyCredentialInput | AgentCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCredentialsInput = {
    update: XOR<UserUpdateWithoutCredentialsInput, UserUncheckedUpdateWithoutCredentialsInput>
    create: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCredentialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCredentialsInput, UserUncheckedUpdateWithoutCredentialsInput>
  }

  export type UserUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NodeUpsertWithWhereUniqueWithoutCredentialInput = {
    where: NodeWhereUniqueInput
    update: XOR<NodeUpdateWithoutCredentialInput, NodeUncheckedUpdateWithoutCredentialInput>
    create: XOR<NodeCreateWithoutCredentialInput, NodeUncheckedCreateWithoutCredentialInput>
  }

  export type NodeUpdateWithWhereUniqueWithoutCredentialInput = {
    where: NodeWhereUniqueInput
    data: XOR<NodeUpdateWithoutCredentialInput, NodeUncheckedUpdateWithoutCredentialInput>
  }

  export type NodeUpdateManyWithWhereWithoutCredentialInput = {
    where: NodeScalarWhereInput
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutCredentialInput>
  }

  export type NodeScalarWhereInput = {
    AND?: NodeScalarWhereInput | NodeScalarWhereInput[]
    OR?: NodeScalarWhereInput[]
    NOT?: NodeScalarWhereInput | NodeScalarWhereInput[]
    id?: StringFilter<"Node"> | string
    workflowId?: StringFilter<"Node"> | string
    name?: StringFilter<"Node"> | string
    type?: EnumNodeTypeFilter<"Node"> | $Enums.NodeType
    position?: JsonFilter<"Node">
    data?: JsonFilter<"Node">
    credentialId?: StringNullableFilter<"Node"> | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
  }

  export type AgentUpsertWithWhereUniqueWithoutCredentialInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutCredentialInput, AgentUncheckedUpdateWithoutCredentialInput>
    create: XOR<AgentCreateWithoutCredentialInput, AgentUncheckedCreateWithoutCredentialInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutCredentialInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutCredentialInput, AgentUncheckedUpdateWithoutCredentialInput>
  }

  export type AgentUpdateManyWithWhereWithoutCredentialInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutCredentialInput>
  }

  export type NodeCreateWithoutWorkflowInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    credential?: CredentialCreateNestedOneWithoutNodeInput
    outputConnections?: ConnectionCreateNestedManyWithoutFromNodeInput
    inputConnections?: ConnectionCreateNestedManyWithoutToNodeInput
  }

  export type NodeUncheckedCreateWithoutWorkflowInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outputConnections?: ConnectionUncheckedCreateNestedManyWithoutFromNodeInput
    inputConnections?: ConnectionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type NodeCreateOrConnectWithoutWorkflowInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput>
  }

  export type NodeCreateManyWorkflowInputEnvelope = {
    data: NodeCreateManyWorkflowInput | NodeCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutWorkflowInput = {
    id?: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromNode: NodeCreateNestedOneWithoutOutputConnectionsInput
    toNode: NodeCreateNestedOneWithoutInputConnectionsInput
  }

  export type ConnectionUncheckedCreateWithoutWorkflowInput = {
    id?: string
    fromNodeId: string
    toNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionCreateOrConnectWithoutWorkflowInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutWorkflowInput, ConnectionUncheckedCreateWithoutWorkflowInput>
  }

  export type ConnectionCreateManyWorkflowInputEnvelope = {
    data: ConnectionCreateManyWorkflowInput | ConnectionCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type ExecutionCreateWithoutWorkflowInput = {
    id?: string
    status?: $Enums.ExecutionStatus
    error?: string | null
    errorStack?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    inngestEventId: string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionUncheckedCreateWithoutWorkflowInput = {
    id?: string
    status?: $Enums.ExecutionStatus
    error?: string | null
    errorStack?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    inngestEventId: string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionCreateOrConnectWithoutWorkflowInput = {
    where: ExecutionWhereUniqueInput
    create: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput>
  }

  export type ExecutionCreateManyWorkflowInputEnvelope = {
    data: ExecutionCreateManyWorkflowInput | ExecutionCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type AgentToolCreateWithoutWorkflowInput = {
    id?: string
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAgentToolsInput
  }

  export type AgentToolUncheckedCreateWithoutWorkflowInput = {
    id?: string
    agentId: string
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentToolCreateOrConnectWithoutWorkflowInput = {
    where: AgentToolWhereUniqueInput
    create: XOR<AgentToolCreateWithoutWorkflowInput, AgentToolUncheckedCreateWithoutWorkflowInput>
  }

  export type AgentToolCreateManyWorkflowInputEnvelope = {
    data: AgentToolCreateManyWorkflowInput | AgentToolCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWorkflowsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
  }

  export type NodeUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: NodeWhereUniqueInput
    update: XOR<NodeUpdateWithoutWorkflowInput, NodeUncheckedUpdateWithoutWorkflowInput>
    create: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput>
  }

  export type NodeUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: NodeWhereUniqueInput
    data: XOR<NodeUpdateWithoutWorkflowInput, NodeUncheckedUpdateWithoutWorkflowInput>
  }

  export type NodeUpdateManyWithWhereWithoutWorkflowInput = {
    where: NodeScalarWhereInput
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type ConnectionUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutWorkflowInput, ConnectionUncheckedUpdateWithoutWorkflowInput>
    create: XOR<ConnectionCreateWithoutWorkflowInput, ConnectionUncheckedCreateWithoutWorkflowInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutWorkflowInput, ConnectionUncheckedUpdateWithoutWorkflowInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutWorkflowInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    OR?: ConnectionScalarWhereInput[]
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    id?: StringFilter<"Connection"> | string
    workflowId?: StringFilter<"Connection"> | string
    fromNodeId?: StringFilter<"Connection"> | string
    toNodeId?: StringFilter<"Connection"> | string
    fromOutput?: StringFilter<"Connection"> | string
    toInput?: StringFilter<"Connection"> | string
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    updatedAt?: DateTimeFilter<"Connection"> | Date | string
  }

  export type ExecutionUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: ExecutionWhereUniqueInput
    update: XOR<ExecutionUpdateWithoutWorkflowInput, ExecutionUncheckedUpdateWithoutWorkflowInput>
    create: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput>
  }

  export type ExecutionUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: ExecutionWhereUniqueInput
    data: XOR<ExecutionUpdateWithoutWorkflowInput, ExecutionUncheckedUpdateWithoutWorkflowInput>
  }

  export type ExecutionUpdateManyWithWhereWithoutWorkflowInput = {
    where: ExecutionScalarWhereInput
    data: XOR<ExecutionUpdateManyMutationInput, ExecutionUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type ExecutionScalarWhereInput = {
    AND?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]
    OR?: ExecutionScalarWhereInput[]
    NOT?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]
    id?: StringFilter<"Execution"> | string
    workflowId?: StringFilter<"Execution"> | string
    status?: EnumExecutionStatusFilter<"Execution"> | $Enums.ExecutionStatus
    error?: StringNullableFilter<"Execution"> | string | null
    errorStack?: StringNullableFilter<"Execution"> | string | null
    startedAt?: DateTimeFilter<"Execution"> | Date | string
    completedAt?: DateTimeNullableFilter<"Execution"> | Date | string | null
    inngestEventId?: StringFilter<"Execution"> | string
    output?: JsonNullableFilter<"Execution">
  }

  export type AgentToolUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: AgentToolWhereUniqueInput
    update: XOR<AgentToolUpdateWithoutWorkflowInput, AgentToolUncheckedUpdateWithoutWorkflowInput>
    create: XOR<AgentToolCreateWithoutWorkflowInput, AgentToolUncheckedCreateWithoutWorkflowInput>
  }

  export type AgentToolUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: AgentToolWhereUniqueInput
    data: XOR<AgentToolUpdateWithoutWorkflowInput, AgentToolUncheckedUpdateWithoutWorkflowInput>
  }

  export type AgentToolUpdateManyWithWhereWithoutWorkflowInput = {
    where: AgentToolScalarWhereInput
    data: XOR<AgentToolUpdateManyMutationInput, AgentToolUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type AgentToolScalarWhereInput = {
    AND?: AgentToolScalarWhereInput | AgentToolScalarWhereInput[]
    OR?: AgentToolScalarWhereInput[]
    NOT?: AgentToolScalarWhereInput | AgentToolScalarWhereInput[]
    id?: StringFilter<"AgentTool"> | string
    agentId?: StringFilter<"AgentTool"> | string
    workflowId?: StringNullableFilter<"AgentTool"> | string | null
    composioAppKey?: StringNullableFilter<"AgentTool"> | string | null
    composioActionName?: StringNullableFilter<"AgentTool"> | string | null
    composioConfig?: JsonNullableFilter<"AgentTool">
    name?: StringFilter<"AgentTool"> | string
    description?: StringFilter<"AgentTool"> | string
    createdAt?: DateTimeFilter<"AgentTool"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTool"> | Date | string
  }

  export type UserUpsertWithoutWorkflowsInput = {
    update: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>
  }

  export type UserUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkflowCreateWithoutNodesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connections?: ConnectionCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolCreateNestedManyWithoutWorkflowInput
    user: UserCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutNodesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    connections?: ConnectionUncheckedCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutNodesInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
  }

  export type CredentialCreateWithoutNodeInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialsInput
    agents?: AgentCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutNodeInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    agents?: AgentUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutNodeInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutNodeInput, CredentialUncheckedCreateWithoutNodeInput>
  }

  export type ConnectionCreateWithoutFromNodeInput = {
    id?: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutConnectionsInput
    toNode: NodeCreateNestedOneWithoutInputConnectionsInput
  }

  export type ConnectionUncheckedCreateWithoutFromNodeInput = {
    id?: string
    workflowId: string
    toNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionCreateOrConnectWithoutFromNodeInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutFromNodeInput, ConnectionUncheckedCreateWithoutFromNodeInput>
  }

  export type ConnectionCreateManyFromNodeInputEnvelope = {
    data: ConnectionCreateManyFromNodeInput | ConnectionCreateManyFromNodeInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutToNodeInput = {
    id?: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutConnectionsInput
    fromNode: NodeCreateNestedOneWithoutOutputConnectionsInput
  }

  export type ConnectionUncheckedCreateWithoutToNodeInput = {
    id?: string
    workflowId: string
    fromNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionCreateOrConnectWithoutToNodeInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutToNodeInput, ConnectionUncheckedCreateWithoutToNodeInput>
  }

  export type ConnectionCreateManyToNodeInputEnvelope = {
    data: ConnectionCreateManyToNodeInput | ConnectionCreateManyToNodeInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowUpsertWithoutNodesInput = {
    update: XOR<WorkflowUpdateWithoutNodesInput, WorkflowUncheckedUpdateWithoutNodesInput>
    create: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutNodesInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutNodesInput, WorkflowUncheckedUpdateWithoutNodesInput>
  }

  export type WorkflowUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connections?: ConnectionUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUpdateManyWithoutWorkflowNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    connections?: ConnectionUncheckedUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type CredentialUpsertWithoutNodeInput = {
    update: XOR<CredentialUpdateWithoutNodeInput, CredentialUncheckedUpdateWithoutNodeInput>
    create: XOR<CredentialCreateWithoutNodeInput, CredentialUncheckedCreateWithoutNodeInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutNodeInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutNodeInput, CredentialUncheckedUpdateWithoutNodeInput>
  }

  export type CredentialUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialsNestedInput
    agents?: AgentUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    agents?: AgentUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type ConnectionUpsertWithWhereUniqueWithoutFromNodeInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutFromNodeInput, ConnectionUncheckedUpdateWithoutFromNodeInput>
    create: XOR<ConnectionCreateWithoutFromNodeInput, ConnectionUncheckedCreateWithoutFromNodeInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutFromNodeInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutFromNodeInput, ConnectionUncheckedUpdateWithoutFromNodeInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutFromNodeInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutFromNodeInput>
  }

  export type ConnectionUpsertWithWhereUniqueWithoutToNodeInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutToNodeInput, ConnectionUncheckedUpdateWithoutToNodeInput>
    create: XOR<ConnectionCreateWithoutToNodeInput, ConnectionUncheckedCreateWithoutToNodeInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutToNodeInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutToNodeInput, ConnectionUncheckedUpdateWithoutToNodeInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutToNodeInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutToNodeInput>
  }

  export type WorkflowCreateWithoutConnectionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: NodeCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolCreateNestedManyWithoutWorkflowInput
    user: UserCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutConnectionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutConnectionsInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutConnectionsInput, WorkflowUncheckedCreateWithoutConnectionsInput>
  }

  export type NodeCreateWithoutOutputConnectionsInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    credential?: CredentialCreateNestedOneWithoutNodeInput
    inputConnections?: ConnectionCreateNestedManyWithoutToNodeInput
  }

  export type NodeUncheckedCreateWithoutOutputConnectionsInput = {
    id?: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputConnections?: ConnectionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type NodeCreateOrConnectWithoutOutputConnectionsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutOutputConnectionsInput, NodeUncheckedCreateWithoutOutputConnectionsInput>
  }

  export type NodeCreateWithoutInputConnectionsInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    credential?: CredentialCreateNestedOneWithoutNodeInput
    outputConnections?: ConnectionCreateNestedManyWithoutFromNodeInput
  }

  export type NodeUncheckedCreateWithoutInputConnectionsInput = {
    id?: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outputConnections?: ConnectionUncheckedCreateNestedManyWithoutFromNodeInput
  }

  export type NodeCreateOrConnectWithoutInputConnectionsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutInputConnectionsInput, NodeUncheckedCreateWithoutInputConnectionsInput>
  }

  export type WorkflowUpsertWithoutConnectionsInput = {
    update: XOR<WorkflowUpdateWithoutConnectionsInput, WorkflowUncheckedUpdateWithoutConnectionsInput>
    create: XOR<WorkflowCreateWithoutConnectionsInput, WorkflowUncheckedCreateWithoutConnectionsInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutConnectionsInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutConnectionsInput, WorkflowUncheckedUpdateWithoutConnectionsInput>
  }

  export type WorkflowUpdateWithoutConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: NodeUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUpdateManyWithoutWorkflowNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type NodeUpsertWithoutOutputConnectionsInput = {
    update: XOR<NodeUpdateWithoutOutputConnectionsInput, NodeUncheckedUpdateWithoutOutputConnectionsInput>
    create: XOR<NodeCreateWithoutOutputConnectionsInput, NodeUncheckedCreateWithoutOutputConnectionsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutOutputConnectionsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutOutputConnectionsInput, NodeUncheckedUpdateWithoutOutputConnectionsInput>
  }

  export type NodeUpdateWithoutOutputConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    credential?: CredentialUpdateOneWithoutNodeNestedInput
    inputConnections?: ConnectionUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutOutputConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputConnections?: ConnectionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUpsertWithoutInputConnectionsInput = {
    update: XOR<NodeUpdateWithoutInputConnectionsInput, NodeUncheckedUpdateWithoutInputConnectionsInput>
    create: XOR<NodeCreateWithoutInputConnectionsInput, NodeUncheckedCreateWithoutInputConnectionsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutInputConnectionsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutInputConnectionsInput, NodeUncheckedUpdateWithoutInputConnectionsInput>
  }

  export type NodeUpdateWithoutInputConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    credential?: CredentialUpdateOneWithoutNodeNestedInput
    outputConnections?: ConnectionUpdateManyWithoutFromNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutInputConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputConnections?: ConnectionUncheckedUpdateManyWithoutFromNodeNestedInput
  }

  export type WorkflowCreateWithoutExecutionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: NodeCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolCreateNestedManyWithoutWorkflowInput
    user: UserCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionUncheckedCreateNestedManyWithoutWorkflowInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutExecutionsInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
  }

  export type WorkflowUpsertWithoutExecutionsInput = {
    update: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>
    create: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>
  }

  export type WorkflowUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: NodeUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUpdateManyWithoutWorkflowNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUncheckedUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type AgentTemplateCreateWithoutAgentsInput = {
    id?: string
    slug?: string | null
    name: string
    subtitle?: string | null
    description: string
    category: $Enums.TemplateCategory
    role?: $Enums.TemplateRole | null
    useCase?: $Enums.TemplateUseCase | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: string
    maxStepsPerRun?: number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateCreatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    color?: string | null
    coverImage?: string | null
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: string | null
    createdByName?: string | null
    usageCount?: number
    rating?: number
    reviewCount?: number
    tags?: AgentTemplateCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTemplateUncheckedCreateWithoutAgentsInput = {
    id?: string
    slug?: string | null
    name: string
    subtitle?: string | null
    description: string
    category: $Enums.TemplateCategory
    role?: $Enums.TemplateRole | null
    useCase?: $Enums.TemplateUseCase | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: string
    maxStepsPerRun?: number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateCreatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    color?: string | null
    coverImage?: string | null
    isPublic?: boolean
    isFeatured?: boolean
    createdById?: string | null
    createdByName?: string | null
    usageCount?: number
    rating?: number
    reviewCount?: number
    tags?: AgentTemplateCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTemplateCreateOrConnectWithoutAgentsInput = {
    where: AgentTemplateWhereUniqueInput
    create: XOR<AgentTemplateCreateWithoutAgentsInput, AgentTemplateUncheckedCreateWithoutAgentsInput>
  }

  export type UserCreateWithoutAgentsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
  }

  export type CredentialCreateWithoutAgentsInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialsInput
    Node?: NodeCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutAgentsInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    Node?: NodeUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutAgentsInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutAgentsInput, CredentialUncheckedCreateWithoutAgentsInput>
  }

  export type ConversationCreateWithoutAgentInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityCreateNestedManyWithoutConversationInput
    traces?: AgentTraceCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutAgentInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityUncheckedCreateNestedManyWithoutConversationInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutAgentInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutAgentInput, ConversationUncheckedCreateWithoutAgentInput>
  }

  export type ConversationCreateManyAgentInputEnvelope = {
    data: ConversationCreateManyAgentInput | ConversationCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentToolCreateWithoutAgentInput = {
    id?: string
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow?: WorkflowCreateNestedOneWithoutAgentToolsInput
  }

  export type AgentToolUncheckedCreateWithoutAgentInput = {
    id?: string
    workflowId?: string | null
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentToolCreateOrConnectWithoutAgentInput = {
    where: AgentToolWhereUniqueInput
    create: XOR<AgentToolCreateWithoutAgentInput, AgentToolUncheckedCreateWithoutAgentInput>
  }

  export type AgentToolCreateManyAgentInputEnvelope = {
    data: AgentToolCreateManyAgentInput | AgentToolCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentMemoryCreateWithoutAgentInput = {
    id?: string
    key: string
    value: string
    category?: $Enums.MemoryCategory
    embedding?: AgentMemoryCreateembeddingInput | number[]
    source?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMemoryUncheckedCreateWithoutAgentInput = {
    id?: string
    key: string
    value: string
    category?: $Enums.MemoryCategory
    embedding?: AgentMemoryCreateembeddingInput | number[]
    source?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMemoryCreateOrConnectWithoutAgentInput = {
    where: AgentMemoryWhereUniqueInput
    create: XOR<AgentMemoryCreateWithoutAgentInput, AgentMemoryUncheckedCreateWithoutAgentInput>
  }

  export type AgentMemoryCreateManyAgentInputEnvelope = {
    data: AgentMemoryCreateManyAgentInput | AgentMemoryCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeDocumentCreateWithoutAgentInput = {
    id?: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: KnowledgeChunkCreateNestedManyWithoutDocumentInput
  }

  export type KnowledgeDocumentUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: KnowledgeChunkUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type KnowledgeDocumentCreateOrConnectWithoutAgentInput = {
    where: KnowledgeDocumentWhereUniqueInput
    create: XOR<KnowledgeDocumentCreateWithoutAgentInput, KnowledgeDocumentUncheckedCreateWithoutAgentInput>
  }

  export type KnowledgeDocumentCreateManyAgentInputEnvelope = {
    data: KnowledgeDocumentCreateManyAgentInput | KnowledgeDocumentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeSettingsCreateWithoutAgentInput = {
    id?: string
    searchFuzziness?: number
    maxResults?: number
    autoRefresh?: boolean
    refreshInterval?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeSettingsUncheckedCreateWithoutAgentInput = {
    id?: string
    searchFuzziness?: number
    maxResults?: number
    autoRefresh?: boolean
    refreshInterval?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeSettingsCreateOrConnectWithoutAgentInput = {
    where: KnowledgeSettingsWhereUniqueInput
    create: XOR<KnowledgeSettingsCreateWithoutAgentInput, KnowledgeSettingsUncheckedCreateWithoutAgentInput>
  }

  export type AgentTriggerCreateWithoutAgentInput = {
    id?: string
    name: string
    type: $Enums.TriggerType
    enabled?: boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: string | null
    nextRunAt?: Date | string | null
    lastRunAt?: Date | string | null
    webhookSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTriggerUncheckedCreateWithoutAgentInput = {
    id?: string
    name: string
    type: $Enums.TriggerType
    enabled?: boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: string | null
    nextRunAt?: Date | string | null
    lastRunAt?: Date | string | null
    webhookSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTriggerCreateOrConnectWithoutAgentInput = {
    where: AgentTriggerWhereUniqueInput
    create: XOR<AgentTriggerCreateWithoutAgentInput, AgentTriggerUncheckedCreateWithoutAgentInput>
  }

  export type AgentTriggerCreateManyAgentInputEnvelope = {
    data: AgentTriggerCreateManyAgentInput | AgentTriggerCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentEmbedCreateWithoutAgentInput = {
    id?: string
    enabled?: boolean
    allowedDomains?: AgentEmbedCreateallowedDomainsInput | string[]
    displayName?: string | null
    welcomeMessage?: string | null
    logo?: string | null
    accentColor?: string
    backgroundColor?: string
    textColor?: string
    userBubbleColor?: string
    botBubbleColor?: string
    position?: $Enums.EmbedPosition
    buttonSize?: number
    windowWidth?: number
    windowHeight?: number
    autoOpen?: boolean
    autoOpenDelay?: number
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: string | null
    totalConversations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentEmbedUncheckedCreateWithoutAgentInput = {
    id?: string
    enabled?: boolean
    allowedDomains?: AgentEmbedCreateallowedDomainsInput | string[]
    displayName?: string | null
    welcomeMessage?: string | null
    logo?: string | null
    accentColor?: string
    backgroundColor?: string
    textColor?: string
    userBubbleColor?: string
    botBubbleColor?: string
    position?: $Enums.EmbedPosition
    buttonSize?: number
    windowWidth?: number
    windowHeight?: number
    autoOpen?: boolean
    autoOpenDelay?: number
    showBranding?: boolean
    collectEmail?: boolean
    requireEmail?: boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: string | null
    totalConversations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentEmbedCreateOrConnectWithoutAgentInput = {
    where: AgentEmbedWhereUniqueInput
    create: XOR<AgentEmbedCreateWithoutAgentInput, AgentEmbedUncheckedCreateWithoutAgentInput>
  }

  export type AgentConnectionCreateWithoutSourceAgentInput = {
    id?: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    targetAgent: AgentCreateNestedOneWithoutConnectedFromInput
  }

  export type AgentConnectionUncheckedCreateWithoutSourceAgentInput = {
    id?: string
    targetAgentId: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentConnectionCreateOrConnectWithoutSourceAgentInput = {
    where: AgentConnectionWhereUniqueInput
    create: XOR<AgentConnectionCreateWithoutSourceAgentInput, AgentConnectionUncheckedCreateWithoutSourceAgentInput>
  }

  export type AgentConnectionCreateManySourceAgentInputEnvelope = {
    data: AgentConnectionCreateManySourceAgentInput | AgentConnectionCreateManySourceAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentConnectionCreateWithoutTargetAgentInput = {
    id?: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceAgent: AgentCreateNestedOneWithoutConnectedToInput
  }

  export type AgentConnectionUncheckedCreateWithoutTargetAgentInput = {
    id?: string
    sourceAgentId: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentConnectionCreateOrConnectWithoutTargetAgentInput = {
    where: AgentConnectionWhereUniqueInput
    create: XOR<AgentConnectionCreateWithoutTargetAgentInput, AgentConnectionUncheckedCreateWithoutTargetAgentInput>
  }

  export type AgentConnectionCreateManyTargetAgentInputEnvelope = {
    data: AgentConnectionCreateManyTargetAgentInput | AgentConnectionCreateManyTargetAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentSwarmCreateWithoutAgentInput = {
    id?: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: SwarmTaskCreateNestedManyWithoutSwarmInput
  }

  export type AgentSwarmUncheckedCreateWithoutAgentInput = {
    id?: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: SwarmTaskUncheckedCreateNestedManyWithoutSwarmInput
  }

  export type AgentSwarmCreateOrConnectWithoutAgentInput = {
    where: AgentSwarmWhereUniqueInput
    create: XOR<AgentSwarmCreateWithoutAgentInput, AgentSwarmUncheckedCreateWithoutAgentInput>
  }

  export type AgentSwarmCreateManyAgentInputEnvelope = {
    data: AgentSwarmCreateManyAgentInput | AgentSwarmCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentEmailAddressCreateWithoutAgentInput = {
    id?: string
    localPart: string
    domain?: string
    autoReply?: boolean
    createdAt?: Date | string
  }

  export type AgentEmailAddressUncheckedCreateWithoutAgentInput = {
    id?: string
    localPart: string
    domain?: string
    autoReply?: boolean
    createdAt?: Date | string
  }

  export type AgentEmailAddressCreateOrConnectWithoutAgentInput = {
    where: AgentEmailAddressWhereUniqueInput
    create: XOR<AgentEmailAddressCreateWithoutAgentInput, AgentEmailAddressUncheckedCreateWithoutAgentInput>
  }

  export type MeetingRecordingCreateWithoutAgentInput = {
    id?: string
    title: string
    meetingUrl?: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId?: string | null
    status?: $Enums.RecordingStatus
    recordingUrl?: string | null
    transcript?: string | null
    summary?: string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingRecordingUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    meetingUrl?: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId?: string | null
    status?: $Enums.RecordingStatus
    recordingUrl?: string | null
    transcript?: string | null
    summary?: string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingRecordingCreateOrConnectWithoutAgentInput = {
    where: MeetingRecordingWhereUniqueInput
    create: XOR<MeetingRecordingCreateWithoutAgentInput, MeetingRecordingUncheckedCreateWithoutAgentInput>
  }

  export type MeetingRecordingCreateManyAgentInputEnvelope = {
    data: MeetingRecordingCreateManyAgentInput | MeetingRecordingCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentPhoneNumberCreateWithoutAgentInput = {
    id?: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
    calls?: PhoneCallCreateNestedManyWithoutPhoneNumberInput
  }

  export type AgentPhoneNumberUncheckedCreateWithoutAgentInput = {
    id?: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
    calls?: PhoneCallUncheckedCreateNestedManyWithoutPhoneNumberInput
  }

  export type AgentPhoneNumberCreateOrConnectWithoutAgentInput = {
    where: AgentPhoneNumberWhereUniqueInput
    create: XOR<AgentPhoneNumberCreateWithoutAgentInput, AgentPhoneNumberUncheckedCreateWithoutAgentInput>
  }

  export type AgentMetricCreateWithoutAgentInput = {
    id?: string
    date: Date | string
    totalConversations?: number
    totalMessages?: number
    avgMessagesPerConvo?: number
    avgResponseTimeMs?: number
    totalTokensUsed?: number
    toolCallsCount?: number
    toolSuccessRate?: number
    feedbackPositive?: number
    feedbackNegative?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMetricUncheckedCreateWithoutAgentInput = {
    id?: string
    date: Date | string
    totalConversations?: number
    totalMessages?: number
    avgMessagesPerConvo?: number
    avgResponseTimeMs?: number
    totalTokensUsed?: number
    toolCallsCount?: number
    toolSuccessRate?: number
    feedbackPositive?: number
    feedbackNegative?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMetricCreateOrConnectWithoutAgentInput = {
    where: AgentMetricWhereUniqueInput
    create: XOR<AgentMetricCreateWithoutAgentInput, AgentMetricUncheckedCreateWithoutAgentInput>
  }

  export type AgentMetricCreateManyAgentInputEnvelope = {
    data: AgentMetricCreateManyAgentInput | AgentMetricCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentTraceCreateWithoutAgentInput = {
    id?: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    conversation: ConversationCreateNestedOneWithoutTracesInput
    aiEvents?: AiEventCreateNestedManyWithoutTraceInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceUncheckedCreateWithoutAgentInput = {
    id?: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    aiEvents?: AiEventUncheckedCreateNestedManyWithoutTraceInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceCreateOrConnectWithoutAgentInput = {
    where: AgentTraceWhereUniqueInput
    create: XOR<AgentTraceCreateWithoutAgentInput, AgentTraceUncheckedCreateWithoutAgentInput>
  }

  export type AgentTraceCreateManyAgentInputEnvelope = {
    data: AgentTraceCreateManyAgentInput | AgentTraceCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentInsightCreateWithoutAgentInput = {
    id?: string
    generatedAt?: Date | string
    timeframeStart: Date | string
    timeframeEnd: Date | string
    clusters: JsonNullValueInput | InputJsonValue
    patterns: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    opportunities: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightUncheckedCreateWithoutAgentInput = {
    id?: string
    generatedAt?: Date | string
    timeframeStart: Date | string
    timeframeEnd: Date | string
    clusters: JsonNullValueInput | InputJsonValue
    patterns: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    opportunities: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightCreateOrConnectWithoutAgentInput = {
    where: AgentInsightWhereUniqueInput
    create: XOR<AgentInsightCreateWithoutAgentInput, AgentInsightUncheckedCreateWithoutAgentInput>
  }

  export type AgentInsightCreateManyAgentInputEnvelope = {
    data: AgentInsightCreateManyAgentInput | AgentInsightCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentFeedbackCreateWithoutAgentInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    trace: AgentTraceCreateNestedOneWithoutFeedbacksInput
    conversation: ConversationCreateNestedOneWithoutFeedbacksInput
  }

  export type AgentFeedbackUncheckedCreateWithoutAgentInput = {
    id?: string
    traceId: string
    conversationId: string
    userId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackCreateOrConnectWithoutAgentInput = {
    where: AgentFeedbackWhereUniqueInput
    create: XOR<AgentFeedbackCreateWithoutAgentInput, AgentFeedbackUncheckedCreateWithoutAgentInput>
  }

  export type AgentFeedbackCreateManyAgentInputEnvelope = {
    data: AgentFeedbackCreateManyAgentInput | AgentFeedbackCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentABTestCreateWithoutAgentInput = {
    id?: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit?: number
    status: $Enums.ABTestStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    variantATraces?: number
    variantBTraces?: number
    variantAScore?: number | null
    variantBScore?: number | null
    winningVariant?: string | null
  }

  export type AgentABTestUncheckedCreateWithoutAgentInput = {
    id?: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit?: number
    status: $Enums.ABTestStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    variantATraces?: number
    variantBTraces?: number
    variantAScore?: number | null
    variantBScore?: number | null
    winningVariant?: string | null
  }

  export type AgentABTestCreateOrConnectWithoutAgentInput = {
    where: AgentABTestWhereUniqueInput
    create: XOR<AgentABTestCreateWithoutAgentInput, AgentABTestUncheckedCreateWithoutAgentInput>
  }

  export type AgentABTestCreateManyAgentInputEnvelope = {
    data: AgentABTestCreateManyAgentInput | AgentABTestCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type OptimizationRunCreateWithoutAgentInput = {
    id?: string
    triggeredAt?: Date | string
    triggeredBy: string
    editPatterns: JsonNullValueInput | InputJsonValue
    promptVariations: JsonNullValueInput | InputJsonValue
    testResults: JsonNullValueInput | InputJsonValue
    recommendation: string
    abTestId?: string | null
    status: string
  }

  export type OptimizationRunUncheckedCreateWithoutAgentInput = {
    id?: string
    triggeredAt?: Date | string
    triggeredBy: string
    editPatterns: JsonNullValueInput | InputJsonValue
    promptVariations: JsonNullValueInput | InputJsonValue
    testResults: JsonNullValueInput | InputJsonValue
    recommendation: string
    abTestId?: string | null
    status: string
  }

  export type OptimizationRunCreateOrConnectWithoutAgentInput = {
    where: OptimizationRunWhereUniqueInput
    create: XOR<OptimizationRunCreateWithoutAgentInput, OptimizationRunUncheckedCreateWithoutAgentInput>
  }

  export type OptimizationRunCreateManyAgentInputEnvelope = {
    data: OptimizationRunCreateManyAgentInput | OptimizationRunCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ModificationProposalCreateWithoutAgentInput = {
    id?: string
    proposedAt?: Date | string
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status?: $Enums.ProposalStatus
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    appliedAt?: Date | string | null
  }

  export type ModificationProposalUncheckedCreateWithoutAgentInput = {
    id?: string
    proposedAt?: Date | string
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status?: $Enums.ProposalStatus
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    appliedAt?: Date | string | null
  }

  export type ModificationProposalCreateOrConnectWithoutAgentInput = {
    where: ModificationProposalWhereUniqueInput
    create: XOR<ModificationProposalCreateWithoutAgentInput, ModificationProposalUncheckedCreateWithoutAgentInput>
  }

  export type ModificationProposalCreateManyAgentInputEnvelope = {
    data: ModificationProposalCreateManyAgentInput | ModificationProposalCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentTemplateUpsertWithoutAgentsInput = {
    update: XOR<AgentTemplateUpdateWithoutAgentsInput, AgentTemplateUncheckedUpdateWithoutAgentsInput>
    create: XOR<AgentTemplateCreateWithoutAgentsInput, AgentTemplateUncheckedCreateWithoutAgentsInput>
    where?: AgentTemplateWhereInput
  }

  export type AgentTemplateUpdateToOneWithWhereWithoutAgentsInput = {
    where?: AgentTemplateWhereInput
    data: XOR<AgentTemplateUpdateWithoutAgentsInput, AgentTemplateUncheckedUpdateWithoutAgentsInput>
  }

  export type AgentTemplateUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTemplateCategoryFieldUpdateOperationsInput | $Enums.TemplateCategory
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    useCase?: NullableEnumTemplateUseCaseFieldUpdateOperationsInput | $Enums.TemplateUseCase | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: StringFieldUpdateOperationsInput | string
    maxStepsPerRun?: IntFieldUpdateOperationsInput | number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateUpdatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    tags?: AgentTemplateUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTemplateUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTemplateCategoryFieldUpdateOperationsInput | $Enums.TemplateCategory
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    useCase?: NullableEnumTemplateUseCaseFieldUpdateOperationsInput | $Enums.TemplateUseCase | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    trigger?: JsonNullValueInput | InputJsonValue
    llmTier?: StringFieldUpdateOperationsInput | string
    maxStepsPerRun?: IntFieldUpdateOperationsInput | number
    fetchSources?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    evalRules?: JsonNullValueInput | InputJsonValue
    suggestedTools?: JsonNullValueInput | InputJsonValue
    suggestedTriggers?: JsonNullValueInput | InputJsonValue
    suggestedIntegrations?: AgentTemplateUpdatesuggestedIntegrationsInput | string[]
    flowData?: JsonNullValueInput | InputJsonValue
    defaultTriggers?: JsonNullValueInput | InputJsonValue
    defaultTools?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    tags?: AgentTemplateUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAgentsInput = {
    update: XOR<UserUpdateWithoutAgentsInput, UserUncheckedUpdateWithoutAgentsInput>
    create: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentsInput, UserUncheckedUpdateWithoutAgentsInput>
  }

  export type UserUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CredentialUpsertWithoutAgentsInput = {
    update: XOR<CredentialUpdateWithoutAgentsInput, CredentialUncheckedUpdateWithoutAgentsInput>
    create: XOR<CredentialCreateWithoutAgentsInput, CredentialUncheckedCreateWithoutAgentsInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutAgentsInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutAgentsInput, CredentialUncheckedUpdateWithoutAgentsInput>
  }

  export type CredentialUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialsNestedInput
    Node?: NodeUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    Node?: NodeUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type ConversationUpsertWithWhereUniqueWithoutAgentInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutAgentInput, ConversationUncheckedUpdateWithoutAgentInput>
    create: XOR<ConversationCreateWithoutAgentInput, ConversationUncheckedCreateWithoutAgentInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutAgentInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutAgentInput, ConversationUncheckedUpdateWithoutAgentInput>
  }

  export type ConversationUpdateManyWithWhereWithoutAgentInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutAgentInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    agentId?: StringFilter<"Conversation"> | string
    isArchived?: BoolFilter<"Conversation"> | boolean
    isPinned?: BoolFilter<"Conversation"> | boolean
    shareToken?: StringNullableFilter<"Conversation"> | string | null
    source?: EnumConversationSourceFilter<"Conversation"> | $Enums.ConversationSource
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type AgentToolUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentToolWhereUniqueInput
    update: XOR<AgentToolUpdateWithoutAgentInput, AgentToolUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentToolCreateWithoutAgentInput, AgentToolUncheckedCreateWithoutAgentInput>
  }

  export type AgentToolUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentToolWhereUniqueInput
    data: XOR<AgentToolUpdateWithoutAgentInput, AgentToolUncheckedUpdateWithoutAgentInput>
  }

  export type AgentToolUpdateManyWithWhereWithoutAgentInput = {
    where: AgentToolScalarWhereInput
    data: XOR<AgentToolUpdateManyMutationInput, AgentToolUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentMemoryUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentMemoryWhereUniqueInput
    update: XOR<AgentMemoryUpdateWithoutAgentInput, AgentMemoryUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentMemoryCreateWithoutAgentInput, AgentMemoryUncheckedCreateWithoutAgentInput>
  }

  export type AgentMemoryUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentMemoryWhereUniqueInput
    data: XOR<AgentMemoryUpdateWithoutAgentInput, AgentMemoryUncheckedUpdateWithoutAgentInput>
  }

  export type AgentMemoryUpdateManyWithWhereWithoutAgentInput = {
    where: AgentMemoryScalarWhereInput
    data: XOR<AgentMemoryUpdateManyMutationInput, AgentMemoryUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentMemoryScalarWhereInput = {
    AND?: AgentMemoryScalarWhereInput | AgentMemoryScalarWhereInput[]
    OR?: AgentMemoryScalarWhereInput[]
    NOT?: AgentMemoryScalarWhereInput | AgentMemoryScalarWhereInput[]
    id?: StringFilter<"AgentMemory"> | string
    agentId?: StringFilter<"AgentMemory"> | string
    key?: StringFilter<"AgentMemory"> | string
    value?: StringFilter<"AgentMemory"> | string
    category?: EnumMemoryCategoryFilter<"AgentMemory"> | $Enums.MemoryCategory
    embedding?: FloatNullableListFilter<"AgentMemory">
    source?: StringNullableFilter<"AgentMemory"> | string | null
    expiresAt?: DateTimeNullableFilter<"AgentMemory"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentMemory"> | Date | string
    updatedAt?: DateTimeFilter<"AgentMemory"> | Date | string
  }

  export type KnowledgeDocumentUpsertWithWhereUniqueWithoutAgentInput = {
    where: KnowledgeDocumentWhereUniqueInput
    update: XOR<KnowledgeDocumentUpdateWithoutAgentInput, KnowledgeDocumentUncheckedUpdateWithoutAgentInput>
    create: XOR<KnowledgeDocumentCreateWithoutAgentInput, KnowledgeDocumentUncheckedCreateWithoutAgentInput>
  }

  export type KnowledgeDocumentUpdateWithWhereUniqueWithoutAgentInput = {
    where: KnowledgeDocumentWhereUniqueInput
    data: XOR<KnowledgeDocumentUpdateWithoutAgentInput, KnowledgeDocumentUncheckedUpdateWithoutAgentInput>
  }

  export type KnowledgeDocumentUpdateManyWithWhereWithoutAgentInput = {
    where: KnowledgeDocumentScalarWhereInput
    data: XOR<KnowledgeDocumentUpdateManyMutationInput, KnowledgeDocumentUncheckedUpdateManyWithoutAgentInput>
  }

  export type KnowledgeDocumentScalarWhereInput = {
    AND?: KnowledgeDocumentScalarWhereInput | KnowledgeDocumentScalarWhereInput[]
    OR?: KnowledgeDocumentScalarWhereInput[]
    NOT?: KnowledgeDocumentScalarWhereInput | KnowledgeDocumentScalarWhereInput[]
    id?: StringFilter<"KnowledgeDocument"> | string
    agentId?: StringFilter<"KnowledgeDocument"> | string
    title?: StringFilter<"KnowledgeDocument"> | string
    content?: StringFilter<"KnowledgeDocument"> | string
    source?: StringNullableFilter<"KnowledgeDocument"> | string | null
    mimeType?: StringFilter<"KnowledgeDocument"> | string
    fileSize?: IntNullableFilter<"KnowledgeDocument"> | number | null
    sourceType?: EnumKnowledgeSourceTypeFilter<"KnowledgeDocument"> | $Enums.KnowledgeSourceType
    externalId?: StringNullableFilter<"KnowledgeDocument"> | string | null
    externalUrl?: StringNullableFilter<"KnowledgeDocument"> | string | null
    syncStatus?: EnumKnowledgeSyncStatusFilter<"KnowledgeDocument"> | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: DateTimeNullableFilter<"KnowledgeDocument"> | Date | string | null
    syncError?: StringNullableFilter<"KnowledgeDocument"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeDocument"> | Date | string
  }

  export type KnowledgeSettingsUpsertWithoutAgentInput = {
    update: XOR<KnowledgeSettingsUpdateWithoutAgentInput, KnowledgeSettingsUncheckedUpdateWithoutAgentInput>
    create: XOR<KnowledgeSettingsCreateWithoutAgentInput, KnowledgeSettingsUncheckedCreateWithoutAgentInput>
    where?: KnowledgeSettingsWhereInput
  }

  export type KnowledgeSettingsUpdateToOneWithWhereWithoutAgentInput = {
    where?: KnowledgeSettingsWhereInput
    data: XOR<KnowledgeSettingsUpdateWithoutAgentInput, KnowledgeSettingsUncheckedUpdateWithoutAgentInput>
  }

  export type KnowledgeSettingsUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    searchFuzziness?: IntFieldUpdateOperationsInput | number
    maxResults?: IntFieldUpdateOperationsInput | number
    autoRefresh?: BoolFieldUpdateOperationsInput | boolean
    refreshInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeSettingsUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    searchFuzziness?: IntFieldUpdateOperationsInput | number
    maxResults?: IntFieldUpdateOperationsInput | number
    autoRefresh?: BoolFieldUpdateOperationsInput | boolean
    refreshInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentTriggerWhereUniqueInput
    update: XOR<AgentTriggerUpdateWithoutAgentInput, AgentTriggerUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentTriggerCreateWithoutAgentInput, AgentTriggerUncheckedCreateWithoutAgentInput>
  }

  export type AgentTriggerUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentTriggerWhereUniqueInput
    data: XOR<AgentTriggerUpdateWithoutAgentInput, AgentTriggerUncheckedUpdateWithoutAgentInput>
  }

  export type AgentTriggerUpdateManyWithWhereWithoutAgentInput = {
    where: AgentTriggerScalarWhereInput
    data: XOR<AgentTriggerUpdateManyMutationInput, AgentTriggerUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentTriggerScalarWhereInput = {
    AND?: AgentTriggerScalarWhereInput | AgentTriggerScalarWhereInput[]
    OR?: AgentTriggerScalarWhereInput[]
    NOT?: AgentTriggerScalarWhereInput | AgentTriggerScalarWhereInput[]
    id?: StringFilter<"AgentTrigger"> | string
    agentId?: StringFilter<"AgentTrigger"> | string
    name?: StringFilter<"AgentTrigger"> | string
    type?: EnumTriggerTypeFilter<"AgentTrigger"> | $Enums.TriggerType
    enabled?: BoolFilter<"AgentTrigger"> | boolean
    config?: JsonFilter<"AgentTrigger">
    cronExpression?: StringNullableFilter<"AgentTrigger"> | string | null
    nextRunAt?: DateTimeNullableFilter<"AgentTrigger"> | Date | string | null
    lastRunAt?: DateTimeNullableFilter<"AgentTrigger"> | Date | string | null
    webhookSecret?: StringNullableFilter<"AgentTrigger"> | string | null
    createdAt?: DateTimeFilter<"AgentTrigger"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTrigger"> | Date | string
  }

  export type AgentEmbedUpsertWithoutAgentInput = {
    update: XOR<AgentEmbedUpdateWithoutAgentInput, AgentEmbedUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentEmbedCreateWithoutAgentInput, AgentEmbedUncheckedCreateWithoutAgentInput>
    where?: AgentEmbedWhereInput
  }

  export type AgentEmbedUpdateToOneWithWhereWithoutAgentInput = {
    where?: AgentEmbedWhereInput
    data: XOR<AgentEmbedUpdateWithoutAgentInput, AgentEmbedUncheckedUpdateWithoutAgentInput>
  }

  export type AgentEmbedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    allowedDomains?: AgentEmbedUpdateallowedDomainsInput | string[]
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    userBubbleColor?: StringFieldUpdateOperationsInput | string
    botBubbleColor?: StringFieldUpdateOperationsInput | string
    position?: EnumEmbedPositionFieldUpdateOperationsInput | $Enums.EmbedPosition
    buttonSize?: IntFieldUpdateOperationsInput | number
    windowWidth?: IntFieldUpdateOperationsInput | number
    windowHeight?: IntFieldUpdateOperationsInput | number
    autoOpen?: BoolFieldUpdateOperationsInput | boolean
    autoOpenDelay?: IntFieldUpdateOperationsInput | number
    showBranding?: BoolFieldUpdateOperationsInput | boolean
    collectEmail?: BoolFieldUpdateOperationsInput | boolean
    requireEmail?: BoolFieldUpdateOperationsInput | boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    totalConversations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmbedUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    allowedDomains?: AgentEmbedUpdateallowedDomainsInput | string[]
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    userBubbleColor?: StringFieldUpdateOperationsInput | string
    botBubbleColor?: StringFieldUpdateOperationsInput | string
    position?: EnumEmbedPositionFieldUpdateOperationsInput | $Enums.EmbedPosition
    buttonSize?: IntFieldUpdateOperationsInput | number
    windowWidth?: IntFieldUpdateOperationsInput | number
    windowHeight?: IntFieldUpdateOperationsInput | number
    autoOpen?: BoolFieldUpdateOperationsInput | boolean
    autoOpenDelay?: IntFieldUpdateOperationsInput | number
    showBranding?: BoolFieldUpdateOperationsInput | boolean
    collectEmail?: BoolFieldUpdateOperationsInput | boolean
    requireEmail?: BoolFieldUpdateOperationsInput | boolean
    conversationStarters?: JsonNullValueInput | InputJsonValue
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    totalConversations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionUpsertWithWhereUniqueWithoutSourceAgentInput = {
    where: AgentConnectionWhereUniqueInput
    update: XOR<AgentConnectionUpdateWithoutSourceAgentInput, AgentConnectionUncheckedUpdateWithoutSourceAgentInput>
    create: XOR<AgentConnectionCreateWithoutSourceAgentInput, AgentConnectionUncheckedCreateWithoutSourceAgentInput>
  }

  export type AgentConnectionUpdateWithWhereUniqueWithoutSourceAgentInput = {
    where: AgentConnectionWhereUniqueInput
    data: XOR<AgentConnectionUpdateWithoutSourceAgentInput, AgentConnectionUncheckedUpdateWithoutSourceAgentInput>
  }

  export type AgentConnectionUpdateManyWithWhereWithoutSourceAgentInput = {
    where: AgentConnectionScalarWhereInput
    data: XOR<AgentConnectionUpdateManyMutationInput, AgentConnectionUncheckedUpdateManyWithoutSourceAgentInput>
  }

  export type AgentConnectionScalarWhereInput = {
    AND?: AgentConnectionScalarWhereInput | AgentConnectionScalarWhereInput[]
    OR?: AgentConnectionScalarWhereInput[]
    NOT?: AgentConnectionScalarWhereInput | AgentConnectionScalarWhereInput[]
    id?: StringFilter<"AgentConnection"> | string
    sourceAgentId?: StringFilter<"AgentConnection"> | string
    targetAgentId?: StringFilter<"AgentConnection"> | string
    alias?: StringFilter<"AgentConnection"> | string
    description?: StringFilter<"AgentConnection"> | string
    enabled?: BoolFilter<"AgentConnection"> | boolean
    createdAt?: DateTimeFilter<"AgentConnection"> | Date | string
    updatedAt?: DateTimeFilter<"AgentConnection"> | Date | string
  }

  export type AgentConnectionUpsertWithWhereUniqueWithoutTargetAgentInput = {
    where: AgentConnectionWhereUniqueInput
    update: XOR<AgentConnectionUpdateWithoutTargetAgentInput, AgentConnectionUncheckedUpdateWithoutTargetAgentInput>
    create: XOR<AgentConnectionCreateWithoutTargetAgentInput, AgentConnectionUncheckedCreateWithoutTargetAgentInput>
  }

  export type AgentConnectionUpdateWithWhereUniqueWithoutTargetAgentInput = {
    where: AgentConnectionWhereUniqueInput
    data: XOR<AgentConnectionUpdateWithoutTargetAgentInput, AgentConnectionUncheckedUpdateWithoutTargetAgentInput>
  }

  export type AgentConnectionUpdateManyWithWhereWithoutTargetAgentInput = {
    where: AgentConnectionScalarWhereInput
    data: XOR<AgentConnectionUpdateManyMutationInput, AgentConnectionUncheckedUpdateManyWithoutTargetAgentInput>
  }

  export type AgentSwarmUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentSwarmWhereUniqueInput
    update: XOR<AgentSwarmUpdateWithoutAgentInput, AgentSwarmUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentSwarmCreateWithoutAgentInput, AgentSwarmUncheckedCreateWithoutAgentInput>
  }

  export type AgentSwarmUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentSwarmWhereUniqueInput
    data: XOR<AgentSwarmUpdateWithoutAgentInput, AgentSwarmUncheckedUpdateWithoutAgentInput>
  }

  export type AgentSwarmUpdateManyWithWhereWithoutAgentInput = {
    where: AgentSwarmScalarWhereInput
    data: XOR<AgentSwarmUpdateManyMutationInput, AgentSwarmUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentSwarmScalarWhereInput = {
    AND?: AgentSwarmScalarWhereInput | AgentSwarmScalarWhereInput[]
    OR?: AgentSwarmScalarWhereInput[]
    NOT?: AgentSwarmScalarWhereInput | AgentSwarmScalarWhereInput[]
    id?: StringFilter<"AgentSwarm"> | string
    agentId?: StringFilter<"AgentSwarm"> | string
    name?: StringFilter<"AgentSwarm"> | string
    taskTemplate?: StringFilter<"AgentSwarm"> | string
    status?: EnumSwarmStatusFilter<"AgentSwarm"> | $Enums.SwarmStatus
    totalTasks?: IntFilter<"AgentSwarm"> | number
    completedTasks?: IntFilter<"AgentSwarm"> | number
    failedTasks?: IntFilter<"AgentSwarm"> | number
    createdAt?: DateTimeFilter<"AgentSwarm"> | Date | string
    updatedAt?: DateTimeFilter<"AgentSwarm"> | Date | string
  }

  export type AgentEmailAddressUpsertWithoutAgentInput = {
    update: XOR<AgentEmailAddressUpdateWithoutAgentInput, AgentEmailAddressUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentEmailAddressCreateWithoutAgentInput, AgentEmailAddressUncheckedCreateWithoutAgentInput>
    where?: AgentEmailAddressWhereInput
  }

  export type AgentEmailAddressUpdateToOneWithWhereWithoutAgentInput = {
    where?: AgentEmailAddressWhereInput
    data: XOR<AgentEmailAddressUpdateWithoutAgentInput, AgentEmailAddressUncheckedUpdateWithoutAgentInput>
  }

  export type AgentEmailAddressUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentEmailAddressUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingUpsertWithWhereUniqueWithoutAgentInput = {
    where: MeetingRecordingWhereUniqueInput
    update: XOR<MeetingRecordingUpdateWithoutAgentInput, MeetingRecordingUncheckedUpdateWithoutAgentInput>
    create: XOR<MeetingRecordingCreateWithoutAgentInput, MeetingRecordingUncheckedCreateWithoutAgentInput>
  }

  export type MeetingRecordingUpdateWithWhereUniqueWithoutAgentInput = {
    where: MeetingRecordingWhereUniqueInput
    data: XOR<MeetingRecordingUpdateWithoutAgentInput, MeetingRecordingUncheckedUpdateWithoutAgentInput>
  }

  export type MeetingRecordingUpdateManyWithWhereWithoutAgentInput = {
    where: MeetingRecordingScalarWhereInput
    data: XOR<MeetingRecordingUpdateManyMutationInput, MeetingRecordingUncheckedUpdateManyWithoutAgentInput>
  }

  export type MeetingRecordingScalarWhereInput = {
    AND?: MeetingRecordingScalarWhereInput | MeetingRecordingScalarWhereInput[]
    OR?: MeetingRecordingScalarWhereInput[]
    NOT?: MeetingRecordingScalarWhereInput | MeetingRecordingScalarWhereInput[]
    id?: StringFilter<"MeetingRecording"> | string
    agentId?: StringFilter<"MeetingRecording"> | string
    title?: StringFilter<"MeetingRecording"> | string
    meetingUrl?: StringNullableFilter<"MeetingRecording"> | string | null
    meetingPlatform?: EnumMeetingPlatformFilter<"MeetingRecording"> | $Enums.MeetingPlatform
    calendarEventId?: StringNullableFilter<"MeetingRecording"> | string | null
    status?: EnumRecordingStatusFilter<"MeetingRecording"> | $Enums.RecordingStatus
    recordingUrl?: StringNullableFilter<"MeetingRecording"> | string | null
    transcript?: StringNullableFilter<"MeetingRecording"> | string | null
    summary?: StringNullableFilter<"MeetingRecording"> | string | null
    actionItems?: JsonFilter<"MeetingRecording">
    participants?: JsonFilter<"MeetingRecording">
    scheduledAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    startedAt?: DateTimeNullableFilter<"MeetingRecording"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MeetingRecording"> | Date | string | null
    duration?: IntNullableFilter<"MeetingRecording"> | number | null
    createdAt?: DateTimeFilter<"MeetingRecording"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingRecording"> | Date | string
  }

  export type AgentPhoneNumberUpsertWithoutAgentInput = {
    update: XOR<AgentPhoneNumberUpdateWithoutAgentInput, AgentPhoneNumberUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentPhoneNumberCreateWithoutAgentInput, AgentPhoneNumberUncheckedCreateWithoutAgentInput>
    where?: AgentPhoneNumberWhereInput
  }

  export type AgentPhoneNumberUpdateToOneWithWhereWithoutAgentInput = {
    where?: AgentPhoneNumberWhereInput
    data: XOR<AgentPhoneNumberUpdateWithoutAgentInput, AgentPhoneNumberUncheckedUpdateWithoutAgentInput>
  }

  export type AgentPhoneNumberUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calls?: PhoneCallUpdateManyWithoutPhoneNumberNestedInput
  }

  export type AgentPhoneNumberUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calls?: PhoneCallUncheckedUpdateManyWithoutPhoneNumberNestedInput
  }

  export type AgentMetricUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentMetricWhereUniqueInput
    update: XOR<AgentMetricUpdateWithoutAgentInput, AgentMetricUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentMetricCreateWithoutAgentInput, AgentMetricUncheckedCreateWithoutAgentInput>
  }

  export type AgentMetricUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentMetricWhereUniqueInput
    data: XOR<AgentMetricUpdateWithoutAgentInput, AgentMetricUncheckedUpdateWithoutAgentInput>
  }

  export type AgentMetricUpdateManyWithWhereWithoutAgentInput = {
    where: AgentMetricScalarWhereInput
    data: XOR<AgentMetricUpdateManyMutationInput, AgentMetricUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentMetricScalarWhereInput = {
    AND?: AgentMetricScalarWhereInput | AgentMetricScalarWhereInput[]
    OR?: AgentMetricScalarWhereInput[]
    NOT?: AgentMetricScalarWhereInput | AgentMetricScalarWhereInput[]
    id?: StringFilter<"AgentMetric"> | string
    agentId?: StringFilter<"AgentMetric"> | string
    date?: DateTimeFilter<"AgentMetric"> | Date | string
    totalConversations?: IntFilter<"AgentMetric"> | number
    totalMessages?: IntFilter<"AgentMetric"> | number
    avgMessagesPerConvo?: FloatFilter<"AgentMetric"> | number
    avgResponseTimeMs?: IntFilter<"AgentMetric"> | number
    totalTokensUsed?: IntFilter<"AgentMetric"> | number
    toolCallsCount?: IntFilter<"AgentMetric"> | number
    toolSuccessRate?: FloatFilter<"AgentMetric"> | number
    feedbackPositive?: IntFilter<"AgentMetric"> | number
    feedbackNegative?: IntFilter<"AgentMetric"> | number
    createdAt?: DateTimeFilter<"AgentMetric"> | Date | string
    updatedAt?: DateTimeFilter<"AgentMetric"> | Date | string
  }

  export type AgentTraceUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentTraceWhereUniqueInput
    update: XOR<AgentTraceUpdateWithoutAgentInput, AgentTraceUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentTraceCreateWithoutAgentInput, AgentTraceUncheckedCreateWithoutAgentInput>
  }

  export type AgentTraceUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentTraceWhereUniqueInput
    data: XOR<AgentTraceUpdateWithoutAgentInput, AgentTraceUncheckedUpdateWithoutAgentInput>
  }

  export type AgentTraceUpdateManyWithWhereWithoutAgentInput = {
    where: AgentTraceScalarWhereInput
    data: XOR<AgentTraceUpdateManyMutationInput, AgentTraceUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentTraceScalarWhereInput = {
    AND?: AgentTraceScalarWhereInput | AgentTraceScalarWhereInput[]
    OR?: AgentTraceScalarWhereInput[]
    NOT?: AgentTraceScalarWhereInput | AgentTraceScalarWhereInput[]
    id?: StringFilter<"AgentTrace"> | string
    agentId?: StringFilter<"AgentTrace"> | string
    conversationId?: StringFilter<"AgentTrace"> | string
    userId?: StringFilter<"AgentTrace"> | string
    workspaceId?: StringFilter<"AgentTrace"> | string
    startedAt?: DateTimeFilter<"AgentTrace"> | Date | string
    completedAt?: DateTimeNullableFilter<"AgentTrace"> | Date | string | null
    status?: EnumTraceStatusFilter<"AgentTrace"> | $Enums.TraceStatus
    steps?: JsonFilter<"AgentTrace">
    totalSteps?: IntFilter<"AgentTrace"> | number
    maxSteps?: IntFilter<"AgentTrace"> | number
    totalTokensIn?: IntFilter<"AgentTrace"> | number
    totalTokensOut?: IntFilter<"AgentTrace"> | number
    totalCost?: FloatFilter<"AgentTrace"> | number
    latencyMs?: IntNullableFilter<"AgentTrace"> | number | null
    toolCalls?: JsonFilter<"AgentTrace">
    toolSuccesses?: IntFilter<"AgentTrace"> | number
    toolFailures?: IntFilter<"AgentTrace"> | number
    l1Passed?: BoolNullableFilter<"AgentTrace"> | boolean | null
    l1Failures?: JsonNullableFilter<"AgentTrace">
    l2Score?: FloatNullableFilter<"AgentTrace"> | number | null
    l2Breakdown?: JsonNullableFilter<"AgentTrace">
    l3Triggered?: BoolFilter<"AgentTrace"> | boolean
    l3Blocked?: BoolNullableFilter<"AgentTrace"> | boolean | null
    feedbackScore?: IntNullableFilter<"AgentTrace"> | number | null
    feedbackComment?: StringNullableFilter<"AgentTrace"> | string | null
    userEdited?: BoolFilter<"AgentTrace"> | boolean
    editDiff?: StringNullableFilter<"AgentTrace"> | string | null
  }

  export type AgentInsightUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentInsightWhereUniqueInput
    update: XOR<AgentInsightUpdateWithoutAgentInput, AgentInsightUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentInsightCreateWithoutAgentInput, AgentInsightUncheckedCreateWithoutAgentInput>
  }

  export type AgentInsightUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentInsightWhereUniqueInput
    data: XOR<AgentInsightUpdateWithoutAgentInput, AgentInsightUncheckedUpdateWithoutAgentInput>
  }

  export type AgentInsightUpdateManyWithWhereWithoutAgentInput = {
    where: AgentInsightScalarWhereInput
    data: XOR<AgentInsightUpdateManyMutationInput, AgentInsightUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentInsightScalarWhereInput = {
    AND?: AgentInsightScalarWhereInput | AgentInsightScalarWhereInput[]
    OR?: AgentInsightScalarWhereInput[]
    NOT?: AgentInsightScalarWhereInput | AgentInsightScalarWhereInput[]
    id?: StringFilter<"AgentInsight"> | string
    agentId?: StringFilter<"AgentInsight"> | string
    generatedAt?: DateTimeFilter<"AgentInsight"> | Date | string
    timeframeStart?: DateTimeFilter<"AgentInsight"> | Date | string
    timeframeEnd?: DateTimeFilter<"AgentInsight"> | Date | string
    clusters?: JsonFilter<"AgentInsight">
    patterns?: JsonFilter<"AgentInsight">
    anomalies?: JsonFilter<"AgentInsight">
    opportunities?: JsonFilter<"AgentInsight">
  }

  export type AgentFeedbackUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentFeedbackWhereUniqueInput
    update: XOR<AgentFeedbackUpdateWithoutAgentInput, AgentFeedbackUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentFeedbackCreateWithoutAgentInput, AgentFeedbackUncheckedCreateWithoutAgentInput>
  }

  export type AgentFeedbackUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentFeedbackWhereUniqueInput
    data: XOR<AgentFeedbackUpdateWithoutAgentInput, AgentFeedbackUncheckedUpdateWithoutAgentInput>
  }

  export type AgentFeedbackUpdateManyWithWhereWithoutAgentInput = {
    where: AgentFeedbackScalarWhereInput
    data: XOR<AgentFeedbackUpdateManyMutationInput, AgentFeedbackUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentFeedbackScalarWhereInput = {
    AND?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
    OR?: AgentFeedbackScalarWhereInput[]
    NOT?: AgentFeedbackScalarWhereInput | AgentFeedbackScalarWhereInput[]
    id?: StringFilter<"AgentFeedback"> | string
    traceId?: StringFilter<"AgentFeedback"> | string
    conversationId?: StringFilter<"AgentFeedback"> | string
    userId?: StringFilter<"AgentFeedback"> | string
    agentId?: StringFilter<"AgentFeedback"> | string
    type?: EnumFeedbackTypeFilter<"AgentFeedback"> | $Enums.FeedbackType
    timestamp?: DateTimeFilter<"AgentFeedback"> | Date | string
    originalOutput?: StringFilter<"AgentFeedback"> | string
    userEdit?: StringNullableFilter<"AgentFeedback"> | string | null
    correctionText?: StringNullableFilter<"AgentFeedback"> | string | null
    stepNumber?: IntFilter<"AgentFeedback"> | number
    metadata?: JsonNullableFilter<"AgentFeedback">
  }

  export type AgentABTestUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentABTestWhereUniqueInput
    update: XOR<AgentABTestUpdateWithoutAgentInput, AgentABTestUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentABTestCreateWithoutAgentInput, AgentABTestUncheckedCreateWithoutAgentInput>
  }

  export type AgentABTestUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentABTestWhereUniqueInput
    data: XOR<AgentABTestUpdateWithoutAgentInput, AgentABTestUncheckedUpdateWithoutAgentInput>
  }

  export type AgentABTestUpdateManyWithWhereWithoutAgentInput = {
    where: AgentABTestScalarWhereInput
    data: XOR<AgentABTestUpdateManyMutationInput, AgentABTestUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentABTestScalarWhereInput = {
    AND?: AgentABTestScalarWhereInput | AgentABTestScalarWhereInput[]
    OR?: AgentABTestScalarWhereInput[]
    NOT?: AgentABTestScalarWhereInput | AgentABTestScalarWhereInput[]
    id?: StringFilter<"AgentABTest"> | string
    agentId?: StringFilter<"AgentABTest"> | string
    variantAPrompt?: StringFilter<"AgentABTest"> | string
    variantBPrompt?: StringFilter<"AgentABTest"> | string
    trafficSplit?: FloatFilter<"AgentABTest"> | number
    status?: EnumABTestStatusFilter<"AgentABTest"> | $Enums.ABTestStatus
    startedAt?: DateTimeFilter<"AgentABTest"> | Date | string
    endedAt?: DateTimeNullableFilter<"AgentABTest"> | Date | string | null
    variantATraces?: IntFilter<"AgentABTest"> | number
    variantBTraces?: IntFilter<"AgentABTest"> | number
    variantAScore?: FloatNullableFilter<"AgentABTest"> | number | null
    variantBScore?: FloatNullableFilter<"AgentABTest"> | number | null
    winningVariant?: StringNullableFilter<"AgentABTest"> | string | null
  }

  export type OptimizationRunUpsertWithWhereUniqueWithoutAgentInput = {
    where: OptimizationRunWhereUniqueInput
    update: XOR<OptimizationRunUpdateWithoutAgentInput, OptimizationRunUncheckedUpdateWithoutAgentInput>
    create: XOR<OptimizationRunCreateWithoutAgentInput, OptimizationRunUncheckedCreateWithoutAgentInput>
  }

  export type OptimizationRunUpdateWithWhereUniqueWithoutAgentInput = {
    where: OptimizationRunWhereUniqueInput
    data: XOR<OptimizationRunUpdateWithoutAgentInput, OptimizationRunUncheckedUpdateWithoutAgentInput>
  }

  export type OptimizationRunUpdateManyWithWhereWithoutAgentInput = {
    where: OptimizationRunScalarWhereInput
    data: XOR<OptimizationRunUpdateManyMutationInput, OptimizationRunUncheckedUpdateManyWithoutAgentInput>
  }

  export type OptimizationRunScalarWhereInput = {
    AND?: OptimizationRunScalarWhereInput | OptimizationRunScalarWhereInput[]
    OR?: OptimizationRunScalarWhereInput[]
    NOT?: OptimizationRunScalarWhereInput | OptimizationRunScalarWhereInput[]
    id?: StringFilter<"OptimizationRun"> | string
    agentId?: StringFilter<"OptimizationRun"> | string
    triggeredAt?: DateTimeFilter<"OptimizationRun"> | Date | string
    triggeredBy?: StringFilter<"OptimizationRun"> | string
    editPatterns?: JsonFilter<"OptimizationRun">
    promptVariations?: JsonFilter<"OptimizationRun">
    testResults?: JsonFilter<"OptimizationRun">
    recommendation?: StringFilter<"OptimizationRun"> | string
    abTestId?: StringNullableFilter<"OptimizationRun"> | string | null
    status?: StringFilter<"OptimizationRun"> | string
  }

  export type ModificationProposalUpsertWithWhereUniqueWithoutAgentInput = {
    where: ModificationProposalWhereUniqueInput
    update: XOR<ModificationProposalUpdateWithoutAgentInput, ModificationProposalUncheckedUpdateWithoutAgentInput>
    create: XOR<ModificationProposalCreateWithoutAgentInput, ModificationProposalUncheckedCreateWithoutAgentInput>
  }

  export type ModificationProposalUpdateWithWhereUniqueWithoutAgentInput = {
    where: ModificationProposalWhereUniqueInput
    data: XOR<ModificationProposalUpdateWithoutAgentInput, ModificationProposalUncheckedUpdateWithoutAgentInput>
  }

  export type ModificationProposalUpdateManyWithWhereWithoutAgentInput = {
    where: ModificationProposalScalarWhereInput
    data: XOR<ModificationProposalUpdateManyMutationInput, ModificationProposalUncheckedUpdateManyWithoutAgentInput>
  }

  export type ModificationProposalScalarWhereInput = {
    AND?: ModificationProposalScalarWhereInput | ModificationProposalScalarWhereInput[]
    OR?: ModificationProposalScalarWhereInput[]
    NOT?: ModificationProposalScalarWhereInput | ModificationProposalScalarWhereInput[]
    id?: StringFilter<"ModificationProposal"> | string
    agentId?: StringFilter<"ModificationProposal"> | string
    proposedAt?: DateTimeFilter<"ModificationProposal"> | Date | string
    type?: EnumModificationTypeFilter<"ModificationProposal"> | $Enums.ModificationType
    current?: StringFilter<"ModificationProposal"> | string
    proposed?: StringFilter<"ModificationProposal"> | string
    rationale?: StringFilter<"ModificationProposal"> | string
    impact?: StringFilter<"ModificationProposal"> | string
    status?: EnumProposalStatusFilter<"ModificationProposal"> | $Enums.ProposalStatus
    reviewedAt?: DateTimeNullableFilter<"ModificationProposal"> | Date | string | null
    reviewedBy?: StringNullableFilter<"ModificationProposal"> | string | null
    appliedAt?: DateTimeNullableFilter<"ModificationProposal"> | Date | string | null
  }

  export type AgentCreateWithoutConnectedToInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutConnectedToInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutConnectedToInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutConnectedToInput, AgentUncheckedCreateWithoutConnectedToInput>
  }

  export type AgentCreateWithoutConnectedFromInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutConnectedFromInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutConnectedFromInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutConnectedFromInput, AgentUncheckedCreateWithoutConnectedFromInput>
  }

  export type AgentUpsertWithoutConnectedToInput = {
    update: XOR<AgentUpdateWithoutConnectedToInput, AgentUncheckedUpdateWithoutConnectedToInput>
    create: XOR<AgentCreateWithoutConnectedToInput, AgentUncheckedCreateWithoutConnectedToInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutConnectedToInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutConnectedToInput, AgentUncheckedUpdateWithoutConnectedToInput>
  }

  export type AgentUpdateWithoutConnectedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutConnectedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUpsertWithoutConnectedFromInput = {
    update: XOR<AgentUpdateWithoutConnectedFromInput, AgentUncheckedUpdateWithoutConnectedFromInput>
    create: XOR<AgentCreateWithoutConnectedFromInput, AgentUncheckedCreateWithoutConnectedFromInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutConnectedFromInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutConnectedFromInput, AgentUncheckedUpdateWithoutConnectedFromInput>
  }

  export type AgentUpdateWithoutConnectedFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutConnectedFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutAgentToolsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAgentToolsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAgentToolsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAgentToolsInput, AgentUncheckedCreateWithoutAgentToolsInput>
  }

  export type WorkflowCreateWithoutAgentToolsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: NodeCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionCreateNestedManyWithoutWorkflowInput
    user: UserCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutAgentToolsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput
    connections?: ConnectionUncheckedCreateNestedManyWithoutWorkflowInput
    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutAgentToolsInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutAgentToolsInput, WorkflowUncheckedCreateWithoutAgentToolsInput>
  }

  export type AgentUpsertWithoutAgentToolsInput = {
    update: XOR<AgentUpdateWithoutAgentToolsInput, AgentUncheckedUpdateWithoutAgentToolsInput>
    create: XOR<AgentCreateWithoutAgentToolsInput, AgentUncheckedCreateWithoutAgentToolsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAgentToolsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAgentToolsInput, AgentUncheckedUpdateWithoutAgentToolsInput>
  }

  export type AgentUpdateWithoutAgentToolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAgentToolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type WorkflowUpsertWithoutAgentToolsInput = {
    update: XOR<WorkflowUpdateWithoutAgentToolsInput, WorkflowUncheckedUpdateWithoutAgentToolsInput>
    create: XOR<WorkflowCreateWithoutAgentToolsInput, WorkflowUncheckedCreateWithoutAgentToolsInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutAgentToolsInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutAgentToolsInput, WorkflowUncheckedUpdateWithoutAgentToolsInput>
  }

  export type WorkflowUpdateWithoutAgentToolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: NodeUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput
    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutAgentToolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUncheckedUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type AgentCreateWithoutConversationsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutConversationsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutConversationsInput, AgentUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationActivityCreateWithoutConversationInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: boolean
    confirmedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConversationActivityUncheckedCreateWithoutConversationInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: boolean
    confirmedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConversationActivityCreateOrConnectWithoutConversationInput = {
    where: ConversationActivityWhereUniqueInput
    create: XOR<ConversationActivityCreateWithoutConversationInput, ConversationActivityUncheckedCreateWithoutConversationInput>
  }

  export type ConversationActivityCreateManyConversationInputEnvelope = {
    data: ConversationActivityCreateManyConversationInput | ConversationActivityCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type AgentTraceCreateWithoutConversationInput = {
    id?: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    agent: AgentCreateNestedOneWithoutTracesInput
    aiEvents?: AiEventCreateNestedManyWithoutTraceInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceUncheckedCreateWithoutConversationInput = {
    id?: string
    agentId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    aiEvents?: AiEventUncheckedCreateNestedManyWithoutTraceInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceCreateOrConnectWithoutConversationInput = {
    where: AgentTraceWhereUniqueInput
    create: XOR<AgentTraceCreateWithoutConversationInput, AgentTraceUncheckedCreateWithoutConversationInput>
  }

  export type AgentTraceCreateManyConversationInputEnvelope = {
    data: AgentTraceCreateManyConversationInput | AgentTraceCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationEvaluationCreateWithoutConversationInput = {
    id?: string
    evaluatedAt?: Date | string
    goalCompleted: boolean
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories?: ConversationEvaluationCreatecategoriesInput | string[]
    failureModes?: ConversationEvaluationCreatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationCreateimprovementSuggestionsInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationUncheckedCreateWithoutConversationInput = {
    id?: string
    evaluatedAt?: Date | string
    goalCompleted: boolean
    goalCompletionConfidence: number
    userSatisfactionScore: number
    categories?: ConversationEvaluationCreatecategoriesInput | string[]
    failureModes?: ConversationEvaluationCreatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationCreateimprovementSuggestionsInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationCreateOrConnectWithoutConversationInput = {
    where: ConversationEvaluationWhereUniqueInput
    create: XOR<ConversationEvaluationCreateWithoutConversationInput, ConversationEvaluationUncheckedCreateWithoutConversationInput>
  }

  export type AgentFeedbackCreateWithoutConversationInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    trace: AgentTraceCreateNestedOneWithoutFeedbacksInput
    agent: AgentCreateNestedOneWithoutFeedbacksInput
  }

  export type AgentFeedbackUncheckedCreateWithoutConversationInput = {
    id?: string
    traceId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackCreateOrConnectWithoutConversationInput = {
    where: AgentFeedbackWhereUniqueInput
    create: XOR<AgentFeedbackCreateWithoutConversationInput, AgentFeedbackUncheckedCreateWithoutConversationInput>
  }

  export type AgentFeedbackCreateManyConversationInputEnvelope = {
    data: AgentFeedbackCreateManyConversationInput | AgentFeedbackCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutConversationsInput = {
    update: XOR<AgentUpdateWithoutConversationsInput, AgentUncheckedUpdateWithoutConversationsInput>
    create: XOR<AgentCreateWithoutConversationsInput, AgentUncheckedCreateWithoutConversationsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutConversationsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutConversationsInput, AgentUncheckedUpdateWithoutConversationsInput>
  }

  export type AgentUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    toolName?: StringNullableFilter<"Message"> | string | null
    toolInput?: JsonNullableFilter<"Message">
    toolOutput?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ConversationActivityUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationActivityWhereUniqueInput
    update: XOR<ConversationActivityUpdateWithoutConversationInput, ConversationActivityUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationActivityCreateWithoutConversationInput, ConversationActivityUncheckedCreateWithoutConversationInput>
  }

  export type ConversationActivityUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationActivityWhereUniqueInput
    data: XOR<ConversationActivityUpdateWithoutConversationInput, ConversationActivityUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationActivityUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationActivityScalarWhereInput
    data: XOR<ConversationActivityUpdateManyMutationInput, ConversationActivityUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationActivityScalarWhereInput = {
    AND?: ConversationActivityScalarWhereInput | ConversationActivityScalarWhereInput[]
    OR?: ConversationActivityScalarWhereInput[]
    NOT?: ConversationActivityScalarWhereInput | ConversationActivityScalarWhereInput[]
    id?: StringFilter<"ConversationActivity"> | string
    conversationId?: StringFilter<"ConversationActivity"> | string
    type?: EnumActivityTypeFilter<"ConversationActivity"> | $Enums.ActivityType
    title?: StringFilter<"ConversationActivity"> | string
    details?: JsonNullableFilter<"ConversationActivity">
    requiresConfirmation?: BoolFilter<"ConversationActivity"> | boolean
    confirmedAt?: DateTimeNullableFilter<"ConversationActivity"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ConversationActivity"> | Date | string | null
    createdAt?: DateTimeFilter<"ConversationActivity"> | Date | string
  }

  export type AgentTraceUpsertWithWhereUniqueWithoutConversationInput = {
    where: AgentTraceWhereUniqueInput
    update: XOR<AgentTraceUpdateWithoutConversationInput, AgentTraceUncheckedUpdateWithoutConversationInput>
    create: XOR<AgentTraceCreateWithoutConversationInput, AgentTraceUncheckedCreateWithoutConversationInput>
  }

  export type AgentTraceUpdateWithWhereUniqueWithoutConversationInput = {
    where: AgentTraceWhereUniqueInput
    data: XOR<AgentTraceUpdateWithoutConversationInput, AgentTraceUncheckedUpdateWithoutConversationInput>
  }

  export type AgentTraceUpdateManyWithWhereWithoutConversationInput = {
    where: AgentTraceScalarWhereInput
    data: XOR<AgentTraceUpdateManyMutationInput, AgentTraceUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationEvaluationUpsertWithoutConversationInput = {
    update: XOR<ConversationEvaluationUpdateWithoutConversationInput, ConversationEvaluationUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationEvaluationCreateWithoutConversationInput, ConversationEvaluationUncheckedCreateWithoutConversationInput>
    where?: ConversationEvaluationWhereInput
  }

  export type ConversationEvaluationUpdateToOneWithWhereWithoutConversationInput = {
    where?: ConversationEvaluationWhereInput
    data: XOR<ConversationEvaluationUpdateWithoutConversationInput, ConversationEvaluationUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationEvaluationUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalCompleted?: BoolFieldUpdateOperationsInput | boolean
    goalCompletionConfidence?: FloatFieldUpdateOperationsInput | number
    userSatisfactionScore?: FloatFieldUpdateOperationsInput | number
    categories?: ConversationEvaluationUpdatecategoriesInput | string[]
    failureModes?: ConversationEvaluationUpdatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationUpdateimprovementSuggestionsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationEvaluationUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalCompleted?: BoolFieldUpdateOperationsInput | boolean
    goalCompletionConfidence?: FloatFieldUpdateOperationsInput | number
    userSatisfactionScore?: FloatFieldUpdateOperationsInput | number
    categories?: ConversationEvaluationUpdatecategoriesInput | string[]
    failureModes?: ConversationEvaluationUpdatefailureModesInput | string[]
    improvementSuggestions?: ConversationEvaluationUpdateimprovementSuggestionsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUpsertWithWhereUniqueWithoutConversationInput = {
    where: AgentFeedbackWhereUniqueInput
    update: XOR<AgentFeedbackUpdateWithoutConversationInput, AgentFeedbackUncheckedUpdateWithoutConversationInput>
    create: XOR<AgentFeedbackCreateWithoutConversationInput, AgentFeedbackUncheckedCreateWithoutConversationInput>
  }

  export type AgentFeedbackUpdateWithWhereUniqueWithoutConversationInput = {
    where: AgentFeedbackWhereUniqueInput
    data: XOR<AgentFeedbackUpdateWithoutConversationInput, AgentFeedbackUncheckedUpdateWithoutConversationInput>
  }

  export type AgentFeedbackUpdateManyWithWhereWithoutConversationInput = {
    where: AgentFeedbackScalarWhereInput
    data: XOR<AgentFeedbackUpdateManyMutationInput, AgentFeedbackUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutConversationsInput
    activities?: ConversationActivityCreateNestedManyWithoutConversationInput
    traces?: AgentTraceCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ConversationActivityUncheckedCreateNestedManyWithoutConversationInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutConversationsNestedInput
    activities?: ConversationActivityUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateWithoutActivitiesInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    traces?: AgentTraceCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutActivitiesInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutActivitiesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutActivitiesInput, ConversationUncheckedCreateWithoutActivitiesInput>
  }

  export type ConversationUpsertWithoutActivitiesInput = {
    update: XOR<ConversationUpdateWithoutActivitiesInput, ConversationUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ConversationCreateWithoutActivitiesInput, ConversationUncheckedCreateWithoutActivitiesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutActivitiesInput, ConversationUncheckedUpdateWithoutActivitiesInput>
  }

  export type ConversationUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AgentCreateWithoutMemoriesInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMemoriesInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMemoriesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMemoriesInput, AgentUncheckedCreateWithoutMemoriesInput>
  }

  export type AgentUpsertWithoutMemoriesInput = {
    update: XOR<AgentUpdateWithoutMemoriesInput, AgentUncheckedUpdateWithoutMemoriesInput>
    create: XOR<AgentCreateWithoutMemoriesInput, AgentUncheckedCreateWithoutMemoriesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMemoriesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMemoriesInput, AgentUncheckedUpdateWithoutMemoriesInput>
  }

  export type AgentUpdateWithoutMemoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMemoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutKnowledgeDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutKnowledgeDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutKnowledgeDocumentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutKnowledgeDocumentsInput, AgentUncheckedCreateWithoutKnowledgeDocumentsInput>
  }

  export type KnowledgeChunkCreateWithoutDocumentInput = {
    id?: string
    content: string
    embedding?: KnowledgeChunkCreateembeddingInput | number[]
    position: number
    pageNumber?: number | null
    heading?: string | null
    createdAt?: Date | string
  }

  export type KnowledgeChunkUncheckedCreateWithoutDocumentInput = {
    id?: string
    content: string
    embedding?: KnowledgeChunkCreateembeddingInput | number[]
    position: number
    pageNumber?: number | null
    heading?: string | null
    createdAt?: Date | string
  }

  export type KnowledgeChunkCreateOrConnectWithoutDocumentInput = {
    where: KnowledgeChunkWhereUniqueInput
    create: XOR<KnowledgeChunkCreateWithoutDocumentInput, KnowledgeChunkUncheckedCreateWithoutDocumentInput>
  }

  export type KnowledgeChunkCreateManyDocumentInputEnvelope = {
    data: KnowledgeChunkCreateManyDocumentInput | KnowledgeChunkCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutKnowledgeDocumentsInput = {
    update: XOR<AgentUpdateWithoutKnowledgeDocumentsInput, AgentUncheckedUpdateWithoutKnowledgeDocumentsInput>
    create: XOR<AgentCreateWithoutKnowledgeDocumentsInput, AgentUncheckedCreateWithoutKnowledgeDocumentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutKnowledgeDocumentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutKnowledgeDocumentsInput, AgentUncheckedUpdateWithoutKnowledgeDocumentsInput>
  }

  export type AgentUpdateWithoutKnowledgeDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutKnowledgeDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type KnowledgeChunkUpsertWithWhereUniqueWithoutDocumentInput = {
    where: KnowledgeChunkWhereUniqueInput
    update: XOR<KnowledgeChunkUpdateWithoutDocumentInput, KnowledgeChunkUncheckedUpdateWithoutDocumentInput>
    create: XOR<KnowledgeChunkCreateWithoutDocumentInput, KnowledgeChunkUncheckedCreateWithoutDocumentInput>
  }

  export type KnowledgeChunkUpdateWithWhereUniqueWithoutDocumentInput = {
    where: KnowledgeChunkWhereUniqueInput
    data: XOR<KnowledgeChunkUpdateWithoutDocumentInput, KnowledgeChunkUncheckedUpdateWithoutDocumentInput>
  }

  export type KnowledgeChunkUpdateManyWithWhereWithoutDocumentInput = {
    where: KnowledgeChunkScalarWhereInput
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyWithoutDocumentInput>
  }

  export type KnowledgeChunkScalarWhereInput = {
    AND?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
    OR?: KnowledgeChunkScalarWhereInput[]
    NOT?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
    id?: StringFilter<"KnowledgeChunk"> | string
    documentId?: StringFilter<"KnowledgeChunk"> | string
    content?: StringFilter<"KnowledgeChunk"> | string
    embedding?: FloatNullableListFilter<"KnowledgeChunk">
    position?: IntFilter<"KnowledgeChunk"> | number
    pageNumber?: IntNullableFilter<"KnowledgeChunk"> | number | null
    heading?: StringNullableFilter<"KnowledgeChunk"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeChunk"> | Date | string
  }

  export type KnowledgeDocumentCreateWithoutChunksInput = {
    id?: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutKnowledgeDocumentsInput
  }

  export type KnowledgeDocumentUncheckedCreateWithoutChunksInput = {
    id?: string
    agentId: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeDocumentCreateOrConnectWithoutChunksInput = {
    where: KnowledgeDocumentWhereUniqueInput
    create: XOR<KnowledgeDocumentCreateWithoutChunksInput, KnowledgeDocumentUncheckedCreateWithoutChunksInput>
  }

  export type KnowledgeDocumentUpsertWithoutChunksInput = {
    update: XOR<KnowledgeDocumentUpdateWithoutChunksInput, KnowledgeDocumentUncheckedUpdateWithoutChunksInput>
    create: XOR<KnowledgeDocumentCreateWithoutChunksInput, KnowledgeDocumentUncheckedCreateWithoutChunksInput>
    where?: KnowledgeDocumentWhereInput
  }

  export type KnowledgeDocumentUpdateToOneWithWhereWithoutChunksInput = {
    where?: KnowledgeDocumentWhereInput
    data: XOR<KnowledgeDocumentUpdateWithoutChunksInput, KnowledgeDocumentUncheckedUpdateWithoutChunksInput>
  }

  export type KnowledgeDocumentUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutKnowledgeDocumentsNestedInput
  }

  export type KnowledgeDocumentUncheckedUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateWithoutKnowledgeSettingsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutKnowledgeSettingsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutKnowledgeSettingsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutKnowledgeSettingsInput, AgentUncheckedCreateWithoutKnowledgeSettingsInput>
  }

  export type AgentUpsertWithoutKnowledgeSettingsInput = {
    update: XOR<AgentUpdateWithoutKnowledgeSettingsInput, AgentUncheckedUpdateWithoutKnowledgeSettingsInput>
    create: XOR<AgentCreateWithoutKnowledgeSettingsInput, AgentUncheckedCreateWithoutKnowledgeSettingsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutKnowledgeSettingsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutKnowledgeSettingsInput, AgentUncheckedUpdateWithoutKnowledgeSettingsInput>
  }

  export type AgentUpdateWithoutKnowledgeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutKnowledgeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutTriggersInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTriggersInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTriggersInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTriggersInput, AgentUncheckedCreateWithoutTriggersInput>
  }

  export type AgentUpsertWithoutTriggersInput = {
    update: XOR<AgentUpdateWithoutTriggersInput, AgentUncheckedUpdateWithoutTriggersInput>
    create: XOR<AgentCreateWithoutTriggersInput, AgentUncheckedCreateWithoutTriggersInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTriggersInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTriggersInput, AgentUncheckedUpdateWithoutTriggersInput>
  }

  export type AgentUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTemplateInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTemplateInput, AgentUncheckedCreateWithoutTemplateInput>
  }

  export type AgentCreateManyTemplateInputEnvelope = {
    data: AgentCreateManyTemplateInput | AgentCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithWhereUniqueWithoutTemplateInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutTemplateInput, AgentUncheckedUpdateWithoutTemplateInput>
    create: XOR<AgentCreateWithoutTemplateInput, AgentUncheckedCreateWithoutTemplateInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutTemplateInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutTemplateInput, AgentUncheckedUpdateWithoutTemplateInput>
  }

  export type AgentUpdateManyWithWhereWithoutTemplateInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AgentCreateWithoutEmbedInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutEmbedInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutEmbedInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutEmbedInput, AgentUncheckedCreateWithoutEmbedInput>
  }

  export type AgentUpsertWithoutEmbedInput = {
    update: XOR<AgentUpdateWithoutEmbedInput, AgentUncheckedUpdateWithoutEmbedInput>
    create: XOR<AgentCreateWithoutEmbedInput, AgentUncheckedCreateWithoutEmbedInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutEmbedInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutEmbedInput, AgentUncheckedUpdateWithoutEmbedInput>
  }

  export type AgentUpdateWithoutEmbedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutEmbedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutEmailAddressInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutEmailAddressInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutEmailAddressInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutEmailAddressInput, AgentUncheckedCreateWithoutEmailAddressInput>
  }

  export type AgentUpsertWithoutEmailAddressInput = {
    update: XOR<AgentUpdateWithoutEmailAddressInput, AgentUncheckedUpdateWithoutEmailAddressInput>
    create: XOR<AgentCreateWithoutEmailAddressInput, AgentUncheckedCreateWithoutEmailAddressInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutEmailAddressInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutEmailAddressInput, AgentUncheckedUpdateWithoutEmailAddressInput>
  }

  export type AgentUpdateWithoutEmailAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutEmailAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutIntegrationsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    workflows?: WorkflowCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIntegrationsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
  }

  export type UserUpsertWithoutIntegrationsInput = {
    update: XOR<UserUpdateWithoutIntegrationsInput, UserUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIntegrationsInput, UserUncheckedUpdateWithoutIntegrationsInput>
  }

  export type UserUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentCreateWithoutSwarmsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutSwarmsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutSwarmsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutSwarmsInput, AgentUncheckedCreateWithoutSwarmsInput>
  }

  export type SwarmTaskCreateWithoutSwarmInput = {
    id?: string
    input: JsonNullValueInput | InputJsonValue
    status?: $Enums.SwarmTaskStatus
    output?: string | null
    error?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SwarmTaskUncheckedCreateWithoutSwarmInput = {
    id?: string
    input: JsonNullValueInput | InputJsonValue
    status?: $Enums.SwarmTaskStatus
    output?: string | null
    error?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SwarmTaskCreateOrConnectWithoutSwarmInput = {
    where: SwarmTaskWhereUniqueInput
    create: XOR<SwarmTaskCreateWithoutSwarmInput, SwarmTaskUncheckedCreateWithoutSwarmInput>
  }

  export type SwarmTaskCreateManySwarmInputEnvelope = {
    data: SwarmTaskCreateManySwarmInput | SwarmTaskCreateManySwarmInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutSwarmsInput = {
    update: XOR<AgentUpdateWithoutSwarmsInput, AgentUncheckedUpdateWithoutSwarmsInput>
    create: XOR<AgentCreateWithoutSwarmsInput, AgentUncheckedCreateWithoutSwarmsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutSwarmsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutSwarmsInput, AgentUncheckedUpdateWithoutSwarmsInput>
  }

  export type AgentUpdateWithoutSwarmsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutSwarmsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type SwarmTaskUpsertWithWhereUniqueWithoutSwarmInput = {
    where: SwarmTaskWhereUniqueInput
    update: XOR<SwarmTaskUpdateWithoutSwarmInput, SwarmTaskUncheckedUpdateWithoutSwarmInput>
    create: XOR<SwarmTaskCreateWithoutSwarmInput, SwarmTaskUncheckedCreateWithoutSwarmInput>
  }

  export type SwarmTaskUpdateWithWhereUniqueWithoutSwarmInput = {
    where: SwarmTaskWhereUniqueInput
    data: XOR<SwarmTaskUpdateWithoutSwarmInput, SwarmTaskUncheckedUpdateWithoutSwarmInput>
  }

  export type SwarmTaskUpdateManyWithWhereWithoutSwarmInput = {
    where: SwarmTaskScalarWhereInput
    data: XOR<SwarmTaskUpdateManyMutationInput, SwarmTaskUncheckedUpdateManyWithoutSwarmInput>
  }

  export type SwarmTaskScalarWhereInput = {
    AND?: SwarmTaskScalarWhereInput | SwarmTaskScalarWhereInput[]
    OR?: SwarmTaskScalarWhereInput[]
    NOT?: SwarmTaskScalarWhereInput | SwarmTaskScalarWhereInput[]
    id?: StringFilter<"SwarmTask"> | string
    swarmId?: StringFilter<"SwarmTask"> | string
    input?: JsonFilter<"SwarmTask">
    status?: EnumSwarmTaskStatusFilter<"SwarmTask"> | $Enums.SwarmTaskStatus
    output?: StringNullableFilter<"SwarmTask"> | string | null
    error?: StringNullableFilter<"SwarmTask"> | string | null
    startedAt?: DateTimeNullableFilter<"SwarmTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SwarmTask"> | Date | string | null
    createdAt?: DateTimeFilter<"SwarmTask"> | Date | string
  }

  export type AgentSwarmCreateWithoutTasksInput = {
    id?: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutSwarmsInput
  }

  export type AgentSwarmUncheckedCreateWithoutTasksInput = {
    id?: string
    agentId: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentSwarmCreateOrConnectWithoutTasksInput = {
    where: AgentSwarmWhereUniqueInput
    create: XOR<AgentSwarmCreateWithoutTasksInput, AgentSwarmUncheckedCreateWithoutTasksInput>
  }

  export type AgentSwarmUpsertWithoutTasksInput = {
    update: XOR<AgentSwarmUpdateWithoutTasksInput, AgentSwarmUncheckedUpdateWithoutTasksInput>
    create: XOR<AgentSwarmCreateWithoutTasksInput, AgentSwarmUncheckedCreateWithoutTasksInput>
    where?: AgentSwarmWhereInput
  }

  export type AgentSwarmUpdateToOneWithWhereWithoutTasksInput = {
    where?: AgentSwarmWhereInput
    data: XOR<AgentSwarmUpdateWithoutTasksInput, AgentSwarmUncheckedUpdateWithoutTasksInput>
  }

  export type AgentSwarmUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutSwarmsNestedInput
  }

  export type AgentSwarmUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateWithoutMeetingRecordingsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMeetingRecordingsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMeetingRecordingsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMeetingRecordingsInput, AgentUncheckedCreateWithoutMeetingRecordingsInput>
  }

  export type AgentUpsertWithoutMeetingRecordingsInput = {
    update: XOR<AgentUpdateWithoutMeetingRecordingsInput, AgentUncheckedUpdateWithoutMeetingRecordingsInput>
    create: XOR<AgentCreateWithoutMeetingRecordingsInput, AgentUncheckedCreateWithoutMeetingRecordingsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMeetingRecordingsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMeetingRecordingsInput, AgentUncheckedUpdateWithoutMeetingRecordingsInput>
  }

  export type AgentUpdateWithoutMeetingRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMeetingRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutPhoneNumberInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutPhoneNumberInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutPhoneNumberInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPhoneNumberInput, AgentUncheckedCreateWithoutPhoneNumberInput>
  }

  export type PhoneCallCreateWithoutPhoneNumberInput = {
    id?: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status?: $Enums.CallStatus
    twilioCallSid?: string | null
    recordingUrl?: string | null
    transcript?: string | null
    conversationId?: string | null
    duration?: number | null
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type PhoneCallUncheckedCreateWithoutPhoneNumberInput = {
    id?: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status?: $Enums.CallStatus
    twilioCallSid?: string | null
    recordingUrl?: string | null
    transcript?: string | null
    conversationId?: string | null
    duration?: number | null
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type PhoneCallCreateOrConnectWithoutPhoneNumberInput = {
    where: PhoneCallWhereUniqueInput
    create: XOR<PhoneCallCreateWithoutPhoneNumberInput, PhoneCallUncheckedCreateWithoutPhoneNumberInput>
  }

  export type PhoneCallCreateManyPhoneNumberInputEnvelope = {
    data: PhoneCallCreateManyPhoneNumberInput | PhoneCallCreateManyPhoneNumberInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutPhoneNumberInput = {
    update: XOR<AgentUpdateWithoutPhoneNumberInput, AgentUncheckedUpdateWithoutPhoneNumberInput>
    create: XOR<AgentCreateWithoutPhoneNumberInput, AgentUncheckedCreateWithoutPhoneNumberInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPhoneNumberInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPhoneNumberInput, AgentUncheckedUpdateWithoutPhoneNumberInput>
  }

  export type AgentUpdateWithoutPhoneNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutPhoneNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PhoneCallUpsertWithWhereUniqueWithoutPhoneNumberInput = {
    where: PhoneCallWhereUniqueInput
    update: XOR<PhoneCallUpdateWithoutPhoneNumberInput, PhoneCallUncheckedUpdateWithoutPhoneNumberInput>
    create: XOR<PhoneCallCreateWithoutPhoneNumberInput, PhoneCallUncheckedCreateWithoutPhoneNumberInput>
  }

  export type PhoneCallUpdateWithWhereUniqueWithoutPhoneNumberInput = {
    where: PhoneCallWhereUniqueInput
    data: XOR<PhoneCallUpdateWithoutPhoneNumberInput, PhoneCallUncheckedUpdateWithoutPhoneNumberInput>
  }

  export type PhoneCallUpdateManyWithWhereWithoutPhoneNumberInput = {
    where: PhoneCallScalarWhereInput
    data: XOR<PhoneCallUpdateManyMutationInput, PhoneCallUncheckedUpdateManyWithoutPhoneNumberInput>
  }

  export type PhoneCallScalarWhereInput = {
    AND?: PhoneCallScalarWhereInput | PhoneCallScalarWhereInput[]
    OR?: PhoneCallScalarWhereInput[]
    NOT?: PhoneCallScalarWhereInput | PhoneCallScalarWhereInput[]
    id?: StringFilter<"PhoneCall"> | string
    phoneNumberId?: StringFilter<"PhoneCall"> | string
    direction?: EnumCallDirectionFilter<"PhoneCall"> | $Enums.CallDirection
    fromNumber?: StringFilter<"PhoneCall"> | string
    toNumber?: StringFilter<"PhoneCall"> | string
    status?: EnumCallStatusFilter<"PhoneCall"> | $Enums.CallStatus
    twilioCallSid?: StringNullableFilter<"PhoneCall"> | string | null
    recordingUrl?: StringNullableFilter<"PhoneCall"> | string | null
    transcript?: StringNullableFilter<"PhoneCall"> | string | null
    conversationId?: StringNullableFilter<"PhoneCall"> | string | null
    duration?: IntNullableFilter<"PhoneCall"> | number | null
    startedAt?: DateTimeFilter<"PhoneCall"> | Date | string
    endedAt?: DateTimeNullableFilter<"PhoneCall"> | Date | string | null
  }

  export type AgentPhoneNumberCreateWithoutCallsInput = {
    id?: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutPhoneNumberInput
  }

  export type AgentPhoneNumberUncheckedCreateWithoutCallsInput = {
    id?: string
    agentId: string
    phoneNumber: string
    twilioSid: string
    voiceEnabled?: boolean
    voiceGreeting?: string | null
    createdAt?: Date | string
  }

  export type AgentPhoneNumberCreateOrConnectWithoutCallsInput = {
    where: AgentPhoneNumberWhereUniqueInput
    create: XOR<AgentPhoneNumberCreateWithoutCallsInput, AgentPhoneNumberUncheckedCreateWithoutCallsInput>
  }

  export type AgentPhoneNumberUpsertWithoutCallsInput = {
    update: XOR<AgentPhoneNumberUpdateWithoutCallsInput, AgentPhoneNumberUncheckedUpdateWithoutCallsInput>
    create: XOR<AgentPhoneNumberCreateWithoutCallsInput, AgentPhoneNumberUncheckedCreateWithoutCallsInput>
    where?: AgentPhoneNumberWhereInput
  }

  export type AgentPhoneNumberUpdateToOneWithWhereWithoutCallsInput = {
    where?: AgentPhoneNumberWhereInput
    data: XOR<AgentPhoneNumberUpdateWithoutCallsInput, AgentPhoneNumberUncheckedUpdateWithoutCallsInput>
  }

  export type AgentPhoneNumberUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutPhoneNumberNestedInput
  }

  export type AgentPhoneNumberUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    twilioSid?: StringFieldUpdateOperationsInput | string
    voiceEnabled?: BoolFieldUpdateOperationsInput | boolean
    voiceGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMetricsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMetricsInput, AgentUncheckedCreateWithoutMetricsInput>
  }

  export type AgentUpsertWithoutMetricsInput = {
    update: XOR<AgentUpdateWithoutMetricsInput, AgentUncheckedUpdateWithoutMetricsInput>
    create: XOR<AgentCreateWithoutMetricsInput, AgentUncheckedCreateWithoutMetricsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMetricsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMetricsInput, AgentUncheckedUpdateWithoutMetricsInput>
  }

  export type AgentUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentTraceCreateWithoutAiEventsInput = {
    id?: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    agent: AgentCreateNestedOneWithoutTracesInput
    conversation: ConversationCreateNestedOneWithoutTracesInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceUncheckedCreateWithoutAiEventsInput = {
    id?: string
    agentId: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceCreateOrConnectWithoutAiEventsInput = {
    where: AgentTraceWhereUniqueInput
    create: XOR<AgentTraceCreateWithoutAiEventsInput, AgentTraceUncheckedCreateWithoutAiEventsInput>
  }

  export type AgentTraceUpsertWithoutAiEventsInput = {
    update: XOR<AgentTraceUpdateWithoutAiEventsInput, AgentTraceUncheckedUpdateWithoutAiEventsInput>
    create: XOR<AgentTraceCreateWithoutAiEventsInput, AgentTraceUncheckedCreateWithoutAiEventsInput>
    where?: AgentTraceWhereInput
  }

  export type AgentTraceUpdateToOneWithWhereWithoutAiEventsInput = {
    where?: AgentTraceWhereInput
    data: XOR<AgentTraceUpdateWithoutAiEventsInput, AgentTraceUncheckedUpdateWithoutAiEventsInput>
  }

  export type AgentTraceUpdateWithoutAiEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutTracesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutTracesNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateWithoutAiEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutTraceNestedInput
  }

  export type AgentCreateWithoutTracesInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTracesInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTracesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTracesInput, AgentUncheckedCreateWithoutTracesInput>
  }

  export type ConversationCreateWithoutTracesInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutTracesInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityUncheckedCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutTracesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutTracesInput, ConversationUncheckedCreateWithoutTracesInput>
  }

  export type AiEventCreateWithoutTraceInput = {
    id?: string
    agentId?: string | null
    conversationId?: string | null
    userId: string
    workspaceId?: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber?: number
    action: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: number
    evalResult?: string
    timestamp?: Date | string
  }

  export type AiEventUncheckedCreateWithoutTraceInput = {
    id?: string
    agentId?: string | null
    conversationId?: string | null
    userId: string
    workspaceId?: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber?: number
    action: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: number
    evalResult?: string
    timestamp?: Date | string
  }

  export type AiEventCreateOrConnectWithoutTraceInput = {
    where: AiEventWhereUniqueInput
    create: XOR<AiEventCreateWithoutTraceInput, AiEventUncheckedCreateWithoutTraceInput>
  }

  export type AiEventCreateManyTraceInputEnvelope = {
    data: AiEventCreateManyTraceInput | AiEventCreateManyTraceInput[]
    skipDuplicates?: boolean
  }

  export type AgentFeedbackCreateWithoutTraceInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutFeedbacksInput
    agent: AgentCreateNestedOneWithoutFeedbacksInput
  }

  export type AgentFeedbackUncheckedCreateWithoutTraceInput = {
    id?: string
    conversationId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackCreateOrConnectWithoutTraceInput = {
    where: AgentFeedbackWhereUniqueInput
    create: XOR<AgentFeedbackCreateWithoutTraceInput, AgentFeedbackUncheckedCreateWithoutTraceInput>
  }

  export type AgentFeedbackCreateManyTraceInputEnvelope = {
    data: AgentFeedbackCreateManyTraceInput | AgentFeedbackCreateManyTraceInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutTracesInput = {
    update: XOR<AgentUpdateWithoutTracesInput, AgentUncheckedUpdateWithoutTracesInput>
    create: XOR<AgentCreateWithoutTracesInput, AgentUncheckedCreateWithoutTracesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTracesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTracesInput, AgentUncheckedUpdateWithoutTracesInput>
  }

  export type AgentUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ConversationUpsertWithoutTracesInput = {
    update: XOR<ConversationUpdateWithoutTracesInput, ConversationUncheckedUpdateWithoutTracesInput>
    create: XOR<ConversationCreateWithoutTracesInput, ConversationUncheckedCreateWithoutTracesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutTracesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutTracesInput, ConversationUncheckedUpdateWithoutTracesInput>
  }

  export type ConversationUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiEventUpsertWithWhereUniqueWithoutTraceInput = {
    where: AiEventWhereUniqueInput
    update: XOR<AiEventUpdateWithoutTraceInput, AiEventUncheckedUpdateWithoutTraceInput>
    create: XOR<AiEventCreateWithoutTraceInput, AiEventUncheckedCreateWithoutTraceInput>
  }

  export type AiEventUpdateWithWhereUniqueWithoutTraceInput = {
    where: AiEventWhereUniqueInput
    data: XOR<AiEventUpdateWithoutTraceInput, AiEventUncheckedUpdateWithoutTraceInput>
  }

  export type AiEventUpdateManyWithWhereWithoutTraceInput = {
    where: AiEventScalarWhereInput
    data: XOR<AiEventUpdateManyMutationInput, AiEventUncheckedUpdateManyWithoutTraceInput>
  }

  export type AiEventScalarWhereInput = {
    AND?: AiEventScalarWhereInput | AiEventScalarWhereInput[]
    OR?: AiEventScalarWhereInput[]
    NOT?: AiEventScalarWhereInput | AiEventScalarWhereInput[]
    id?: StringFilter<"AiEvent"> | string
    traceId?: StringNullableFilter<"AiEvent"> | string | null
    agentId?: StringNullableFilter<"AiEvent"> | string | null
    conversationId?: StringNullableFilter<"AiEvent"> | string | null
    userId?: StringFilter<"AiEvent"> | string
    workspaceId?: StringNullableFilter<"AiEvent"> | string | null
    model?: StringFilter<"AiEvent"> | string
    tier?: StringFilter<"AiEvent"> | string
    tokensIn?: IntFilter<"AiEvent"> | number
    tokensOut?: IntFilter<"AiEvent"> | number
    cost?: FloatFilter<"AiEvent"> | number
    latencyMs?: IntFilter<"AiEvent"> | number
    stepNumber?: IntFilter<"AiEvent"> | number
    action?: StringFilter<"AiEvent"> | string
    toolName?: StringNullableFilter<"AiEvent"> | string | null
    toolInput?: JsonNullableFilter<"AiEvent">
    toolOutput?: JsonNullableFilter<"AiEvent">
    stepsUsed?: IntFilter<"AiEvent"> | number
    evalResult?: StringFilter<"AiEvent"> | string
    timestamp?: DateTimeFilter<"AiEvent"> | Date | string
  }

  export type AgentFeedbackUpsertWithWhereUniqueWithoutTraceInput = {
    where: AgentFeedbackWhereUniqueInput
    update: XOR<AgentFeedbackUpdateWithoutTraceInput, AgentFeedbackUncheckedUpdateWithoutTraceInput>
    create: XOR<AgentFeedbackCreateWithoutTraceInput, AgentFeedbackUncheckedCreateWithoutTraceInput>
  }

  export type AgentFeedbackUpdateWithWhereUniqueWithoutTraceInput = {
    where: AgentFeedbackWhereUniqueInput
    data: XOR<AgentFeedbackUpdateWithoutTraceInput, AgentFeedbackUncheckedUpdateWithoutTraceInput>
  }

  export type AgentFeedbackUpdateManyWithWhereWithoutTraceInput = {
    where: AgentFeedbackScalarWhereInput
    data: XOR<AgentFeedbackUpdateManyMutationInput, AgentFeedbackUncheckedUpdateManyWithoutTraceInput>
  }

  export type ConversationCreateWithoutEvaluationInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityCreateNestedManyWithoutConversationInput
    traces?: AgentTraceCreateNestedManyWithoutConversationInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutEvaluationInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityUncheckedCreateNestedManyWithoutConversationInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutConversationInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutEvaluationInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutEvaluationInput, ConversationUncheckedCreateWithoutEvaluationInput>
  }

  export type ConversationUpsertWithoutEvaluationInput = {
    update: XOR<ConversationUpdateWithoutEvaluationInput, ConversationUncheckedUpdateWithoutEvaluationInput>
    create: XOR<ConversationCreateWithoutEvaluationInput, ConversationUncheckedCreateWithoutEvaluationInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutEvaluationInput, ConversationUncheckedUpdateWithoutEvaluationInput>
  }

  export type ConversationUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUpdateManyWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AgentCreateWithoutInsightsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutInsightsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutInsightsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutInsightsInput, AgentUncheckedCreateWithoutInsightsInput>
  }

  export type AgentUpsertWithoutInsightsInput = {
    update: XOR<AgentUpdateWithoutInsightsInput, AgentUncheckedUpdateWithoutInsightsInput>
    create: XOR<AgentCreateWithoutInsightsInput, AgentUncheckedCreateWithoutInsightsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutInsightsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutInsightsInput, AgentUncheckedUpdateWithoutInsightsInput>
  }

  export type AgentUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentTraceCreateWithoutFeedbacksInput = {
    id?: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    agent: AgentCreateNestedOneWithoutTracesInput
    conversation: ConversationCreateNestedOneWithoutTracesInput
    aiEvents?: AiEventCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    agentId: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
    aiEvents?: AiEventUncheckedCreateNestedManyWithoutTraceInput
  }

  export type AgentTraceCreateOrConnectWithoutFeedbacksInput = {
    where: AgentTraceWhereUniqueInput
    create: XOR<AgentTraceCreateWithoutFeedbacksInput, AgentTraceUncheckedCreateWithoutFeedbacksInput>
  }

  export type ConversationCreateWithoutFeedbacksInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityCreateNestedManyWithoutConversationInput
    traces?: AgentTraceCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationCreateNestedOneWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    title?: string | null
    agentId: string
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    activities?: ConversationActivityUncheckedCreateNestedManyWithoutConversationInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutConversationInput
    evaluation?: ConversationEvaluationUncheckedCreateNestedOneWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutFeedbacksInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutFeedbacksInput, ConversationUncheckedCreateWithoutFeedbacksInput>
  }

  export type AgentCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutFeedbacksInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutFeedbacksInput, AgentUncheckedCreateWithoutFeedbacksInput>
  }

  export type AgentTraceUpsertWithoutFeedbacksInput = {
    update: XOR<AgentTraceUpdateWithoutFeedbacksInput, AgentTraceUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<AgentTraceCreateWithoutFeedbacksInput, AgentTraceUncheckedCreateWithoutFeedbacksInput>
    where?: AgentTraceWhereInput
  }

  export type AgentTraceUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: AgentTraceWhereInput
    data: XOR<AgentTraceUpdateWithoutFeedbacksInput, AgentTraceUncheckedUpdateWithoutFeedbacksInput>
  }

  export type AgentTraceUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutTracesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutTracesNestedInput
    aiEvents?: AiEventUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    aiEvents?: AiEventUncheckedUpdateManyWithoutTraceNestedInput
  }

  export type ConversationUpsertWithoutFeedbacksInput = {
    update: XOR<ConversationUpdateWithoutFeedbacksInput, ConversationUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<ConversationCreateWithoutFeedbacksInput, ConversationUncheckedCreateWithoutFeedbacksInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutFeedbacksInput, ConversationUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ConversationUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUpdateOneWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput
  }

  export type AgentUpsertWithoutFeedbacksInput = {
    update: XOR<AgentUpdateWithoutFeedbacksInput, AgentUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<AgentCreateWithoutFeedbacksInput, AgentUncheckedCreateWithoutFeedbacksInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutFeedbacksInput, AgentUncheckedUpdateWithoutFeedbacksInput>
  }

  export type AgentUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutAbTestsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAbTestsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAbTestsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAbTestsInput, AgentUncheckedCreateWithoutAbTestsInput>
  }

  export type AgentUpsertWithoutAbTestsInput = {
    update: XOR<AgentUpdateWithoutAbTestsInput, AgentUncheckedUpdateWithoutAbTestsInput>
    create: XOR<AgentCreateWithoutAbTestsInput, AgentUncheckedCreateWithoutAbTestsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAbTestsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAbTestsInput, AgentUncheckedUpdateWithoutAbTestsInput>
  }

  export type AgentUpdateWithoutAbTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAbTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutOptimizationRunsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutOptimizationRunsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    modificationProposals?: ModificationProposalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutOptimizationRunsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutOptimizationRunsInput, AgentUncheckedCreateWithoutOptimizationRunsInput>
  }

  export type AgentUpsertWithoutOptimizationRunsInput = {
    update: XOR<AgentUpdateWithoutOptimizationRunsInput, AgentUncheckedUpdateWithoutOptimizationRunsInput>
    create: XOR<AgentCreateWithoutOptimizationRunsInput, AgentUncheckedCreateWithoutOptimizationRunsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutOptimizationRunsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutOptimizationRunsInput, AgentUncheckedUpdateWithoutOptimizationRunsInput>
  }

  export type AgentUpdateWithoutOptimizationRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutOptimizationRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutModificationProposalsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AgentTemplateCreateNestedOneWithoutAgentsInput
    user: UserCreateNestedOneWithoutAgentsInput
    credential?: CredentialCreateNestedOneWithoutAgentsInput
    conversations?: ConversationCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricCreateNestedManyWithoutAgentInput
    traces?: AgentTraceCreateNestedManyWithoutAgentInput
    insights?: AgentInsightCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutModificationProposalsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutAgentInput
    agentTools?: AgentToolUncheckedCreateNestedManyWithoutAgentInput
    memories?: AgentMemoryUncheckedCreateNestedManyWithoutAgentInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedCreateNestedManyWithoutAgentInput
    knowledgeSettings?: KnowledgeSettingsUncheckedCreateNestedOneWithoutAgentInput
    triggers?: AgentTriggerUncheckedCreateNestedManyWithoutAgentInput
    embed?: AgentEmbedUncheckedCreateNestedOneWithoutAgentInput
    connectedTo?: AgentConnectionUncheckedCreateNestedManyWithoutSourceAgentInput
    connectedFrom?: AgentConnectionUncheckedCreateNestedManyWithoutTargetAgentInput
    swarms?: AgentSwarmUncheckedCreateNestedManyWithoutAgentInput
    emailAddress?: AgentEmailAddressUncheckedCreateNestedOneWithoutAgentInput
    meetingRecordings?: MeetingRecordingUncheckedCreateNestedManyWithoutAgentInput
    phoneNumber?: AgentPhoneNumberUncheckedCreateNestedOneWithoutAgentInput
    metrics?: AgentMetricUncheckedCreateNestedManyWithoutAgentInput
    traces?: AgentTraceUncheckedCreateNestedManyWithoutAgentInput
    insights?: AgentInsightUncheckedCreateNestedManyWithoutAgentInput
    feedbacks?: AgentFeedbackUncheckedCreateNestedManyWithoutAgentInput
    abTests?: AgentABTestUncheckedCreateNestedManyWithoutAgentInput
    optimizationRuns?: OptimizationRunUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutModificationProposalsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutModificationProposalsInput, AgentUncheckedCreateWithoutModificationProposalsInput>
  }

  export type AgentUpsertWithoutModificationProposalsInput = {
    update: XOR<AgentUpdateWithoutModificationProposalsInput, AgentUncheckedUpdateWithoutModificationProposalsInput>
    create: XOR<AgentCreateWithoutModificationProposalsInput, AgentUncheckedCreateWithoutModificationProposalsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutModificationProposalsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutModificationProposalsInput, AgentUncheckedUpdateWithoutModificationProposalsInput>
  }

  export type AgentUpdateWithoutModificationProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutModificationProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialCreateManyUserInput = {
    id?: string
    name: string
    value: string
    type: $Enums.CredentialType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    credentialId?: string | null
  }

  export type IntegrationCreateManyUserInput = {
    id?: string
    type: $Enums.IntegrationType
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    accountEmail?: string | null
    accountName?: string | null
    scopes?: IntegrationCreatescopesInput | string[]
    teamId?: string | null
    teamName?: string | null
    botUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: NodeUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput
    connections?: ConnectionUncheckedUpdateManyWithoutWorkflowNestedInput
    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Node?: NodeUpdateManyWithoutCredentialNestedInput
    agents?: AgentUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Node?: NodeUncheckedUpdateManyWithoutCredentialNestedInput
    agents?: AgentUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountEmail?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: IntegrationUpdatescopesInput | string[]
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    botUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeCreateManyCredentialInput = {
    id?: string
    workflowId: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentCreateManyCredentialInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    templateId?: string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type NodeUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    outputConnections?: ConnectionUpdateManyWithoutFromNodeNestedInput
    inputConnections?: ConnectionUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputConnections?: ConnectionUncheckedUpdateManyWithoutFromNodeNestedInput
    inputConnections?: ConnectionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUncheckedUpdateManyWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AgentTemplateUpdateOneWithoutAgentsNestedInput
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NodeCreateManyWorkflowInput = {
    id?: string
    name: string
    type: $Enums.NodeType
    position: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionCreateManyWorkflowInput = {
    id?: string
    fromNodeId: string
    toNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutionCreateManyWorkflowInput = {
    id?: string
    status?: $Enums.ExecutionStatus
    error?: string | null
    errorStack?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    inngestEventId: string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentToolCreateManyWorkflowInput = {
    id?: string
    agentId: string
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: CredentialUpdateOneWithoutNodeNestedInput
    outputConnections?: ConnectionUpdateManyWithoutFromNodeNestedInput
    inputConnections?: ConnectionUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputConnections?: ConnectionUncheckedUpdateManyWithoutFromNodeNestedInput
    inputConnections?: ConnectionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type NodeUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: JsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromNode?: NodeUpdateOneRequiredWithoutOutputConnectionsNestedInput
    toNode?: NodeUpdateOneRequiredWithoutInputConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    toNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    toNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutionUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExecutionUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inngestEventId?: StringFieldUpdateOperationsInput | string
    output?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentToolUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAgentToolsNestedInput
  }

  export type AgentToolUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentToolUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionCreateManyFromNodeInput = {
    id?: string
    workflowId: string
    toNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionCreateManyToNodeInput = {
    id?: string
    workflowId: string
    fromNodeId: string
    fromOutput?: string
    toInput?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionUpdateWithoutFromNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutConnectionsNestedInput
    toNode?: NodeUpdateOneRequiredWithoutInputConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutFromNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    toNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyWithoutFromNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    toNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUpdateWithoutToNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneRequiredWithoutConnectionsNestedInput
    fromNode?: NodeUpdateOneRequiredWithoutOutputConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutToNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyWithoutToNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    fromOutput?: StringFieldUpdateOperationsInput | string
    toInput?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyAgentInput = {
    id?: string
    title?: string | null
    isArchived?: boolean
    isPinned?: boolean
    shareToken?: string | null
    source?: $Enums.ConversationSource
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentToolCreateManyAgentInput = {
    id?: string
    workflowId?: string | null
    composioAppKey?: string | null
    composioActionName?: string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMemoryCreateManyAgentInput = {
    id?: string
    key: string
    value: string
    category?: $Enums.MemoryCategory
    embedding?: AgentMemoryCreateembeddingInput | number[]
    source?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeDocumentCreateManyAgentInput = {
    id?: string
    title: string
    content: string
    source?: string | null
    mimeType?: string
    fileSize?: number | null
    sourceType?: $Enums.KnowledgeSourceType
    externalId?: string | null
    externalUrl?: string | null
    syncStatus?: $Enums.KnowledgeSyncStatus
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTriggerCreateManyAgentInput = {
    id?: string
    name: string
    type: $Enums.TriggerType
    enabled?: boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: string | null
    nextRunAt?: Date | string | null
    lastRunAt?: Date | string | null
    webhookSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentConnectionCreateManySourceAgentInput = {
    id?: string
    targetAgentId: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentConnectionCreateManyTargetAgentInput = {
    id?: string
    sourceAgentId: string
    alias: string
    description: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentSwarmCreateManyAgentInput = {
    id?: string
    name: string
    taskTemplate: string
    status?: $Enums.SwarmStatus
    totalTasks?: number
    completedTasks?: number
    failedTasks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingRecordingCreateManyAgentInput = {
    id?: string
    title: string
    meetingUrl?: string | null
    meetingPlatform: $Enums.MeetingPlatform
    calendarEventId?: string | null
    status?: $Enums.RecordingStatus
    recordingUrl?: string | null
    transcript?: string | null
    summary?: string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentMetricCreateManyAgentInput = {
    id?: string
    date: Date | string
    totalConversations?: number
    totalMessages?: number
    avgMessagesPerConvo?: number
    avgResponseTimeMs?: number
    totalTokensUsed?: number
    toolCallsCount?: number
    toolSuccessRate?: number
    feedbackPositive?: number
    feedbackNegative?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTraceCreateManyAgentInput = {
    id?: string
    conversationId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
  }

  export type AgentInsightCreateManyAgentInput = {
    id?: string
    generatedAt?: Date | string
    timeframeStart: Date | string
    timeframeEnd: Date | string
    clusters: JsonNullValueInput | InputJsonValue
    patterns: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    opportunities: JsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackCreateManyAgentInput = {
    id?: string
    traceId: string
    conversationId: string
    userId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentABTestCreateManyAgentInput = {
    id?: string
    variantAPrompt: string
    variantBPrompt: string
    trafficSplit?: number
    status: $Enums.ABTestStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    variantATraces?: number
    variantBTraces?: number
    variantAScore?: number | null
    variantBScore?: number | null
    winningVariant?: string | null
  }

  export type OptimizationRunCreateManyAgentInput = {
    id?: string
    triggeredAt?: Date | string
    triggeredBy: string
    editPatterns: JsonNullValueInput | InputJsonValue
    promptVariations: JsonNullValueInput | InputJsonValue
    testResults: JsonNullValueInput | InputJsonValue
    recommendation: string
    abTestId?: string | null
    status: string
  }

  export type ModificationProposalCreateManyAgentInput = {
    id?: string
    proposedAt?: Date | string
    type: $Enums.ModificationType
    current: string
    proposed: string
    rationale: string
    impact: string
    status?: $Enums.ProposalStatus
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    appliedAt?: Date | string | null
  }

  export type ConversationUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    activities?: ConversationActivityUncheckedUpdateManyWithoutConversationNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutConversationNestedInput
    evaluation?: ConversationEvaluationUncheckedUpdateOneWithoutConversationNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumConversationSourceFieldUpdateOperationsInput | $Enums.ConversationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentToolUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowUpdateOneWithoutAgentToolsNestedInput
  }

  export type AgentToolUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentToolUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
    composioAppKey?: NullableStringFieldUpdateOperationsInput | string | null
    composioActionName?: NullableStringFieldUpdateOperationsInput | string | null
    composioConfig?: NullableJsonNullValueInput | InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMemoryUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMemoryUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMemoryUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: EnumMemoryCategoryFieldUpdateOperationsInput | $Enums.MemoryCategory
    embedding?: AgentMemoryUpdateembeddingInput | number[]
    source?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeDocumentUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: KnowledgeChunkUpdateManyWithoutDocumentNestedInput
  }

  export type KnowledgeDocumentUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: KnowledgeChunkUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type KnowledgeDocumentUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumKnowledgeSourceTypeFieldUpdateOperationsInput | $Enums.KnowledgeSourceType
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumKnowledgeSyncStatusFieldUpdateOperationsInput | $Enums.KnowledgeSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTriggerUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionUpdateWithoutSourceAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetAgent?: AgentUpdateOneRequiredWithoutConnectedFromNestedInput
  }

  export type AgentConnectionUncheckedUpdateWithoutSourceAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetAgentId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionUncheckedUpdateManyWithoutSourceAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetAgentId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionUpdateWithoutTargetAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceAgent?: AgentUpdateOneRequiredWithoutConnectedToNestedInput
  }

  export type AgentConnectionUncheckedUpdateWithoutTargetAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAgentId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConnectionUncheckedUpdateManyWithoutTargetAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAgentId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentSwarmUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: SwarmTaskUpdateManyWithoutSwarmNestedInput
  }

  export type AgentSwarmUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: SwarmTaskUncheckedUpdateManyWithoutSwarmNestedInput
  }

  export type AgentSwarmUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    taskTemplate?: StringFieldUpdateOperationsInput | string
    status?: EnumSwarmStatusFieldUpdateOperationsInput | $Enums.SwarmStatus
    totalTasks?: IntFieldUpdateOperationsInput | number
    completedTasks?: IntFieldUpdateOperationsInput | number
    failedTasks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRecordingUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    meetingPlatform?: EnumMeetingPlatformFieldUpdateOperationsInput | $Enums.MeetingPlatform
    calendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: JsonNullValueInput | InputJsonValue
    participants?: JsonNullValueInput | InputJsonValue
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMetricUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMetricUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentMetricUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalConversations?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgMessagesPerConvo?: FloatFieldUpdateOperationsInput | number
    avgResponseTimeMs?: IntFieldUpdateOperationsInput | number
    totalTokensUsed?: IntFieldUpdateOperationsInput | number
    toolCallsCount?: IntFieldUpdateOperationsInput | number
    toolSuccessRate?: FloatFieldUpdateOperationsInput | number
    feedbackPositive?: IntFieldUpdateOperationsInput | number
    feedbackNegative?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTraceUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    conversation?: ConversationUpdateOneRequiredWithoutTracesNestedInput
    aiEvents?: AiEventUpdateManyWithoutTraceNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    aiEvents?: AiEventUncheckedUpdateManyWithoutTraceNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentInsightUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
  }

  export type AgentInsightUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    clusters?: JsonNullValueInput | InputJsonValue
    patterns?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    opportunities?: JsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    trace?: AgentTraceUpdateOneRequiredWithoutFeedbacksNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type AgentFeedbackUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentABTestUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentABTestUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentABTestUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantAPrompt?: StringFieldUpdateOperationsInput | string
    variantBPrompt?: StringFieldUpdateOperationsInput | string
    trafficSplit?: FloatFieldUpdateOperationsInput | number
    status?: EnumABTestStatusFieldUpdateOperationsInput | $Enums.ABTestStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantATraces?: IntFieldUpdateOperationsInput | number
    variantBTraces?: IntFieldUpdateOperationsInput | number
    variantAScore?: NullableFloatFieldUpdateOperationsInput | number | null
    variantBScore?: NullableFloatFieldUpdateOperationsInput | number | null
    winningVariant?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OptimizationRunUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OptimizationRunUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OptimizationRunUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: StringFieldUpdateOperationsInput | string
    editPatterns?: JsonNullValueInput | InputJsonValue
    promptVariations?: JsonNullValueInput | InputJsonValue
    testResults?: JsonNullValueInput | InputJsonValue
    recommendation?: StringFieldUpdateOperationsInput | string
    abTestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ModificationProposalUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModificationProposalUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModificationProposalUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    current?: StringFieldUpdateOperationsInput | string
    proposed?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationActivityCreateManyConversationInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: boolean
    confirmedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AgentTraceCreateManyConversationInput = {
    id?: string
    agentId: string
    userId: string
    workspaceId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: number
    maxSteps?: number
    totalTokensIn?: number
    totalTokensOut?: number
    totalCost?: number
    latencyMs?: number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: number
    toolFailures?: number
    l1Passed?: boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: boolean
    l3Blocked?: boolean | null
    feedbackScore?: number | null
    feedbackComment?: string | null
    userEdited?: boolean
    editDiff?: string | null
  }

  export type AgentFeedbackCreateManyConversationInput = {
    id?: string
    traceId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationActivityUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationActivityUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationActivityUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    requiresConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTraceUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutTracesNestedInput
    aiEvents?: AiEventUpdateManyWithoutTraceNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
    aiEvents?: AiEventUncheckedUpdateManyWithoutTraceNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutTraceNestedInput
  }

  export type AgentTraceUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTraceStatusFieldUpdateOperationsInput | $Enums.TraceStatus
    steps?: JsonNullValueInput | InputJsonValue
    totalSteps?: IntFieldUpdateOperationsInput | number
    maxSteps?: IntFieldUpdateOperationsInput | number
    totalTokensIn?: IntFieldUpdateOperationsInput | number
    totalTokensOut?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    toolCalls?: JsonNullValueInput | InputJsonValue
    toolSuccesses?: IntFieldUpdateOperationsInput | number
    toolFailures?: IntFieldUpdateOperationsInput | number
    l1Passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    l1Failures?: NullableJsonNullValueInput | InputJsonValue
    l2Score?: NullableFloatFieldUpdateOperationsInput | number | null
    l2Breakdown?: NullableJsonNullValueInput | InputJsonValue
    l3Triggered?: BoolFieldUpdateOperationsInput | boolean
    l3Blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    feedbackComment?: NullableStringFieldUpdateOperationsInput | string | null
    userEdited?: BoolFieldUpdateOperationsInput | boolean
    editDiff?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentFeedbackUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    trace?: AgentTraceUpdateOneRequiredWithoutFeedbacksNestedInput
    agent?: AgentUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type AgentFeedbackUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    traceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeChunkCreateManyDocumentInput = {
    id?: string
    content: string
    embedding?: KnowledgeChunkCreateembeddingInput | number[]
    position: number
    pageNumber?: number | null
    heading?: string | null
    createdAt?: Date | string
  }

  export type KnowledgeChunkUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embedding?: KnowledgeChunkUpdateembeddingInput | number[]
    position?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    context?: string | null
    model?: $Enums.AgentModel
    temperature?: number
    safeMode?: boolean
    llmTier?: string | null
    maxStepsPerRun?: number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: string | null
    avatar?: string | null
    tags?: AgentCreatetagsInput | string[]
    isFavorite?: boolean
    isEnabled?: boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    credentialId?: string | null
  }

  export type AgentUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentsNestedInput
    credential?: CredentialUpdateOneWithoutAgentsNestedInput
    conversations?: ConversationUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutAgentNestedInput
    agentTools?: AgentToolUncheckedUpdateManyWithoutAgentNestedInput
    memories?: AgentMemoryUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeDocuments?: KnowledgeDocumentUncheckedUpdateManyWithoutAgentNestedInput
    knowledgeSettings?: KnowledgeSettingsUncheckedUpdateOneWithoutAgentNestedInput
    triggers?: AgentTriggerUncheckedUpdateManyWithoutAgentNestedInput
    embed?: AgentEmbedUncheckedUpdateOneWithoutAgentNestedInput
    connectedTo?: AgentConnectionUncheckedUpdateManyWithoutSourceAgentNestedInput
    connectedFrom?: AgentConnectionUncheckedUpdateManyWithoutTargetAgentNestedInput
    swarms?: AgentSwarmUncheckedUpdateManyWithoutAgentNestedInput
    emailAddress?: AgentEmailAddressUncheckedUpdateOneWithoutAgentNestedInput
    meetingRecordings?: MeetingRecordingUncheckedUpdateManyWithoutAgentNestedInput
    phoneNumber?: AgentPhoneNumberUncheckedUpdateOneWithoutAgentNestedInput
    metrics?: AgentMetricUncheckedUpdateManyWithoutAgentNestedInput
    traces?: AgentTraceUncheckedUpdateManyWithoutAgentNestedInput
    insights?: AgentInsightUncheckedUpdateManyWithoutAgentNestedInput
    feedbacks?: AgentFeedbackUncheckedUpdateManyWithoutAgentNestedInput
    abTests?: AgentABTestUncheckedUpdateManyWithoutAgentNestedInput
    optimizationRuns?: OptimizationRunUncheckedUpdateManyWithoutAgentNestedInput
    modificationProposals?: ModificationProposalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    model?: EnumAgentModelFieldUpdateOperationsInput | $Enums.AgentModel
    temperature?: FloatFieldUpdateOperationsInput | number
    safeMode?: BoolFieldUpdateOperationsInput | boolean
    llmTier?: NullableStringFieldUpdateOperationsInput | string | null
    maxStepsPerRun?: NullableIntFieldUpdateOperationsInput | number | null
    evalRules?: NullableJsonNullValueInput | InputJsonValue
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AgentUpdatetagsInput | string[]
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    flowData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SwarmTaskCreateManySwarmInput = {
    id?: string
    input: JsonNullValueInput | InputJsonValue
    status?: $Enums.SwarmTaskStatus
    output?: string | null
    error?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SwarmTaskUpdateWithoutSwarmInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwarmTaskUncheckedUpdateWithoutSwarmInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwarmTaskUncheckedUpdateManyWithoutSwarmInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: JsonNullValueInput | InputJsonValue
    status?: EnumSwarmTaskStatusFieldUpdateOperationsInput | $Enums.SwarmTaskStatus
    output?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCallCreateManyPhoneNumberInput = {
    id?: string
    direction: $Enums.CallDirection
    fromNumber: string
    toNumber: string
    status?: $Enums.CallStatus
    twilioCallSid?: string | null
    recordingUrl?: string | null
    transcript?: string | null
    conversationId?: string | null
    duration?: number | null
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type PhoneCallUpdateWithoutPhoneNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PhoneCallUncheckedUpdateWithoutPhoneNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PhoneCallUncheckedUpdateManyWithoutPhoneNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiEventCreateManyTraceInput = {
    id?: string
    agentId?: string | null
    conversationId?: string | null
    userId: string
    workspaceId?: string | null
    model: string
    tier: string
    tokensIn: number
    tokensOut: number
    cost: number
    latencyMs: number
    stepNumber?: number
    action: string
    toolName?: string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: number
    evalResult?: string
    timestamp?: Date | string
  }

  export type AgentFeedbackCreateManyTraceInput = {
    id?: string
    conversationId: string
    userId: string
    agentId: string
    type: $Enums.FeedbackType
    timestamp?: Date | string
    originalOutput: string
    userEdit?: string | null
    correctionText?: string | null
    stepNumber: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiEventUpdateWithoutTraceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiEventUncheckedUpdateWithoutTraceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiEventUncheckedUpdateManyWithoutTraceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    stepNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    toolInput?: NullableJsonNullValueInput | InputJsonValue
    toolOutput?: NullableJsonNullValueInput | InputJsonValue
    stepsUsed?: IntFieldUpdateOperationsInput | number
    evalResult?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentFeedbackUpdateWithoutTraceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutFeedbacksNestedInput
    agent?: AgentUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type AgentFeedbackUncheckedUpdateWithoutTraceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentFeedbackUncheckedUpdateManyWithoutTraceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOutput?: StringFieldUpdateOperationsInput | string
    userEdit?: NullableStringFieldUpdateOperationsInput | string | null
    correctionText?: NullableStringFieldUpdateOperationsInput | string | null
    stepNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}