import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ agentId: string }> }
) {
  try {
    const session = await auth.api.getSession({ headers: req.headers });
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { agentId } = await params;
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status") || undefined;

    // Verify agent belongs to user
    const agent = await prisma.agent.findUnique({
      where: { id: agentId },
      select: { userId: true },
    });

    if (!agent || agent.userId !== session.user.id) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 });
    }

    // Fetch modification proposals
    const proposals = await prisma.modificationProposal.findMany({
      where: {
        agentId,
        ...(status && { status: status.toUpperCase() as "PENDING" | "APPROVED" | "REJECTED" | "APPLIED" }),
      },
      orderBy: { proposedAt: "desc" },
      take: 20,
    });

    return NextResponse.json({ proposals });
  } catch (error) {
    console.error("Error fetching proposals:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch proposals" },
      { status: 500 }
    );
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ agentId: string }> }
) {
  try {
    const session = await auth.api.getSession({ headers: req.headers });
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { agentId } = await params;
    const body = await req.json();
    const { days = 7 } = body;

    // Verify agent belongs to user
    const agent = await prisma.agent.findUnique({
      where: { id: agentId },
      select: {
        userId: true,
        workspaceId: true,
        systemPrompt: true,
        model: true,
        temperature: true,
      },
    });

    if (!agent || agent.userId !== session.user.id) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 });
    }

    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    // Fetch feedback
    const feedback = await prisma.agentFeedback.findMany({
      where: {
        agentId,
        timestamp: { gte: startDate },
      },
      select: {
        id: true,
        type: true,
        correctionText: true,
      },
    });

    // Calculate metrics from traces
    const traces = await prisma.agentTrace.findMany({
      where: {
        agentId,
        ...(agent.workspaceId ? { workspaceId: agent.workspaceId } : {}),
        startedAt: { gte: startDate },
      },
      select: {
        status: true,
        totalCost: true,
      },
    });

    const successCount = traces.filter((t) => t.status === "COMPLETED").length;
    const metrics = {
      success_rate: traces.length > 0 ? successCount / traces.length : 0,
      cost: traces.reduce((sum, t) => sum + t.totalCost, 0),
    };

    // Return analysis results (proposals would be generated by the core engine)
    return NextResponse.json({
      proposals: [],
      analysis: {
        feedbackCount: feedback.length,
        tracesAnalyzed: traces.length,
        metrics,
      },
    });
  } catch (error) {
    console.error("Error generating proposals:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to generate proposals" },
      { status: 500 }
    );
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: Promise<{ agentId: string }> }
) {
  try {
    const session = await auth.api.getSession({ headers: req.headers });
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { agentId } = await params;
    const body = await req.json();
    const { proposalId, action } = body; // action: "approve" | "reject"

    if (!proposalId || !action) {
      return NextResponse.json(
        { error: "Missing proposalId or action" },
        { status: 400 }
      );
    }

    // Verify agent belongs to user
    const agent = await prisma.agent.findUnique({
      where: { id: agentId },
      select: { userId: true },
    });

    if (!agent || agent.userId !== session.user.id) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 });
    }

    // Fetch proposal
    const proposal = await prisma.modificationProposal.findUnique({
      where: { id: proposalId },
    });

    if (!proposal || proposal.agentId !== agentId) {
      return NextResponse.json({ error: "Proposal not found" }, { status: 404 });
    }

    if (action === "approve") {
      // Apply the proposed change to the agent based on modification type
      const updateData: Record<string, unknown> = {};
      if (proposal.type === "PROMPT_REFINEMENT") {
        updateData.systemPrompt = proposal.proposed;
      } else if (proposal.type === "ADJUST_TEMPERATURE") {
        const temp = parseFloat(proposal.proposed);
        if (!isNaN(temp)) updateData.temperature = temp;
      }

      if (Object.keys(updateData).length > 0) {
        await prisma.agent.update({
          where: { id: agentId },
          data: updateData,
        });
      }

      // Update proposal status
      await prisma.modificationProposal.update({
        where: { id: proposalId },
        data: {
          status: "APPLIED",
          reviewedAt: new Date(),
          reviewedBy: session.user.id,
          appliedAt: new Date(),
        },
      });

      return NextResponse.json({
        success: true,
        message: "Proposal applied successfully",
      });
    } else if (action === "reject") {
      await prisma.modificationProposal.update({
        where: { id: proposalId },
        data: {
          status: "REJECTED",
          reviewedAt: new Date(),
          reviewedBy: session.user.id,
        },
      });

      return NextResponse.json({
        success: true,
        message: "Proposal rejected",
      });
    } else {
      return NextResponse.json(
        { error: "Invalid action. Must be 'approve' or 'reject'" },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Error updating proposal:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to update proposal" },
      { status: 500 }
    );
  }
}
